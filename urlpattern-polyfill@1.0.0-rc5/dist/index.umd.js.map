{"version":3,"file":"index.umd.js","sources":["../src/path-to-regex-modified.ts","../src/url-utils.ts","../src/url-pattern-parser.ts","../src/url-pattern.ts"],"sourcesContent":["/**\n * Tokenizer results.\n */\nexport interface LexToken {\n  type:\n    | \"OPEN\"\n    | \"CLOSE\"\n    | \"PATTERN\"\n    | \"NAME\"\n    | \"CHAR\"\n    | \"ESCAPED_CHAR\"\n    | \"MODIFIER\"\n    | \"ASTERISK\"\n    | \"INVALID_CHAR\"\n    | \"END\";\n  index: number;\n  value: string;\n}\n\n// Note, the `//u` suffix triggers this typescript linting bug:\n//\n//  https://github.com/buzinas/tslint-eslint-rules/issues/289\n//\n// This requires disabling the no-empty-character-class lint rule.\nconst regexIdentifierStart = /[$_\\p{ID_Start}]/u;\nconst regexIdentifierPart = /[$_\\u200C\\u200D\\p{ID_Continue}]/u;\n\nfunction isASCII(str: string, extended: boolean) {\n  return (extended ? /^[\\x00-\\xFF]*$/ : /^[\\x00-\\x7F]*$/).test(str);\n}\n\n/**\n * Tokenize input string.\n */\nexport function lexer(str: string, lenient: boolean = false): LexToken[] {\n  const tokens: LexToken[] = [];\n  let i = 0;\n\n  while (i < str.length) {\n    const char = str[i];\n\n    const ErrorOrInvalid = function (msg: string) {\n      if (!lenient) throw new TypeError(msg);\n      tokens.push({ type: \"INVALID_CHAR\", index: i, value: str[i++] });\n    };\n\n    if (char === \"*\") {\n      tokens.push({ type: \"ASTERISK\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"+\" || char === \"?\") {\n      tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"\\\\\") {\n      tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"{\") {\n      tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"}\") {\n      tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \":\") {\n      let name = \"\";\n      let j = i + 1;\n\n      while (j < str.length) {\n        const code = str.substr(j, 1);\n\n        if (\n          (j === i + 1 && regexIdentifierStart.test(code)) ||\n          (j !== i + 1 && regexIdentifierPart.test(code))\n        ) {\n          name += str[j++];\n          continue;\n        }\n\n        break;\n      }\n\n      if (!name) {\n        ErrorOrInvalid(`Missing parameter name at ${i}`);\n        continue;\n      }\n\n      tokens.push({ type: \"NAME\", index: i, value: name });\n      i = j;\n      continue;\n    }\n\n    if (char === \"(\") {\n      let count = 1;\n      let pattern = \"\";\n      let j = i + 1;\n      let error = false;\n\n      if (str[j] === \"?\") {\n        ErrorOrInvalid(`Pattern cannot start with \"?\" at ${j}`);\n        continue;\n      }\n\n      while (j < str.length) {\n        if (!isASCII(str[j], false)) {\n          ErrorOrInvalid(`Invalid character '${str[j]}' at ${j}.`);\n          error = true;\n          break;\n        }\n\n        if (str[j] === \"\\\\\") {\n          pattern += str[j++] + str[j++];\n          continue;\n        }\n\n        if (str[j] === \")\") {\n          count--;\n          if (count === 0) {\n            j++;\n            break;\n          }\n        } else if (str[j] === \"(\") {\n          count++;\n          if (str[j + 1] !== \"?\") {\n            ErrorOrInvalid(`Capturing groups are not allowed at ${j}`);\n            error = true;\n            break;\n          }\n        }\n\n        pattern += str[j++];\n      }\n\n      if (error) {\n        continue;\n      }\n\n      if (count) {\n        ErrorOrInvalid(`Unbalanced pattern at ${i}`);\n        continue;\n      }\n      if (!pattern) {\n        ErrorOrInvalid(`Missing pattern at ${i}`);\n        continue;\n      }\n\n      tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n      i = j;\n      continue;\n    }\n\n    tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n  }\n\n  tokens.push({ type: \"END\", index: i, value: \"\" });\n\n  return tokens;\n}\n\n/**\n * Callback type that is invoked for every plain text part of the pattern.\n * This is intended to be used to apply URL canonicalization to the pattern\n * itself.  This is different from the encode callback used to encode group\n * values passed to compile, match, etc.\n */\ntype EncodePartCallback = (value: string) => string;\n\nexport interface ParseOptions {\n  /**\n   * Set the default delimiter for repeat parameters. (default: `'/'`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters to automatically consider prefixes when parsing.\n   */\n  prefixes?: string;\n\n  /**\n   * Encoding callback to apply to each plaintext part of the pattern.\n   */\n  encodePart?: EncodePartCallback;\n}\n\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str: string, options: ParseOptions = {}): Token[] {\n  const tokens = lexer(str);\n  const { prefixes = \"./\" } = options;\n  const defaultPattern = `[^${escapeString(options.delimiter || \"/#?\")}]+?`;\n  const result: Token[] = [];\n  let key = 0;\n  let i = 0;\n  let path = \"\";\n  let nameSet = new Set();\n\n  const tryConsume = (type: LexToken[\"type\"]): string | undefined => {\n    if (i < tokens.length && tokens[i].type === type) return tokens[i++].value;\n  };\n\n  const tryConsumeModifier = (): string | undefined => {\n    const r = tryConsume(\"MODIFIER\");\n    if (r) {\n      return r;\n    }\n    return tryConsume(\"ASTERISK\");\n  };\n\n  const mustConsume = (type: LexToken[\"type\"]): string => {\n    const value = tryConsume(type);\n    if (value !== undefined) return value;\n    const { type: nextType, index } = tokens[i];\n    throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}`);\n  };\n\n  const consumeText = (): string => {\n    let result = \"\";\n    let value: string | undefined;\n    // tslint:disable-next-line\n    while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n      result += value;\n    }\n    return result;\n  };\n\n  const DefaultEncodePart = (value: string): string => {\n    return value;\n  };\n  const encodePart = options.encodePart || DefaultEncodePart;\n\n  while (i < tokens.length) {\n    const char = tryConsume(\"CHAR\");\n    const name = tryConsume(\"NAME\");\n\n    let pattern = tryConsume(\"PATTERN\");\n    if (!name && !pattern && tryConsume(\"ASTERISK\")) {\n      pattern = \".*\";\n    }\n\n    if (name || pattern) {\n      let prefix = char || \"\";\n\n      if (prefixes.indexOf(prefix) === -1) {\n        path += prefix;\n        prefix = \"\";\n      }\n\n      if (path) {\n        result.push(encodePart(path));\n        path = \"\";\n      }\n\n      const finalName = name || key++;\n      if (nameSet.has(finalName)) {\n        throw new TypeError(`Duplicate name '${finalName}'.`);\n      }\n      nameSet.add(finalName);\n\n      result.push({\n        name: finalName,\n        prefix: encodePart(prefix),\n        suffix: \"\",\n        pattern: pattern || defaultPattern,\n        modifier: tryConsumeModifier() || \"\",\n      });\n      continue;\n    }\n\n    const value = char || tryConsume(\"ESCAPED_CHAR\");\n    if (value) {\n      path += value;\n      continue;\n    }\n\n    const open = tryConsume(\"OPEN\");\n    if (open) {\n      const prefix = consumeText();\n      const name = tryConsume(\"NAME\") || \"\";\n      let pattern = tryConsume(\"PATTERN\") || \"\";\n      if (!name && !pattern && tryConsume(\"ASTERISK\")) {\n        pattern = \".*\";\n      }\n      const suffix = consumeText();\n\n      mustConsume(\"CLOSE\");\n      const modifier = tryConsumeModifier() || \"\";\n\n      if (!name && !pattern && !modifier) {\n        path += prefix;\n        continue;\n      }\n\n      if (!name && !pattern && !prefix) {\n        continue;\n      }\n\n      if (path) {\n        result.push(encodePart(path));\n        path = \"\";\n      }\n\n      result.push({\n        name: name || (pattern ? key++ : \"\"),\n        pattern: name && !pattern ? defaultPattern : pattern,\n        prefix: encodePart(prefix),\n        suffix: encodePart(suffix),\n        modifier: modifier,\n      });\n      continue;\n    }\n\n    if (path) {\n      result.push(encodePart(path));\n      path = \"\";\n    }\n\n    mustConsume(\"END\");\n  }\n\n  return result;\n}\n\nexport interface TokensToFunctionOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * Function for encoding input strings for output.\n   */\n  encode?: (value: string, token: Key) => string;\n  /**\n   * When `false` the function can produce an invalid (unmatched) path. (default: `true`)\n   */\n  validate?: boolean;\n}\n\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile<P extends object = object>(\n  str: string,\n  options?: ParseOptions & TokensToFunctionOptions\n) {\n  return tokensToFunction<P>(parse(str, options), options);\n}\n\nexport type PathFunction<P extends object = object> = (data?: P) => string;\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nexport function tokensToFunction<P extends object = object>(\n  tokens: Token[],\n  options: TokensToFunctionOptions = {}\n): PathFunction<P> {\n  const reFlags = flags(options);\n  const { encode = (x: string) => x, validate = true } = options;\n\n  // Compile all the tokens into regexps.\n  const matches = tokens.map((token) => {\n    if (typeof token === \"object\") {\n      return new RegExp(`^(?:${token.pattern})$`, reFlags);\n    }\n  });\n\n  return (data: Record<string, any> | null | undefined) => {\n    let path = \"\";\n\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n\n      if (typeof token === \"string\") {\n        path += token;\n        continue;\n      }\n\n      const value = data ? data[token.name] : undefined;\n      const optional = token.modifier === \"?\" || token.modifier === \"*\";\n      const repeat = token.modifier === \"*\" || token.modifier === \"+\";\n\n      if (Array.isArray(value)) {\n        if (!repeat) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to not repeat, but got an array`\n          );\n        }\n\n        if (value.length === 0) {\n          if (optional) continue;\n\n          throw new TypeError(`Expected \"${token.name}\" to not be empty`);\n        }\n\n        for (let j = 0; j < value.length; j++) {\n          const segment = encode(value[j], token);\n\n          if (validate && !(matches[i] as RegExp).test(segment)) {\n            throw new TypeError(\n              `Expected all \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`\n            );\n          }\n\n          path += token.prefix + segment + token.suffix;\n        }\n\n        continue;\n      }\n\n      if (typeof value === \"string\" || typeof value === \"number\") {\n        const segment = encode(String(value), token);\n\n        if (validate && !(matches[i] as RegExp).test(segment)) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`\n          );\n        }\n\n        path += token.prefix + segment + token.suffix;\n        continue;\n      }\n\n      if (optional) continue;\n\n      const typeOfMessage = repeat ? \"an array\" : \"a string\";\n      throw new TypeError(`Expected \"${token.name}\" to be ${typeOfMessage}`);\n    }\n\n    return path;\n  };\n}\n\nexport interface RegexpToFunctionOptions {\n  /**\n   * Function for decoding strings for params.\n   */\n  decode?: (value: string, token: Key) => string;\n}\n\n/**\n * A match result contains data about the path match.\n */\nexport interface MatchResult<P extends object = object> {\n  path: string;\n  index: number;\n  params: P;\n}\n\n/**\n * A match is either `false` (no match) or a match result.\n */\nexport type Match<P extends object = object> = false | MatchResult<P>;\n\n/**\n * The match function takes a string and returns whether it matched the path.\n */\nexport type MatchFunction<P extends object = object> = (\n  path: string\n) => Match<P>;\n\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match<P extends object = object>(\n  str: Path,\n  options?: ParseOptions & TokensToRegexpOptions & RegexpToFunctionOptions\n) {\n  const keys: Key[] = [];\n  const re = pathToRegexp(str, keys, options);\n  return regexpToFunction<P>(re, keys, options);\n}\n\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nexport function regexpToFunction<P extends object = object>(\n  re: RegExp,\n  keys: Key[],\n  options: RegexpToFunctionOptions = {}\n): MatchFunction<P> {\n  const { decode = (x: string) => x } = options;\n\n  return function (pathname: string) {\n    const m = re.exec(pathname);\n    if (!m) return false;\n\n    const { 0: path, index } = m;\n    const params = Object.create(null);\n\n    for (let i = 1; i < m.length; i++) {\n      // tslint:disable-next-line\n      if (m[i] === undefined) continue;\n\n      const key = keys[i - 1];\n\n      if (key.modifier === \"*\" || key.modifier === \"+\") {\n        params[key.name] = m[i].split(key.prefix + key.suffix).map((value) => {\n          return decode(value, key);\n        });\n      } else {\n        params[key.name] = decode(m[i], key);\n      }\n    }\n\n    return { path, index, params };\n  };\n}\n\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str: string) {\n  return str.replace(/([.+*?^${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options?: { sensitive?: boolean }) {\n  return options && options.sensitive ? \"u\" : \"ui\";\n}\n\n/**\n * Metadata about a key.\n */\nexport interface Key {\n  name: string | number;\n  prefix: string;\n  suffix: string;\n  pattern: string;\n  modifier: string;\n}\n\n/**\n * A token is a string (nothing special) or key metadata (capture group).\n */\nexport type Token = string | Key;\n\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path: RegExp, keys?: Key[]): RegExp {\n  if (!keys) return path;\n\n  const groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n\n  let index = 0;\n  let execResult = groupsRegex.exec(path.source);\n  while (execResult) {\n    keys.push({\n      // Use parenthesized substring match if available, index otherwise\n      name: execResult[1] || index++,\n      prefix: \"\",\n      suffix: \"\",\n      modifier: \"\",\n      pattern: \"\",\n    });\n    execResult = groupsRegex.exec(path.source);\n  }\n\n  return path;\n}\n\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(\n  paths: Array<string | RegExp>,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions\n): RegExp {\n  const parts = paths.map((path) => pathToRegexp(path, keys, options).source);\n  return new RegExp(`(?:${parts.join(\"|\")})`, flags(options));\n}\n\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(\n  path: string,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions\n) {\n  return tokensToRegexp(parse(path, options), keys, options);\n}\n\nexport interface TokensToRegexpOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * When `true` the regexp won't allow an optional trailing delimiter to match. (default: `false`)\n   */\n  strict?: boolean;\n  /**\n   * When `true` the regexp will match to the end of the string. (default: `true`)\n   */\n  end?: boolean;\n  /**\n   * When `true` the regexp will match from the beginning of the string. (default: `true`)\n   */\n  start?: boolean;\n  /**\n   * Sets the final character for non-ending optimistic matches. (default: `/`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters that can also be \"end\" characters.\n   */\n  endsWith?: string;\n  /**\n   * Encode path tokens for use in the `RegExp`.\n   */\n  encode?: (value: string) => string;\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nexport function tokensToRegexp(\n  tokens: Token[],\n  keys?: Key[],\n  options: TokensToRegexpOptions = {}\n) {\n  const {\n    strict = false,\n    start = true,\n    end = true,\n    encode = (x: string) => x,\n  } = options;\n  const endsWith = `[${escapeString(options.endsWith || \"\")}]|$`;\n  const delimiter = `[${escapeString(options.delimiter || \"/#?\")}]`;\n  let route = start ? \"^\" : \"\";\n\n  // Iterate over the tokens and create our regexp string.\n  for (const token of tokens) {\n    if (typeof token === \"string\") {\n      route += escapeString(encode(token));\n    } else {\n      const prefix = escapeString(encode(token.prefix));\n      const suffix = escapeString(encode(token.suffix));\n\n      if (token.pattern) {\n        if (keys) keys.push(token);\n\n        if (prefix || suffix) {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            const mod = token.modifier === \"*\" ? \"?\" : \"\";\n            route += `(?:${prefix}((?:${token.pattern})(?:${suffix}${prefix}(?:${token.pattern}))*)${suffix})${mod}`;\n          } else {\n            route += `(?:${prefix}(${token.pattern})${suffix})${token.modifier}`;\n          }\n        } else {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            route += `((?:${token.pattern})${token.modifier})`;\n          } else {\n            route += `(${token.pattern})${token.modifier}`;\n          }\n        }\n      } else {\n        route += `(?:${prefix}${suffix})${token.modifier}`;\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += `${delimiter}?`;\n\n    route += !options.endsWith ? \"$\" : `(?=${endsWith})`;\n  } else {\n    const endToken = tokens[tokens.length - 1];\n    const isEndDelimited =\n      typeof endToken === \"string\"\n        ? delimiter.indexOf(endToken[endToken.length - 1]) > -1\n        : // tslint:disable-next-line\n          endToken === undefined;\n\n    if (!strict) {\n      route += `(?:${delimiter}(?=${endsWith}))?`;\n    }\n\n    if (!isEndDelimited) {\n      route += `(?=${delimiter}|${endsWith})`;\n    }\n  }\n\n  return new RegExp(route, flags(options));\n}\n\n/**\n * Supported `path-to-regexp` input types.\n */\nexport type Path = string | RegExp | Array<string | RegExp>;\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(\n  path: Path,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions\n) {\n  if (path instanceof RegExp) return regexpToRegexp(path, keys);\n  if (Array.isArray(path)) return arrayToRegexp(path, keys, options);\n  return stringToRegexp(path, keys, options);\n}\n","import {ParseOptions, TokensToRegexpOptions} from './path-to-regex-modified';\n\n// default to strict mode and case sensitivity.  In addition, most\n// components have no concept of a delimiter or prefix character.\nexport const DEFAULT_OPTIONS: TokensToRegexpOptions & ParseOptions = {\n  delimiter: '',\n  prefixes: '',\n  sensitive: true,\n  strict: true,\n};\n\n// The options to use for hostname patterns.  This uses a\n// \".\" delimiter controlling how far a named group like \":bar\" will match\n// by default.  Note, hostnames are case insensitive but we require case\n// sensitivity here.  This assumes that the hostname values have already\n// been normalized to lower case as in URL().\nexport const HOSTNAME_OPTIONS: TokensToRegexpOptions & ParseOptions = {\n  delimiter: '.',\n  prefixes: '',\n  sensitive: true,\n  strict: true,\n};\n\n// The options to use for pathname patterns.  This uses a\n// \"/\" delimiter controlling how far a named group like \":bar\" will match\n// by default.  It also configures \"/\" to be treated as an automatic\n// prefix before groups.\nexport const PATHNAME_OPTIONS: TokensToRegexpOptions & ParseOptions = {\n  delimiter: '/',\n  prefixes: '/',\n  sensitive: true,\n  strict: true,\n};\n\n// Utility function to determine if a pathname is absolute or not.  For\n// URL values this mainly consists of a check for a leading slash.  For\n// patterns we do some additional checking for escaped or grouped slashes.\nexport function isAbsolutePathname(pathname: string, isPattern: boolean): boolean {\n  if (!pathname.length) {\n    return false;\n  }\n\n  if (pathname[0] === '/') {\n    return true;\n  }\n\n  if (!isPattern) {\n    return false;\n  }\n\n  if (pathname.length < 2) {\n    return false;\n  }\n\n  // Patterns treat escaped slashes and slashes within an explicit grouping as\n  // valid leading slashes.  For example, \"\\/foo\" or \"{/foo}\".  Patterns do\n  // not consider slashes within a custom regexp group as valid for the leading\n  // pathname slash for now.  To support that we would need to be able to\n  // detect things like \":name_123(/foo)\" as a valid leading group in a pattern,\n  // but that is considered too complex for now.\n  if ((pathname[0] == '\\\\' || pathname[0] == '{') && pathname[1] == '/') {\n    return true;\n  }\n\n  return false;\n}\n\nfunction maybeStripPrefix(value: string, prefix: string): string {\n  if (value.startsWith(prefix)) {\n    return value.substring(prefix.length, value.length);\n  }\n  return value;\n}\n\nfunction maybeStripSuffix(value: string, suffix: string): string {\n  if (value.endsWith(suffix)) {\n    return value.substr(0, value.length - suffix.length);\n  }\n  return value;\n}\n\nexport function treatAsIPv6Hostname(value: string | undefined): boolean {\n  if (!value || value.length < 2) {\n    return false;\n  }\n\n  if (value[0] === '[') {\n    return true;\n  }\n\n  if ((value[0] === '\\\\' || value[0] === '{') &&\n      value[1] === '[') {\n    return true;\n  }\n\n  return false;\n}\n\nexport const SPECIAL_SCHEMES = [\n  'ftp',\n  'file',\n  'http',\n  'https',\n  'ws',\n  'wss',\n];\n\nexport function isSpecialScheme(protocol_regexp: any) {\n  if (!protocol_regexp) {\n    return true;\n  }\n  for (const scheme of SPECIAL_SCHEMES) {\n    if (protocol_regexp.test(scheme)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function canonicalizeHash(hash: string, isPattern: boolean) {\n  hash = maybeStripPrefix(hash, '#');\n  if (isPattern || hash === '') {\n    return hash;\n  }\n  const url = new URL(\"https://example.com\");\n  url.hash = hash;\n  return url.hash ? url.hash.substring(1, url.hash.length) : '';\n}\n\nexport function canonicalizeSearch(search: string, isPattern: boolean) {\n  search = maybeStripPrefix(search, '?');\n  if (isPattern || search === '') {\n    return search;\n  }\n  const url = new URL(\"https://example.com\");\n  url.search = search;\n  return url.search ? url.search.substring(1, url.search.length) : '';\n}\n\nexport function canonicalizeHostname(hostname: string, isPattern: boolean) {\n  if (isPattern || hostname === '') {\n    return hostname;\n  }\n  if (treatAsIPv6Hostname(hostname)) {\n    return ipv6HostnameEncodeCallback(hostname);\n  } else {\n    return hostnameEncodeCallback(hostname);\n  }\n}\n\nexport function canonicalizePassword(password: string, isPattern: boolean) {\n  if (isPattern || password === '') {\n    return password;\n  }\n  const url = new URL(\"https://example.com\");\n  url.password = password;\n  return url.password;\n}\n\nexport function canonicalizeUsername(username: string, isPattern: boolean) {\n  if (isPattern || username === '') {\n    return username;\n  }\n  const url = new URL(\"https://example.com\");\n  url.username = username;\n  return url.username;\n}\n\nexport function canonicalizePathname(pathname: string, protocol: string | undefined,\n                                     isPattern: boolean) {\n  if (isPattern || pathname === '') {\n    return pathname;\n  }\n\n  if (protocol && !SPECIAL_SCHEMES.includes(protocol)) {\n    const url = new URL(`${protocol}:${pathname}`);\n    return url.pathname;\n  }\n\n  const leadingSlash = pathname[0] == \"/\";\n  pathname = new URL(!leadingSlash ? '/-' + pathname : pathname,\n                     \"https://example.com\").pathname;\n  if (!leadingSlash) {\n    pathname = pathname.substring(2, pathname.length);\n  }\n\n  return pathname;\n}\n\nexport function canonicalizePort(port: string, protocol: string | undefined, isPattern: boolean): string {\n  if (defaultPortForProtocol(protocol) === port) {\n    port = '';\n  }\n\n  if (isPattern || port === '') {\n    return port;\n  }\n\n  return portEncodeCallback(port);\n}\n\nexport function canonicalizeProtocol(protocol: string, isPattern: boolean) {\n  protocol = maybeStripSuffix(protocol, ':');\n\n  if (isPattern || protocol === '') {\n    return protocol;\n  }\n\n  return protocolEncodeCallback(protocol);\n}\n\nexport function defaultPortForProtocol(protocol: string | undefined): string {\n  switch (protocol) {\n    case \"ws\":\n    case \"http\":\n      return '80';\n    case \"wws\":\n    case \"https\":\n      return '443';\n    case \"ftp\":\n      return '21';\n    default:\n      return '';\n  }\n}\n\nexport function protocolEncodeCallback(input: string): string {\n  if (input === '') {\n    return input;\n  }\n  if (/^[-+.A-Za-z0-9]*$/.test(input))\n    return input.toLowerCase();\n  throw new TypeError(`Invalid protocol '${input}'.`);\n}\n\nexport function usernameEncodeCallback(input: string): string {\n  if (input === '') {\n    return input;\n  }\n  const url = new URL('https://example.com');\n  url.username = input;\n  return url.username;\n}\n\nexport function passwordEncodeCallback(input: string): string {\n  if (input === '') {\n    return input;\n  }\n  const url = new URL('https://example.com');\n  url.password = input;\n  return url.password;\n}\n\nexport function hostnameEncodeCallback(input: string): string {\n  if (input === '') {\n    return input;\n  }\n  if (/[\\t\\n\\r #%/:<>?@[\\]^\\\\|]/g.test(input)) {\n    throw(new TypeError(`Invalid hostname '${input}'`));\n  }\n  const url = new URL('https://example.com');\n  url.hostname = input;\n  return url.hostname;\n}\n\nexport function ipv6HostnameEncodeCallback(input: string): string {\n  if (input === '') {\n    return input;\n  }\n  if (/[^0-9a-fA-F[\\]:]/g.test(input)) {\n    throw(new TypeError(`Invalid IPv6 hostname '${input}'`));\n  }\n  return input.toLowerCase();\n}\n\nexport function portEncodeCallback(input: string): string {\n  if (input === '') {\n    return input;\n  }\n  // Since ports only consist of digits there should be no encoding needed.\n  // Therefore we directly use the UTF8 encoding version of CanonicalizePort().\n  if ((/^[0-9]*$/.test(input) && parseInt(input) <= 65535)) {\n    return input;\n  }\n  throw new TypeError(`Invalid port '${input}'.`);\n}\n\nexport function standardURLPathnameEncodeCallback(input: string): string {\n  if (input === '') {\n    return input;\n  }\n  const url = new URL('https://example.com');\n  url.pathname = input[0] !== '/' ? '/-' + input : input;\n  if (input[0] !== '/') {\n    return url.pathname.substring(2, url.pathname.length);\n  }\n  return url.pathname;\n}\n\nexport function pathURLPathnameEncodeCallback(input: string): string {\n  if (input === '') {\n    return input;\n  }\n  const url = new URL(`data:${input}`);\n  return url.pathname;\n}\n\nexport function searchEncodeCallback(input: string): string {\n  if (input === '') {\n    return input;\n  }\n  const url = new URL('https://example.com');\n  url.search = input;\n  return url.search.substring(1, url.search.length);\n}\n\nexport function hashEncodeCallback(input: string): string {\n  if (input === '') {\n    return input;\n  }\n  const url = new URL('https://example.com');\n  url.hash = input;\n  return url.hash.substring(1, url.hash.length);\n}\n","// The parse has been translated from the chromium c++ implementation at:\n//\n//  https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/modules/url_pattern/url_pattern_parser.h;l=36;drc=f66c35e3c41629675130001dbce0dcfba870160b\n//\n\nimport {lexer, LexToken, pathToRegexp, ParseOptions, TokensToRegexpOptions} from './path-to-regex-modified';\nimport {URLPatternInit} from './url-pattern.interfaces';\nimport {DEFAULT_OPTIONS, protocolEncodeCallback, isSpecialScheme} from './url-utils';\n\nenum State {\n  INIT,\n  PROTOCOL,\n  AUTHORITY,\n  USERNAME,\n  PASSWORD,\n  HOSTNAME,\n  PORT,\n  PATHNAME,\n  SEARCH,\n  HASH,\n  DONE,\n}\n\n// A helper class to parse the first string passed to the URLPattern\n// constructor.  In general the parser works by using the path-to-regexp\n// lexer to first split up the input into pattern tokens.  It can\n// then look through the tokens to find non-special characters that match\n// the different URL component separators.  Each component is then split\n// off and stored in a `URLPatternInit` object that can be accessed via\n// the `Parser.result` getter.  The intent is that this init object should\n// then be processed as if it was passed into the constructor itself.\nexport class Parser {\n  // The input string to the parser.\n  private input: string;\n\n  // The list of `LexToken`s produced by the path-to-regexp `lexer()` function\n  // when passed `input` with lenient mode enabled.\n  private tokenList: LexToken[] = [];\n\n  // As we parse the input string we populate a `URLPatternInit` dictionary\n  // with each component pattern.  This is then the final result of the parse.\n  private internalResult: URLPatternInit = {};\n\n  // The index of the current `LexToken` being considered.\n  private tokenIndex: number = 0;\n\n  // The value to add to `tokenIndex` on each turn through the parse loop.\n  // While typically this is `1`, it is also set to `0` at times for things\n  // like state transitions, etc.  It is automatically reset back to `1` at\n  // the top of the parse loop.\n  private tokenIncrement: number = 1;\n\n  // The index of the first `LexToken` to include in the component string.\n  private componentStart: number = 0;\n\n  // The current parse state.  This should only be changed via `changeState()`\n  // or `rewindAndSetState()`.\n  private state: State = State.INIT;\n\n  // The current nest depth of `{ }` pattern groupings.\n  private groupDepth: number = 0;\n\n  // The current nesting depth of `[ ]` in hostname patterns.\n  private hostnameIPv6BracketDepth: number = 0;\n\n  // True if we should apply parse rules as if this is a \"standard\" URL.  If\n  // false then this is treated as a \"not a base URL\".\n  private shouldTreatAsStandardURL: boolean = false;\n\n  public constructor(input: string) {\n    this.input = input;\n  }\n\n  // Return the parse result.  The result is only available after the\n  // `parse()` method completes.\n  public get result(): URLPatternInit {\n    return this.internalResult;\n  }\n\n  // Attempt to parse the input string used to construct the Parser object.\n  // This method may only be called once.  Any errors will be thrown as an\n  // exception.  Retrieve the parse result by accessing the `Parser.result`\n  // property getter.\n  public parse(): void {\n    this.tokenList = lexer(this.input, /*lenient=*/true);\n\n    for (; this.tokenIndex < this.tokenList.length;\n         this.tokenIndex += this.tokenIncrement) {\n      // Reset back to our default tokenIncrement value.\n      this.tokenIncrement = 1;\n\n      // All states must respect the end of the token list.  The path-to-regexp\n      // lexer guarantees that the last token will have the type `END`.\n      if (this.tokenList[this.tokenIndex].type === 'END') {\n        // If we failed to find a protocol terminator then we are still in\n        // relative mode.  We now need to determine the first component of the\n        // relative URL.\n        if (this.state === State.INIT) {\n          // Reset back to the start of the input string.\n          this.rewind();\n\n          // If the string begins with `?` then its a relative search component.\n          // If it starts with `#` then its a relative hash component.  Otherwise\n          // its a relative pathname.\n          if (this.isHashPrefix()) {\n            this.changeState(State.HASH, /*skip=*/1);\n          } else if (this.isSearchPrefix()) {\n            this.changeState(State.SEARCH, /*skip=*/1);\n            this.internalResult.hash = '';\n          } else {\n            this.changeState(State.PATHNAME, /*skip=*/0);\n            this.internalResult.search = '';\n            this.internalResult.hash = '';\n          }\n          continue;\n        }\n        //\n        // If we failed to find an `@`, then there is no username and password.\n        // We should rewind and process the data as a hostname.\n        else if (this.state === State.AUTHORITY) {\n          this.rewindAndSetState(State.HOSTNAME);\n          continue;\n        }\n\n        this.changeState(State.DONE, /*skip=*/0);\n        break;\n      }\n\n      // In addition, all states must handle pattern groups.  We do not permit\n      // a component to end in the middle of a pattern group.  Therefore we skip\n      // past any tokens that are within `{` and `}`.  Note, the tokenizer\n      // handles group `(` and `)` and `:foo` groups for us automatically, so\n      // we don't need special code for them here.\n      if (this.groupDepth > 0) {\n        if (this.isGroupClose()) {\n          this.groupDepth -= 1;\n        } else {\n          continue;\n        }\n      }\n\n      if (this.isGroupOpen()) {\n        this.groupDepth += 1;\n        continue;\n      }\n\n      switch (this.state) {\n        case State.INIT:\n          if (this.isProtocolSuffix()) {\n            // We are in absolute mode and we know values will not be inherited\n            // from a base URL.  Therefore initialize the rest of the components\n            // to the empty string.\n            this.internalResult.username = '';\n            this.internalResult.password = '';\n            this.internalResult.hostname = '';\n            this.internalResult.port = '';\n            this.internalResult.pathname = '';\n            this.internalResult.search = '';\n            this.internalResult.hash = '';\n\n            // Update the state to expect the start of an absolute URL.\n            this.rewindAndSetState(State.PROTOCOL);\n          }\n          break;\n\n        case State.PROTOCOL:\n          // If we find the end of the protocol component...\n          if (this.isProtocolSuffix()) {\n            // First we eagerly compile the protocol pattern and use it to\n            // compute if this entire URLPattern should be treated as a\n            // \"standard\" URL.  If any of the special schemes, like `https`,\n            // match the protocol pattern then we treat it as standard.\n            this.computeShouldTreatAsStandardURL();\n\n            // By default we treat this as a \"cannot-be-a-base-URL\" or what chrome\n            // calls a \"path\" URL.  In this case we go straight to the pathname\n            // component.  The hostname and port are left with their default\n            // empty string values.\n            let nextState: State = State.PATHNAME;\n            let skip: number = 1;\n\n            if (this.shouldTreatAsStandardURL) {\n              this.internalResult.pathname = '/';\n            }\n\n            // If there are authority slashes, like `https://`, then\n            // we must transition to the authority section of the URLPattern.\n            if (this.nextIsAuthoritySlashes()) {\n              nextState = State.AUTHORITY;\n              skip = 3;\n            }\n\n            // If there are no authority slashes, but the protocol is special\n            // then we still go to the authority section as this is a \"standard\"\n            // URL.  This differs from the above case since we don't need to skip\n            // the extra slashes.\n            else if (this.shouldTreatAsStandardURL) {\n              nextState = State.AUTHORITY;\n            }\n\n            this.changeState(nextState, skip);\n          }\n          break;\n\n        case State.AUTHORITY:\n          // Before going to the hostname state we must see if there is an\n          // identity of the form:\n          //\n          //  <username>:<password>@<hostname>\n          //\n          // We check for this by looking for the `@` character.  The username\n          // and password are themselves each optional, so the `:` may not be\n          // present.  If we see the `@` we just go to the username state\n          // and let it proceed until it hits either the password separator\n          // or the `@` terminator.\n          if (this.isIdentityTerminator()) {\n            this.rewindAndSetState(State.USERNAME);\n          }\n\n          // Stop searching for the `@` character if we see the beginning\n          // of the pathname, search, or hash components.\n          else if (this.isPathnameStart() || this.isSearchPrefix() ||\n                   this.isHashPrefix()) {\n            this.rewindAndSetState(State.HOSTNAME);\n          }\n          break;\n\n        case State.USERNAME:\n          // If we find a `:` then transition to the password component state.\n          if (this.isPasswordPrefix()) {\n            this.changeState(State.PASSWORD, /*skip=*/1);\n          }\n\n          // If we find a `@` then transition to the hostname component state.\n          else if (this.isIdentityTerminator()) {\n            this.changeState(State.HOSTNAME, /*skip=*/1);\n          }\n          break;\n\n        case State.PASSWORD:\n          // If we find a `@` then transition to the hostname component state.\n          if (this.isIdentityTerminator()) {\n            this.changeState(State.HOSTNAME, /*skip=*/1);\n          }\n          break;\n\n        case State.HOSTNAME:\n          // Track whether we are inside ipv6 address brackets.\n          if (this.isIPv6Open()) {\n            this.hostnameIPv6BracketDepth += 1;\n          } else if (this.isIPv6Close()) {\n            this.hostnameIPv6BracketDepth -= 1;\n          }\n\n          // If we find a `:` then we transition to the port component state.\n          // However, we ignore `:` when parsing an ipv6 address.\n          if (this.isPortPrefix() && !this.hostnameIPv6BracketDepth) {\n            this.changeState(State.PORT, /*skip=*/1);\n          }\n\n          // If we find a `/` then we transition to the pathname component state.\n          else if (this.isPathnameStart()) {\n            this.changeState(State.PATHNAME, /*skip=*/0);\n          }\n\n          // If we find a `?` then we transition to the search component state.\n          else if (this.isSearchPrefix()) {\n            this.changeState(State.SEARCH, /*skip=*/1);\n          }\n\n          // If we find a `#` then we transition to the hash component state.\n          else if (this.isHashPrefix()) {\n            this.changeState(State.HASH, /*skip=*/1);\n          }\n          break;\n\n        case State.PORT:\n          // If we find a `/` then we transition to the pathname component state.\n          if (this.isPathnameStart()) {\n            this.changeState(State.PATHNAME, /*skip=*/0);\n          }\n\n          // If we find a `?` then we transition to the search component state.\n          else if (this.isSearchPrefix()) {\n            this.changeState(State.SEARCH, /*skip=*/1);\n          }\n\n          // If we find a `#` then we transition to the hash component state.\n          else if (this.isHashPrefix()) {\n            this.changeState(State.HASH, /*skip=*/1);\n          }\n          break;\n\n        case State.PATHNAME:\n          // If we find a `?` then we transition to the search component state.\n          if (this.isSearchPrefix()) {\n            this.changeState(State.SEARCH, /*skip=*/1);\n          }\n\n          // If we find a `#` then we transition to the hash component state.\n          else if (this.isHashPrefix()) {\n            this.changeState(State.HASH, /*skip=*/1);\n          }\n          break;\n\n        case State.SEARCH:\n          // If we find a `#` then we transition to the hash component state.\n          if (this.isHashPrefix()) {\n            this.changeState(State.HASH, /*skip=*/1);\n          }\n          break;\n\n        case State.HASH:\n          // Nothing to do here as we are just looking for the end.\n          break;\n\n        case State.DONE:\n          // This should not be reached.\n          break;\n      }\n    }\n  }\n\n  private changeState(newState: State, skip: number): void {\n    switch (this.state) {\n      case State.INIT:\n        // No component to set when transitioning from this state.\n        break;\n      case State.PROTOCOL:\n        this.internalResult.protocol = this.makeComponentString();\n        break;\n      case State.AUTHORITY:\n        // No component to set when transitioning from this state.\n        break;\n      case State.USERNAME:\n        this.internalResult.username = this.makeComponentString();\n        break;\n      case State.PASSWORD:\n        this.internalResult.password = this.makeComponentString();\n        break;\n      case State.HOSTNAME:\n        this.internalResult.hostname = this.makeComponentString();\n        break;\n      case State.PORT:\n        this.internalResult.port = this.makeComponentString();\n        break;\n      case State.PATHNAME:\n        this.internalResult.pathname = this.makeComponentString();\n        break;\n      case State.SEARCH:\n        this.internalResult.search = this.makeComponentString();\n        break;\n      case State.HASH:\n        this.internalResult.hash = this.makeComponentString();\n        break;\n      case State.DONE:\n        // No component to set when transitioning from this state.\n        break;\n    }\n\n    this.changeStateWithoutSettingComponent(newState, skip);\n  }\n\n  private changeStateWithoutSettingComponent(newState: State, skip: number): void {\n    this.state = newState;\n\n    // Now update `componentStart` to point to the new component.  The `skip`\n    // argument tells us how many tokens to ignore to get to the next start.\n    this.componentStart = this.tokenIndex + skip;\n\n    // Next, move the `tokenIndex` so that the top of the loop will begin\n    // parsing the new component.\n    this.tokenIndex += skip;\n    this.tokenIncrement = 0;\n  }\n\n  private rewind(): void {\n    this.tokenIndex = this.componentStart;\n    this.tokenIncrement = 0;\n  }\n\n  private rewindAndSetState(newState: State): void {\n    this.rewind();\n    this.state = newState;\n  }\n\n  private safeToken(index: number): LexToken {\n    if (index < 0) {\n      index = this.tokenList.length - index;\n    }\n\n    if (index < this.tokenList.length) {\n      return this.tokenList[index];\n    }\n    return this.tokenList[this.tokenList.length - 1];\n  }\n\n  private isNonSpecialPatternChar(index: number, value: string): boolean {\n    const token: LexToken = this.safeToken(index);\n    return token.value === value &&\n      (token.type === 'CHAR' ||\n       token.type === 'ESCAPED_CHAR' ||\n       token.type === 'INVALID_CHAR');\n  }\n\n  private isProtocolSuffix(): boolean {\n    return this.isNonSpecialPatternChar(this.tokenIndex, ':');\n  }\n\n  private nextIsAuthoritySlashes(): boolean {\n    return this.isNonSpecialPatternChar(this.tokenIndex + 1, '/') &&\n           this.isNonSpecialPatternChar(this.tokenIndex + 2, '/');\n  }\n\n  private isIdentityTerminator(): boolean {\n    return this.isNonSpecialPatternChar(this.tokenIndex, '@');\n  }\n\n  private isPasswordPrefix(): boolean {\n    return this.isNonSpecialPatternChar(this.tokenIndex, ':');\n  }\n\n  private isPortPrefix(): boolean {\n    return this.isNonSpecialPatternChar(this.tokenIndex, ':');\n  }\n\n  private isPathnameStart(): boolean {\n    return this.isNonSpecialPatternChar(this.tokenIndex, '/');\n  }\n\n  private isSearchPrefix(): boolean {\n    if (this.isNonSpecialPatternChar(this.tokenIndex, '?')) {\n      return true;\n    }\n\n    if (this.tokenList[this.tokenIndex].value !== '?') {\n      return false;\n    }\n\n    // We have a `?` tokenized as a modifer.  We only want to treat this as\n    // the search prefix if it would not normally be valid in a path-to-regexp\n    // string.  A modifier must follow a matching group.  Therefore we inspect\n    // the preceding token to if the `?` is immediately following a group\n    // construct.\n    //\n    // So if the string is:\n    //\n    //  https://exmaple.com/foo?bar\n    //\n    // Then we return true because the previous token is a `o` with type `CHAR`.\n    // For the string:\n    //\n    //  https://example.com/:name?bar\n    //\n    // Then we return false because the previous token is `:name` with type\n    // `NAME`.  If the developer intended this to be a search prefix then they\n    // would need to escape the quest mark like `:name\\\\?bar`.\n    //\n    // Note, if `tokenIndex` is zero the index will wrap around and\n    // `safeToken()` will return the `END` token.  This will correctly return\n    // true from this method as a pattern cannot normally begin with an\n    // unescaped `?`.\n    const previousToken: LexToken = this.safeToken(this.tokenIndex - 1);\n    return previousToken.type !== 'NAME' &&\n           previousToken.type !== 'PATTERN' &&\n           previousToken.type !== 'CLOSE' &&\n           previousToken.type !== 'ASTERISK';\n  }\n\n  private isHashPrefix(): boolean {\n    return this.isNonSpecialPatternChar(this.tokenIndex, '#');\n  }\n\n  private isGroupOpen(): boolean {\n    return this.tokenList[this.tokenIndex].type == 'OPEN';\n  }\n\n  private isGroupClose(): boolean {\n    return this.tokenList[this.tokenIndex].type == 'CLOSE';\n  }\n\n  private isIPv6Open(): boolean {\n    return this.isNonSpecialPatternChar(this.tokenIndex, '[');\n  }\n\n  private isIPv6Close(): boolean {\n    return this.isNonSpecialPatternChar(this.tokenIndex, ']');\n  }\n\n  private makeComponentString(): string {\n    const token: LexToken = this.tokenList[this.tokenIndex];\n    const componentCharStart = this.safeToken(this.componentStart).index;\n    return this.input.substring(componentCharStart, token.index);\n  }\n\n  private computeShouldTreatAsStandardURL(): void {\n    const options: TokensToRegexpOptions & ParseOptions = {};\n    Object.assign(options, DEFAULT_OPTIONS);\n    options.encodePart = protocolEncodeCallback;\n    const regexp = pathToRegexp(this.makeComponentString(), /*keys=*/undefined, options);\n    this.shouldTreatAsStandardURL = isSpecialScheme(regexp);\n  }\n}\n","import {ParseOptions, parse, Token, tokensToRegexp, TokensToRegexpOptions} from './path-to-regex-modified';\nimport {URLPatternResult, URLPatternInit, URLPatternKeys} from './url-pattern.interfaces';\nimport {\n  DEFAULT_OPTIONS,\n  HOSTNAME_OPTIONS,\n  PATHNAME_OPTIONS,\n  canonicalizeHash,\n  canonicalizeHostname,\n  canonicalizePassword,\n  canonicalizePathname,\n  canonicalizePort,\n  canonicalizeProtocol,\n  canonicalizeSearch,\n  canonicalizeUsername,\n  defaultPortForProtocol,\n  treatAsIPv6Hostname,\n  isAbsolutePathname,\n  isSpecialScheme,\n  protocolEncodeCallback,\n  usernameEncodeCallback,\n  passwordEncodeCallback,\n  hostnameEncodeCallback,\n  ipv6HostnameEncodeCallback,\n  portEncodeCallback,\n  standardURLPathnameEncodeCallback,\n  pathURLPathnameEncodeCallback,\n  searchEncodeCallback,\n  hashEncodeCallback,\n} from './url-utils';\nimport {Parser} from './url-pattern-parser';\n\n// Define the components in a URL.  The ordering of this constant list is\n// signficant to the implementation below.\nconst COMPONENTS: URLPatternKeys[]= [\n  'protocol',\n  'username',\n  'password',\n  'hostname',\n  'port',\n  'pathname',\n  'search',\n  'hash',\n];\n\n// The default wildcard pattern used for a component when the constructor\n// input does not provide an explicit value.\nconst DEFAULT_PATTERN = '*';\n\nfunction extractValues(url: string, baseURL?: string): URLPatternInit {\n  if (typeof url !== \"string\") {\n    throw new TypeError(`parameter 1 is not of type 'string'.`);\n  }\n  const o = new URL(url, baseURL); // May throw.\n  return {\n    protocol: o.protocol.substring(0, o.protocol.length - 1),\n    username: o.username,\n    password: o.password,\n    hostname: o.hostname,\n    port: o.port,\n    pathname: o.pathname,\n    search: o.search != '' ? o.search.substring(1, o.search.length) : undefined,\n    hash: o.hash != '' ? o.hash.substring(1, o.hash.length) : undefined,\n  };\n}\n\n// A utility method that takes a URLPatternInit, splits it apart, and applies\n// the individual component values in the given set of strings.  The strings\n// are only applied if a value is present in the init structure.\nfunction applyInit(o: URLPatternInit, init: URLPatternInit, isPattern: boolean): URLPatternInit {\n  // If there is a baseURL we need to apply its component values first.  The\n  // rest of the URLPatternInit structure will then later override these\n  // values.  Note, the baseURL will always set either an empty string or\n  // longer value for each considered component.  We do not allow null strings\n  // to persist for these components past this phase since they should no\n  // longer be treated as wildcards.\n  let baseURL;\n  if (typeof init.baseURL === 'string') {\n    try {\n      baseURL = new URL(init.baseURL);\n      o.protocol = baseURL.protocol ? baseURL.protocol.substring(0, baseURL.protocol.length - 1) : '';\n      o.username = baseURL.username;\n      o.password = baseURL.password;\n      o.hostname = baseURL.hostname;\n      o.port = baseURL.port;\n      o.pathname = baseURL.pathname;\n      o.search = baseURL.search ? baseURL.search.substring(1, baseURL.search.length) : '';\n      o.hash = baseURL.hash ? baseURL.hash.substring(1, baseURL.hash.length) : '';\n    } catch {\n      throw new TypeError(`invalid baseURL '${init.baseURL}'.`);\n    }\n  }\n\n  // Apply the URLPatternInit component values on top of the default and\n  // baseURL values.\n  if (typeof init.protocol === 'string') {\n    o.protocol = canonicalizeProtocol(init.protocol, isPattern);\n  }\n\n  if (typeof init.username === 'string') {\n    o.username = canonicalizeUsername(init.username, isPattern);\n  }\n\n  if (typeof init.password === 'string') {\n    o.password = canonicalizePassword(init.password, isPattern);\n  }\n\n  if (typeof init.hostname === 'string') {\n    o.hostname = canonicalizeHostname(init.hostname, isPattern);\n  }\n\n  if (typeof init.port === 'string') {\n    o.port = canonicalizePort(init.port, o.protocol, isPattern);\n  }\n\n  if (typeof init.pathname === 'string') {\n    o.pathname = init.pathname;\n    if (baseURL && !isAbsolutePathname(o.pathname, isPattern)) {\n      // Find the last slash in the baseURL pathname.  Since the URL is\n      // hierarchical it should have a slash to be valid, but we are cautious\n      // and check.  If there is no slash then we cannot use resolve the\n      // relative pathname and just treat the init pathname as an absolute\n      // value.\n      const slashIndex = baseURL.pathname.lastIndexOf('/');\n      if (slashIndex >= 0) {\n        // Extract the baseURL path up to and including the first slash.\n        // Append the relative init pathname to it.\n        o.pathname = baseURL.pathname.substring(0, slashIndex + 1) + o.pathname;\n      }\n    }\n    o.pathname = canonicalizePathname(o.pathname, o.protocol, isPattern);\n  }\n\n  if (typeof init.search === 'string') {\n    o.search = canonicalizeSearch(init.search, isPattern);\n  }\n\n  if (typeof init.hash === 'string') {\n    o.hash = canonicalizeHash(init.hash, isPattern);\n  }\n\n  return o;\n}\n\nfunction escapePatternString(value: string): string {\n  return value.replace(/([+*?:{}()\\\\])/g, '\\\\$1');\n}\n\nfunction escapeRegexpString(value: string): string {\n  return value.replace(/([.+*?^${}()[\\]|/\\\\])/g, '\\\\$1');\n}\n\n// A utility function to convert a list of path-to-regexp Tokens back into\n// a pattern string.  The resulting pattern should be equivalent to the\n// original parsed pattern, although they may differ due to canonicalization.\nfunction tokensToPattern(tokens: Token[],\n                         options: TokensToRegexpOptions & ParseOptions): string {\n  const wildcardPattern = \".*\";\n  const segmentWildcardPattern =\n      `[^${escapeRegexpString(options.delimiter || '/#?')}]+?`;\n  const regexIdentifierPart = /[$_\\u200C\\u200D\\p{ID_Continue}]/u;\n\n  let result = \"\";\n  for (let i = 0; i < tokens.length; ++i) {\n    const token = tokens[i];\n    const lastToken = i > 0 ? tokens[i - 1] : null;\n    const nextToken: any = i < tokens.length - 1 ? tokens[i + 1] : null;\n\n    // Plain text tokens can be directly added to the pattern string.\n    if (typeof token === 'string') {\n      result += escapePatternString(token);\n      continue;\n    }\n\n    // Tokens without a pattern are also plain text, but were originally\n    // contained in a `{ ... }` group.  There may be a modifier following\n    // the group.  If there is no modifier then we strip the braces off\n    // as they are superfluous.\n    if (token.pattern === '') {\n      if (token.modifier === '') {\n        result += escapePatternString(token.prefix);\n        continue;\n      }\n      result += `{${escapePatternString(token.prefix)}}${token.modifier}`;\n      continue;\n    }\n\n    // Determine if the token name was custom or automatically assigned.\n    const customName = typeof token.name !== 'number';\n\n    // Determine if the token needs a grouping like `{ ... }`.  This is\n    // necessary when the group:\n    //\n    // 1. is using a non-automatic prefix or any suffix.\n    const optionsPrefixes = options.prefixes !== undefined ? options.prefixes\n                                                           : \"./\";\n    let needsGrouping =\n      token.suffix !== \"\" ||\n      (token.prefix !== \"\" &&\n       (token.prefix.length !== 1 ||\n        !optionsPrefixes.includes(token.prefix)));\n\n    // 2. following by a matching group that may be expressed in a way that can\n    //    be mistakenly interpreted as part of the matching group.  For\n    //    example:\n    //\n    //    a. An `(...)` expression following a `:foo` group.  We want to output\n    //       `{:foo}(...)` and not `:foo(...)`.\n    //    b. A plain text expression following a `:foo` group where the text\n    //       could be mistakenly interpreted as part of the name.  We want to\n    //       output `{:foo}bar` and not `:foobar`.\n    if (!needsGrouping && customName &&\n        token.pattern === segmentWildcardPattern &&\n        token.modifier === \"\" && nextToken && !nextToken.prefix &&\n        !nextToken.suffix) {\n      if (typeof nextToken === \"string\") {\n        const code = nextToken.length > 0 ? nextToken[0] : \"\";\n        needsGrouping = regexIdentifierPart.test(code);\n      } else {\n        needsGrouping = typeof nextToken.name === \"number\";\n      }\n    }\n\n    // 3. preceded by a fixed text part that ends with an implicit prefix\n    //    character (like `/`).  This occurs when the original pattern used\n    //    an escape or grouping to prevent the implicit prefix; e.g.\n    //    `\\\\/*` or `/{*}`.  In these cases we use a grouping to prevent the\n    //    implicit prefix in the generated string.\n    if (!needsGrouping && token.prefix === \"\" && lastToken &&\n        typeof lastToken === \"string\" && lastToken.length > 0) {\n      const code = lastToken[lastToken.length - 1];\n      needsGrouping = optionsPrefixes.includes(code);\n    }\n\n    // This is a full featured token.  We must generate a string that looks\n    // like:\n    //\n    //  { <prefix> <pattern> <suffix> } <modifier>\n    //\n    // Where the { and } may not be needed.  The <pattern> will be a regexp,\n    // named group, or wildcard.\n    if (needsGrouping) {\n      result += '{';\n    }\n\n    result += escapePatternString(token.prefix);\n\n    if (customName) {\n      result += `:${token.name}`;\n    }\n\n    if (token.pattern === wildcardPattern) {\n      // We can only use the `*` wildcard card if we meet a number of\n      // conditions.  We must use an explicit `(.*)` group if:\n      //\n      // 1. A custom name was used; e.g. `:foo(.*)`.\n      // 2. If the preceding group is a matching group without a modifier; e.g.\n      //    `(foo)(.*)`.  In that case we cannot emit the `*` shorthand without\n      //    it being mistakenly interpreted as the modifier for the previous\n      //    group.\n      if (!customName && (!lastToken ||\n                          typeof lastToken === 'string' ||\n                          lastToken.modifier ||\n                          needsGrouping ||\n                          token.prefix !== \"\")) {\n        result += '*';\n      } else {\n        result += `(${wildcardPattern})`;\n      }\n    } else if (token.pattern === segmentWildcardPattern) {\n      // We only need to emit a regexp if a custom name was\n      // not specified.  A custom name like `:foo` gets the\n      // kSegmentWildcard type automatically.\n      if (!customName) {\n        result += `(${segmentWildcardPattern})`;\n      }\n    } else {\n      result += `(${token.pattern})`;\n    }\n\n    // If the matching group is a simple `:foo` custom name with the default\n    // segment wildcard, then we must check for a trailing suffix that could\n    // be interpreted as a trailing part of the name itself.  In these cases\n    // we must escape the beginning of the suffix in order to separate it\n    // from the end of the custom name; e.g. `:foo\\\\bar` instead of `:foobar`.\n    if (token.pattern === segmentWildcardPattern && customName &&\n        token.suffix !== \"\") {\n      if (regexIdentifierPart.test(token.suffix[0])) {\n        result += '\\\\';\n      }\n    }\n\n    result += escapePatternString(token.suffix);\n\n    if (needsGrouping) {\n      result += '}';\n    }\n\n    result += token.modifier;\n  }\n\n  return result;\n}\n\nexport class URLPattern {\n  private pattern: URLPatternInit;\n  private regexp: any = {};\n  private keys: any = {};\n  private component_pattern: any = {};\n\n  constructor(init: URLPatternInit | string = {}, baseURL?: string) {\n    try {\n      // shorthand\n      if (typeof init === 'string') {\n        const parser = new Parser(init);\n        parser.parse();\n        init = parser.result;\n        if (baseURL) {\n          if (typeof baseURL === 'string') {\n            init.baseURL = baseURL;\n          } else {\n            throw new TypeError(`'baseURL' parameter is not of type 'string'.`);\n          }\n        } else if (typeof init.protocol !== 'string') {\n          throw new TypeError(`A base URL must be provided for a relative constructor string.`);\n        }\n      } else if (baseURL) {\n        throw new TypeError(`parameter 1 is not of type 'string'.`);\n      }\n\n      // no or invalid arguments\n      if (!init || typeof init !== 'object') {\n        throw new TypeError(`parameter 1 is not of type 'string' and cannot convert to dictionary.`);\n      }\n\n      const defaults = {\n        pathname: DEFAULT_PATTERN,\n        protocol: DEFAULT_PATTERN,\n        username: DEFAULT_PATTERN,\n        password: DEFAULT_PATTERN,\n        hostname: DEFAULT_PATTERN,\n        port: DEFAULT_PATTERN,\n        search: DEFAULT_PATTERN,\n        hash: DEFAULT_PATTERN,\n      };\n\n      this.pattern = applyInit(defaults, init, true);\n\n      if (defaultPortForProtocol(this.pattern.protocol) === this.pattern.port) {\n        this.pattern.port = '';\n      }\n\n      let component: URLPatternKeys;\n      // Iterate in component order so we are sure to compile the protocol\n      // before the pathname.  We need to know the protocol in order to know\n      // which kind of canonicalization to apply.\n      for (component of COMPONENTS) {\n        if (!(component in this.pattern))\n          continue;\n        const options: TokensToRegexpOptions & ParseOptions = {};\n        const pattern = this.pattern[component];\n        this.keys[component] = [];\n        switch (component) {\n          case 'protocol':\n            Object.assign(options, DEFAULT_OPTIONS);\n            options.encodePart = protocolEncodeCallback;\n            break;\n          case 'username':\n            Object.assign(options, DEFAULT_OPTIONS);\n            options.encodePart = usernameEncodeCallback;\n            break;\n          case 'password':\n            Object.assign(options, DEFAULT_OPTIONS);\n            options.encodePart = passwordEncodeCallback;\n            break;\n          case 'hostname':\n            Object.assign(options, HOSTNAME_OPTIONS);\n            if (treatAsIPv6Hostname(pattern)) {\n              options.encodePart = ipv6HostnameEncodeCallback;\n            } else {\n              options.encodePart = hostnameEncodeCallback;\n            }\n            break;\n          case 'port':\n            Object.assign(options, DEFAULT_OPTIONS);\n            options.encodePart = portEncodeCallback;\n            break;\n          case 'pathname':\n            if (isSpecialScheme(this.regexp.protocol)) {\n              Object.assign(options, PATHNAME_OPTIONS);\n              options.encodePart = standardURLPathnameEncodeCallback;\n            } else {\n              Object.assign(options, DEFAULT_OPTIONS);\n              options.encodePart = pathURLPathnameEncodeCallback;\n            }\n            break;\n          case 'search':\n            Object.assign(options, DEFAULT_OPTIONS);\n            options.encodePart = searchEncodeCallback;\n            break;\n          case 'hash':\n            Object.assign(options, DEFAULT_OPTIONS);\n            options.encodePart = hashEncodeCallback;\n            break;\n        }\n        try {\n          const tokens = parse(pattern as string, options);\n          this.regexp[component] = tokensToRegexp(tokens, this.keys[component], options);\n          this.component_pattern[component] = tokensToPattern(tokens, options);\n        } catch {\n          // If a pattern is illegal the constructor will throw an exception\n          throw new TypeError(`invalid ${component} pattern '${this.pattern[component]}'.`);\n        }\n      }\n    } catch (err: any) {\n      throw new TypeError(`Failed to construct 'URLPattern': ${err.message}`);\n    }\n  }\n\n  test(input: string | URLPatternInit = {}, baseURL?: string) {\n    let values: URLPatternInit = {\n      pathname: '',\n      protocol: '',\n      username: '',\n      password: '',\n      hostname: '',\n      port: '',\n      search: '',\n      hash: '',\n    };\n\n    if (typeof(input) !== 'string' && baseURL) {\n      throw new TypeError(`parameter 1 is not of type 'string'.`);\n    }\n\n    if (typeof input === 'undefined') {\n      return false;\n    }\n\n    try {\n      if (typeof input === 'object') {\n        values = applyInit(values, input, false);\n      } else {\n        values = applyInit(values, extractValues(input, baseURL), false);\n      }\n    } catch (err: any) {\n      // Treat exceptions simply as a failure to match.\n      return false;\n    }\n\n    let component:URLPatternKeys\n    for (component in this.pattern) {\n      if (!this.regexp[component].exec(values[component])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  exec(input: string | URLPatternInit = {}, baseURL?: string): URLPatternResult | null | undefined {\n    let values: URLPatternInit = {\n      pathname: '',\n      protocol: '',\n      username: '',\n      password: '',\n      hostname: '',\n      port: '',\n      search: '',\n      hash: '',\n    };\n\n    if (typeof(input) !== 'string' && baseURL) {\n      throw new TypeError(`parameter 1 is not of type 'string'.`);\n    }\n\n    if (typeof input === 'undefined') {\n      return;\n    }\n\n    try {\n      if (typeof input === 'object') {\n        values = applyInit(values, input, false);\n      } else {\n        values = applyInit(values, extractValues(input, baseURL), false);\n      }\n    } catch (err: any) {\n      // Treat exceptions simply as a failure to match.\n      return null;\n    }\n\n    let result: any = {};\n    if (baseURL) {\n      result.inputs = [input, baseURL];\n    } else {\n      result.inputs = [input];\n    }\n\n    let component: URLPatternKeys;\n    for (component in this.pattern) {\n      let match = this.regexp[component].exec(values[component]);\n      if (!match) {\n        return null;\n      }\n\n      let groups = {} as Array<string>;\n      for (let [i, key] of this.keys[component].entries()) {\n        if (typeof key.name === 'string' || typeof key.name === 'number') {\n          let value = match[i + 1];\n          groups[key.name] = value || '';\n        }\n      }\n\n      result[component] = {\n        input: values[component] || '',\n        groups,\n      };\n    }\n\n    return result;\n  }\n\n  public get protocol() {\n    return this.component_pattern.protocol;\n  }\n\n  public get username() {\n    return this.component_pattern.username;\n  }\n\n  public get password() {\n    return this.component_pattern.password;\n  }\n\n  public get hostname() {\n    return this.component_pattern.hostname;\n  }\n\n  public get port() {\n    return this.component_pattern.port;\n  }\n\n  public get pathname() {\n    return this.component_pattern.pathname;\n  }\n\n  public get search() {\n    return this.component_pattern.search;\n  }\n\n  public get hash() {\n    return this.component_pattern.hash;\n  }\n}\n"],"names":["regexIdentifierStart","regexIdentifierPart","isASCII","str","extended","test","lexer","lenient","tokens","i","length","char","ErrorOrInvalid","msg","TypeError","push","type","index","value","count","pattern","j","error","name","code","substr","parse","options","prefixes","defaultPattern","escapeString","delimiter","result","key","path","nameSet","Set","tryConsume","tryConsumeModifier","mustConsume","undefined","consumeText","encodePart","prefix","indexOf","finalName","has","add","suffix","modifier","replace","flags","sensitive","tokensToRegexp","keys","strict","start","end","encode","x","endsWith","route","token","endToken","isEndDelimited","RegExp","pathToRegexp","groupsRegex","execResult","exec","source","regexpToRegexp","Array","isArray","paths","parts","map","join","arrayToRegexp","stringToRegexp","DEFAULT_OPTIONS","HOSTNAME_OPTIONS","PATHNAME_OPTIONS","maybeStripPrefix","startsWith","substring","treatAsIPv6Hostname","State","SPECIAL_SCHEMES","isSpecialScheme","protocol_regexp","defaultPortForProtocol","protocol","protocolEncodeCallback","input","toLowerCase","usernameEncodeCallback","url","URL","username","passwordEncodeCallback","password","hostnameEncodeCallback","hostname","ipv6HostnameEncodeCallback","portEncodeCallback","parseInt","standardURLPathnameEncodeCallback","pathname","pathURLPathnameEncodeCallback","searchEncodeCallback","search","hashEncodeCallback","hash","Parser","tokenList","internalResult","tokenIndex","tokenIncrement","componentStart","state","INIT","groupDepth","hostnameIPv6BracketDepth","shouldTreatAsStandardURL","this","rewind","isHashPrefix","changeState","HASH","isSearchPrefix","SEARCH","PATHNAME","AUTHORITY","rewindAndSetState","HOSTNAME","DONE","isGroupClose","isGroupOpen","isProtocolSuffix","port","PROTOCOL","computeShouldTreatAsStandardURL","nextState","skip","nextIsAuthoritySlashes","isIdentityTerminator","USERNAME","isPathnameStart","isPasswordPrefix","PASSWORD","isIPv6Open","isIPv6Close","isPortPrefix","PORT","newState","makeComponentString","changeStateWithoutSettingComponent","safeToken","isNonSpecialPatternChar","previousToken","componentCharStart","Object","assign","regexp","COMPONENTS","DEFAULT_PATTERN","extractValues","baseURL","o","applyInit","init","isPattern","canonicalizeProtocol","canonicalizeUsername","canonicalizePassword","canonicalizeHostname","canonicalizePort","isAbsolutePathname","slashIndex","lastIndexOf","includes","leadingSlash","canonicalizePathname","canonicalizeSearch","canonicalizeHash","escapePatternString","tokensToPattern","segmentWildcardPattern","lastToken","nextToken","customName","optionsPrefixes","needsGrouping","component_pattern","parser","component","err","message","values","inputs","match","groups","entries"],"mappings":"iwCAwBA,IAAMA,EAAuB,01OACvBC,EAAsB,44RAE5B,SAASC,EAAQC,EAAaC,GAC5B,OAAQA,EAAW,iBAAmB,kBAAkBC,KAAKF,YAM/CG,EAAMH,EAAaI,YAAAA,IAAAA,GAAmB,GAIpD,IAHA,IAAMC,EAAqB,GACvBC,EAAI,EAEDA,EAAIN,EAAIO,QAAQ,CACrB,IAAMC,EAAOR,EAAIM,GAEXG,EAAiB,SAAUC,GAC/B,IAAKN,EAAS,UAAUO,UAAUD,GAClCL,EAAOO,KAAK,CAAEC,KAAM,eAAgBC,MAAOR,EAAGS,MAAOf,EAAIM,QAG3D,GAAa,MAATE,EAKJ,GAAa,MAATA,GAAyB,MAATA,EAKpB,GAAa,OAATA,EAKJ,GAAa,MAATA,EAKJ,GAAa,MAATA,EAKJ,GAAa,MAATA,EA4BJ,GAAa,MAATA,EA2DJH,EAAOO,KAAK,CAAEC,KAAM,OAAQC,MAAOR,EAAGS,MAAOf,EAAIM,WA3DjD,CACE,IAAIU,EAAQ,EACRC,EAAU,GACVC,EAAIZ,EAAI,EACRa,GAAQ,EAEZ,GAAe,MAAXnB,EAAIkB,GAAY,CAClBT,sCAAmDS,GACnD,SAGF,KAAOA,EAAIlB,EAAIO,QAAQ,CACrB,IAAKR,EAAQC,EAAIkB,IAAI,GAAQ,CAC3BT,wBAAqCT,EAAIkB,WAAUA,OACnDC,GAAQ,EACR,MAGF,GAAe,OAAXnB,EAAIkB,GAAR,CAKA,GAAe,MAAXlB,EAAIkB,IAEN,GAAc,KADdF,EACiB,CACfE,IACA,eAEkB,MAAXlB,EAAIkB,KACbF,IACmB,MAAfhB,EAAIkB,EAAI,IAAY,CACtBT,yCAAsDS,GACtDC,GAAQ,EACR,MAIJF,GAAWjB,EAAIkB,UAnBbD,GAAWjB,EAAIkB,KAAOlB,EAAIkB,KAsB9B,GAAIC,EACF,SAGF,GAAIH,EAAO,CACTP,2BAAwCH,GACxC,SAEF,IAAKW,EAAS,CACZR,wBAAqCH,GACrC,SAGFD,EAAOO,KAAK,CAAEC,KAAM,UAAWC,MAAOR,EAAGS,MAAOE,IAChDX,EAAIY,MAnFN,CAIE,IAHA,IAAIE,EAAO,GACPF,EAAIZ,EAAI,EAELY,EAAIlB,EAAIO,QAAQ,CACrB,IAAMc,EAAOrB,EAAIsB,OAAOJ,EAAG,GAE3B,KACGA,IAAMZ,EAAI,GAAKT,EAAqBK,KAAKmB,IACzCH,IAAMZ,EAAI,GAAKR,EAAoBI,KAAKmB,IAM3C,MAJED,GAAQpB,EAAIkB,KAOhB,IAAKE,EAAM,CACTX,+BAA4CH,GAC5C,SAGFD,EAAOO,KAAK,CAAEC,KAAM,OAAQC,MAAOR,EAAGS,MAAOK,IAC7Cd,EAAIY,OA5BJb,EAAOO,KAAK,CAAEC,KAAM,QAASC,MAAOR,EAAGS,MAAOf,EAAIM,YALlDD,EAAOO,KAAK,CAAEC,KAAM,OAAQC,MAAOR,EAAGS,MAAOf,EAAIM,YALjDD,EAAOO,KAAK,CAAEC,KAAM,eAAgBC,MAAOR,IAAKS,MAAOf,EAAIM,YAL3DD,EAAOO,KAAK,CAAEC,KAAM,WAAYC,MAAOR,EAAGS,MAAOf,EAAIM,YALrDD,EAAOO,KAAK,CAAEC,KAAM,WAAYC,MAAOR,EAAGS,MAAOf,EAAIM,OAoHzD,OAFAD,EAAOO,KAAK,CAAEC,KAAM,MAAOC,MAAOR,EAAGS,MAAO,KAErCV,WA8BOkB,EAAMvB,EAAawB,YAAAA,IAAAA,EAAwB,IA4CzD,IA3CA,IAAMnB,EAASF,EAAMH,KACOwB,EAApBC,SAAAA,aAAW,OACbC,OAAsBC,EAAaH,EAAQI,WAAa,aACxDC,EAAkB,GACpBC,EAAM,EACNxB,EAAI,EACJyB,EAAO,GACPC,EAAU,IAAIC,IAEZC,EAAa,SAACrB,GAClB,GAAIP,EAAID,EAAOE,QAAUF,EAAOC,GAAGO,OAASA,EAAM,OAAOR,EAAOC,KAAKS,OAGjEoB,EAAqB,WAEzB,OADUD,EAAW,aAIdA,EAAW,aAGdE,EAAc,SAACvB,GACnB,IAAME,EAAQmB,EAAWrB,GACzB,QAAcwB,IAAVtB,EAAqB,OAAOA,EAChC,MAAkCV,EAAOC,GACzC,UAAUK,0BADFE,cAAgBC,oBAC4CD,IAGhEyB,EAAc,WAIlB,IAHA,IACIvB,EADAc,EAAS,GAGLd,EAAQmB,EAAW,SAAWA,EAAW,iBAC/CL,GAAUd,EAEZ,OAAOc,GAMHU,EAAaf,EAAQe,YAHD,SAACxB,GACzB,OAAOA,GAIFT,EAAID,EAAOE,QAAQ,CACxB,IAAMC,EAAO0B,EAAW,QAClBd,EAAOc,EAAW,QAEpBjB,EAAUiB,EAAW,WAKzB,GAJKd,GAASH,IAAWiB,EAAW,cAClCjB,EAAU,MAGRG,GAAQH,EAAZ,CACE,IAAIuB,EAAShC,GAAQ,IAEa,IAA9BiB,EAASgB,QAAQD,KACnBT,GAAQS,EACRA,EAAS,IAGPT,IACFF,EAAOjB,KAAK2B,EAAWR,IACvBA,EAAO,IAGT,IAAMW,EAAYtB,GAAQU,IAC1B,GAAIE,EAAQW,IAAID,GACd,UAAU/B,6BAA6B+B,QAEzCV,EAAQY,IAAIF,GAEZb,EAAOjB,KAAK,CACVQ,KAAMsB,EACNF,OAAQD,EAAWC,GACnBK,OAAQ,GACR5B,QAASA,GAAWS,EACpBoB,SAAUX,KAAwB,SAxBtC,CA6BA,IAAMpB,EAAQP,GAAQ0B,EAAW,gBACjC,GAAInB,EACFgB,GAAQhB,OAKV,GADamB,EAAW,QACxB,CACE,IAAMM,EAASF,IACTlB,EAAOc,EAAW,SAAW,GAC/BjB,EAAUiB,EAAW,YAAc,GAClCd,GAASH,IAAWiB,EAAW,cAClCjB,EAAU,MAEZ,IAAM4B,EAASP,IAEfF,EAAY,SACZ,IAAMU,EAAWX,KAAwB,GAEzC,IAAKf,IAASH,IAAY6B,EAAU,CAClCf,GAAQS,EACR,SAGF,IAAKpB,IAASH,IAAYuB,EACxB,SAGET,IACFF,EAAOjB,KAAK2B,EAAWR,IACvBA,EAAO,IAGTF,EAAOjB,KAAK,CACVQ,KAAMA,IAASH,EAAUa,IAAQ,IACjCb,QAASG,IAASH,EAAUS,EAAiBT,EAC7CuB,OAAQD,EAAWC,GACnBK,OAAQN,EAAWM,GACnBC,SAAUA,SAKVf,IACFF,EAAOjB,KAAK2B,EAAWR,IACvBA,EAAO,IAGTK,EAAY,QAGd,OAAOP,EAgMT,SAASF,EAAa3B,GACpB,OAAOA,EAAI+C,QAAQ,yBAA0B,QAM/C,SAASC,EAAMxB,GACb,OAAOA,GAAWA,EAAQyB,UAAY,IAAM,cAqG9BC,EACd7C,EACA8C,EACA3B,YAAAA,IAAAA,EAAiC,IAajC,IAXA,QAKIA,EAJF4B,OAAAA,kBAIE5B,EAHF6B,MAAAA,kBAGE7B,EAFF8B,IAAAA,kBAEE9B,EADF+B,OAAAA,aAAS,SAACC,UAAcA,KAEpBC,MAAe9B,EAAaH,EAAQiC,UAAY,UAChD7B,MAAgBD,EAAaH,EAAQI,WAAa,WACpD8B,EAAQL,EAAQ,IAAM,OAGNhD,kBAAQ,KAAjBsD,UACT,GAAqB,iBAAVA,EACTD,GAAS/B,EAAa4B,EAAOI,QACxB,CACL,IAAMnB,EAASb,EAAa4B,EAAOI,EAAMnB,SACnCK,EAASlB,EAAa4B,EAAOI,EAAMd,SAErCc,EAAM1C,SACJkC,GAAMA,EAAKvC,KAAK+C,GAKhBD,GAHAlB,GAAUK,EACW,MAAnBc,EAAMb,UAAuC,MAAnBa,EAAMb,eAEnBN,SAAamB,EAAM1C,eAAc4B,EAASL,QAAYmB,EAAM1C,eAAc4B,OAD1D,MAAnBc,EAAMb,SAAmB,IAAM,UAG5BN,MAAUmB,EAAM1C,YAAW4B,MAAUc,EAAMb,SAGrC,MAAnBa,EAAMb,UAAuC,MAAnBa,EAAMb,gBAClBa,EAAM1C,YAAW0C,EAAMb,iBAE1Ba,EAAM1C,YAAW0C,EAAMb,UAIxCY,SAAelB,EAASK,MAAUc,EAAMb,UAK9C,GAAIQ,EACGF,IAAQM,GAAY9B,OAEzB8B,GAAUlC,EAAQiC,eAAuBA,MAAZ,QACxB,CACL,IAAMG,EAAWvD,EAAOA,EAAOE,OAAS,GAClCsD,EACgB,iBAAbD,EACHhC,EAAUa,QAAQmB,EAASA,EAASrD,OAAS,KAAO,OAEvC8B,IAAbuB,EAEDR,IACHM,SAAe9B,QAAe6B,SAG3BI,IACHH,SAAe9B,MAAa6B,OAIhC,WAAWK,OAAOJ,EAAOV,EAAMxB,aAejBuC,EACdhC,EACAoB,EACA3B,GAEA,OAAIO,aAAgB+B,OAtKtB,SAAwB/B,EAAcoB,GACpC,IAAKA,EAAM,OAAOpB,EAMlB,IAJA,IAAMiC,EAAc,0BAEhBlD,EAAQ,EACRmD,EAAaD,EAAYE,KAAKnC,EAAKoC,QAChCF,GACLd,EAAKvC,KAAK,CAERQ,KAAM6C,EAAW,IAAMnD,IACvB0B,OAAQ,GACRK,OAAQ,GACRC,SAAU,GACV7B,QAAS,KAEXgD,EAAaD,EAAYE,KAAKnC,EAAKoC,QAGrC,OAAOpC,EAmJ4BqC,CAAerC,EAAMoB,GACpDkB,MAAMC,QAAQvC,GA9IpB,SACEwC,EACApB,EACA3B,GAEA,IAAMgD,EAAQD,EAAME,IAAI,SAAC1C,UAASgC,EAAahC,EAAMoB,EAAM3B,GAAS2C,SACpE,WAAWL,aAAaU,EAAME,KAAK,SAAS1B,EAAMxB,IAwIlBmD,CAAc5C,EAAMoB,EAAM3B,GAlI5D,SACEO,EACAoB,EACA3B,GAEA,OAAO0B,EAAe3B,EAAMQ,EAAMP,GAAU2B,EAAM3B,GA8H3CoD,CAAe7C,EAAMoB,EAAM3B,OCxsBvBqD,EAAwD,CACnEjD,UAAW,GACXH,SAAU,GACVwB,WAAW,EACXG,QAAQ,GAQG0B,EAAyD,CACpElD,UAAW,IACXH,SAAU,GACVwB,WAAW,EACXG,QAAQ,GAOG2B,EAAyD,CACpEnD,UAAW,IACXH,SAAU,IACVwB,WAAW,EACXG,QAAQ,GAoCV,SAAS4B,EAAiBjE,EAAeyB,GACvC,OAAIzB,EAAMkE,WAAWzC,GACZzB,EAAMmE,UAAU1C,EAAOjC,OAAQQ,EAAMR,QAEvCQ,WAUOoE,EAAoBpE,GAClC,SAAKA,GAASA,EAAMR,OAAS,GAIZ,MAAbQ,EAAM,KAIQ,OAAbA,EAAM,IAA4B,MAAbA,EAAM,IACf,MAAbA,EAAM,SClFPqE,EDyFQC,EAAkB,CAC7B,MACA,OACA,OACA,QACA,KACA,gBAGcC,EAAgBC,GAC9B,IAAKA,EACH,SAEF,cAAqBF,kBACnB,GAAIE,EAAgBrF,cAClB,SAGJ,kBA+FcsF,EAAuBC,GACrC,OAAQA,GACN,IAAK,KACL,IAAK,OACH,MAAO,KACT,IAAK,MACL,IAAK,QACH,MAAO,MACT,IAAK,MACH,MAAO,KACT,QACE,MAAO,aAIGC,EAAuBC,GACrC,GAAc,KAAVA,EACF,OAAOA,EAET,GAAI,oBAAoBzF,KAAKyF,GAC3B,OAAOA,EAAMC,cACf,UAAUjF,+BAA+BgF,iBAG3BE,EAAuBF,GACrC,GAAc,KAAVA,EACF,OAAOA,EAET,IAAMG,EAAM,IAAIC,IAAI,uBAEpB,OADAD,EAAIE,SAAWL,EACRG,EAAIE,kBAGGC,EAAuBN,GACrC,GAAc,KAAVA,EACF,OAAOA,EAET,IAAMG,EAAM,IAAIC,IAAI,uBAEpB,OADAD,EAAII,SAAWP,EACRG,EAAII,kBAGGC,EAAuBR,GACrC,GAAc,KAAVA,EACF,OAAOA,EAET,GAAI,4BAA4BzF,KAAKyF,GACnC,UAAUhF,+BAA+BgF,OAE3C,IAAMG,EAAM,IAAIC,IAAI,uBAEpB,OADAD,EAAIM,SAAWT,EACRG,EAAIM,kBAGGC,EAA2BV,GACzC,GAAc,KAAVA,EACF,OAAOA,EAET,GAAI,oBAAoBzF,KAAKyF,GAC3B,UAAUhF,oCAAoCgF,OAEhD,OAAOA,EAAMC,uBAGCU,EAAmBX,GACjC,GAAc,KAAVA,EACF,OAAOA,EAIT,GAAK,WAAWzF,KAAKyF,IAAUY,SAASZ,IAAU,MAChD,OAAOA,EAET,UAAUhF,2BAA2BgF,iBAGvBa,EAAkCb,GAChD,GAAc,KAAVA,EACF,OAAOA,EAET,IAAMG,EAAM,IAAIC,IAAI,uBAEpB,OADAD,EAAIW,SAAwB,MAAbd,EAAM,GAAa,KAAOA,EAAQA,EAChC,MAAbA,EAAM,GACDG,EAAIW,SAASvB,UAAU,EAAGY,EAAIW,SAASlG,QAEzCuF,EAAIW,kBAGGC,EAA8Bf,GAC5C,MAAc,KAAVA,EACKA,EAEG,IAAII,YAAYJ,GACjBc,kBAGGE,EAAqBhB,GACnC,GAAc,KAAVA,EACF,OAAOA,EAET,IAAMG,EAAM,IAAIC,IAAI,uBAEpB,OADAD,EAAIc,OAASjB,EACNG,EAAIc,OAAO1B,UAAU,EAAGY,EAAIc,OAAOrG,iBAG5BsG,EAAmBlB,GACjC,GAAc,KAAVA,EACF,OAAOA,EAET,IAAMG,EAAM,IAAIC,IAAI,uBAEpB,OADAD,EAAIgB,KAAOnB,EACJG,EAAIgB,KAAK5B,UAAU,EAAGY,EAAIgB,KAAKvG,SCzTxC,SAAK6E,GACHA,mBACAA,2BACAA,6BACAA,2BACAA,2BACAA,2BACAA,mBACAA,2BACAA,uBACAA,mBACAA,oBAXF,CAAKA,IAAAA,WAsBQ2B,aAsCX,WAAmBpB,QApCXA,kBAIAqB,UAAwB,QAIxBC,eAAiC,QAGjCC,WAAqB,OAMrBC,eAAyB,OAGzBC,eAAyB,OAIzBC,MAAejC,EAAMkC,UAGrBC,WAAqB,OAGrBC,yBAAmC,OAInCC,0BAAoC,EAG1CC,KAAK/B,MAAQA,EAvCjB,2BAoDSpE,MAAA,WAGL,IAFAmG,KAAKV,UAAY7G,EAAMuH,KAAK/B,OAAmB,GAExC+B,KAAKR,WAAaQ,KAAKV,UAAUzG,OACnCmH,KAAKR,YAAcQ,KAAKP,eAAgB,CAM3C,GAJAO,KAAKP,eAAiB,EAIuB,QAAzCO,KAAKV,UAAUU,KAAKR,YAAYrG,KAAgB,CAIlD,GAAI6G,KAAKL,QAAUjC,EAAMkC,KAAM,CAE7BI,KAAKC,SAKDD,KAAKE,eACPF,KAAKG,YAAYzC,EAAM0C,KAAe,GAC7BJ,KAAKK,kBACdL,KAAKG,YAAYzC,EAAM4C,OAAiB,GACxCN,KAAKT,eAAeH,KAAO,KAE3BY,KAAKG,YAAYzC,EAAM6C,SAAmB,GAC1CP,KAAKT,eAAeL,OAAS,GAC7Bc,KAAKT,eAAeH,KAAO,IAE7B,YAKOY,KAAKL,QAAUjC,EAAM8C,UAAW,CACvCR,KAAKS,kBAAkB/C,EAAMgD,UAC7B,SAGFV,KAAKG,YAAYzC,EAAMiD,KAAe,GACtC,MAQF,GAAIX,KAAKH,WAAa,EAAG,CACvB,IAAIG,KAAKY,eAGP,SAFAZ,KAAKH,YAAc,EAMvB,GAAIG,KAAKa,cACPb,KAAKH,YAAc,OAIrB,OAAQG,KAAKL,OACX,KAAKjC,EAAMkC,KACLI,KAAKc,qBAIPd,KAAKT,eAAejB,SAAW,GAC/B0B,KAAKT,eAAef,SAAW,GAC/BwB,KAAKT,eAAeb,SAAW,GAC/BsB,KAAKT,eAAewB,KAAO,GAC3Bf,KAAKT,eAAeR,SAAW,GAC/BiB,KAAKT,eAAeL,OAAS,GAC7Bc,KAAKT,eAAeH,KAAO,GAG3BY,KAAKS,kBAAkB/C,EAAMsD,WAE/B,MAEF,KAAKtD,EAAMsD,SAET,GAAIhB,KAAKc,mBAAoB,CAK3Bd,KAAKiB,kCAML,IAAIC,EAAmBxD,EAAM6C,SACzBY,EAAe,EAEfnB,KAAKD,2BACPC,KAAKT,eAAeR,SAAW,KAK7BiB,KAAKoB,0BACPF,EAAYxD,EAAM8C,UAClBW,EAAO,GAOAnB,KAAKD,2BACZmB,EAAYxD,EAAM8C,WAGpBR,KAAKG,YAAYe,EAAWC,GAE9B,MAEF,KAAKzD,EAAM8C,UAWLR,KAAKqB,uBACPrB,KAAKS,kBAAkB/C,EAAM4D,WAKtBtB,KAAKuB,mBAAqBvB,KAAKK,kBAC/BL,KAAKE,iBACZF,KAAKS,kBAAkB/C,EAAMgD,UAE/B,MAEF,KAAKhD,EAAM4D,SAELtB,KAAKwB,mBACPxB,KAAKG,YAAYzC,EAAM+D,SAAmB,GAInCzB,KAAKqB,wBACZrB,KAAKG,YAAYzC,EAAMgD,SAAmB,GAE5C,MAEF,KAAKhD,EAAM+D,SAELzB,KAAKqB,wBACPrB,KAAKG,YAAYzC,EAAMgD,SAAmB,GAE5C,MAEF,KAAKhD,EAAMgD,SAELV,KAAK0B,aACP1B,KAAKF,0BAA4B,EACxBE,KAAK2B,gBACd3B,KAAKF,0BAA4B,GAK/BE,KAAK4B,iBAAmB5B,KAAKF,yBAC/BE,KAAKG,YAAYzC,EAAMmE,KAAe,GAI/B7B,KAAKuB,kBACZvB,KAAKG,YAAYzC,EAAM6C,SAAmB,GAInCP,KAAKK,iBACZL,KAAKG,YAAYzC,EAAM4C,OAAiB,GAIjCN,KAAKE,gBACZF,KAAKG,YAAYzC,EAAM0C,KAAe,GAExC,MAEF,KAAK1C,EAAMmE,KAEL7B,KAAKuB,kBACPvB,KAAKG,YAAYzC,EAAM6C,SAAmB,GAInCP,KAAKK,iBACZL,KAAKG,YAAYzC,EAAM4C,OAAiB,GAIjCN,KAAKE,gBACZF,KAAKG,YAAYzC,EAAM0C,KAAe,GAExC,MAEF,KAAK1C,EAAM6C,SAELP,KAAKK,iBACPL,KAAKG,YAAYzC,EAAM4C,OAAiB,GAIjCN,KAAKE,gBACZF,KAAKG,YAAYzC,EAAM0C,KAAe,GAExC,MAEF,KAAK1C,EAAM4C,OAELN,KAAKE,gBACPF,KAAKG,YAAYzC,EAAM0C,KAAe,QAexCD,YAAA,SAAY2B,EAAiBX,GACnC,OAAQnB,KAAKL,OACX,KAAKjC,EAAMkC,KAET,MACF,KAAKlC,EAAMsD,SACThB,KAAKT,eAAexB,SAAWiC,KAAK+B,sBACpC,MACF,KAAKrE,EAAM8C,UAET,MACF,KAAK9C,EAAM4D,SACTtB,KAAKT,eAAejB,SAAW0B,KAAK+B,sBACpC,MACF,KAAKrE,EAAM+D,SACTzB,KAAKT,eAAef,SAAWwB,KAAK+B,sBACpC,MACF,KAAKrE,EAAMgD,SACTV,KAAKT,eAAeb,SAAWsB,KAAK+B,sBACpC,MACF,KAAKrE,EAAMmE,KACT7B,KAAKT,eAAewB,KAAOf,KAAK+B,sBAChC,MACF,KAAKrE,EAAM6C,SACTP,KAAKT,eAAeR,SAAWiB,KAAK+B,sBACpC,MACF,KAAKrE,EAAM4C,OACTN,KAAKT,eAAeL,OAASc,KAAK+B,sBAClC,MACF,KAAKrE,EAAM0C,KACTJ,KAAKT,eAAeH,KAAOY,KAAK+B,sBAOpC/B,KAAKgC,mCAAmCF,EAAUX,MAG5Ca,mCAAA,SAAmCF,EAAiBX,GAC1DnB,KAAKL,MAAQmC,EAIb9B,KAAKN,eAAiBM,KAAKR,WAAa2B,EAIxCnB,KAAKR,YAAc2B,EACnBnB,KAAKP,eAAiB,KAGhBQ,OAAA,WACND,KAAKR,WAAaQ,KAAKN,eACvBM,KAAKP,eAAiB,KAGhBgB,kBAAA,SAAkBqB,GACxB9B,KAAKC,SACLD,KAAKL,MAAQmC,KAGPG,UAAA,SAAU7I,GAKhB,OAJIA,EAAQ,IACVA,EAAQ4G,KAAKV,UAAUzG,OAASO,GAG9BA,EAAQ4G,KAAKV,UAAUzG,YACbyG,UAAUlG,QAEZkG,UAAUU,KAAKV,UAAUzG,OAAS,MAGxCqJ,wBAAA,SAAwB9I,EAAeC,GAC7C,IAAM4C,EAAkB+D,KAAKiC,UAAU7I,GACvC,OAAO6C,EAAM5C,QAAUA,IACL,SAAf4C,EAAM9C,MACS,iBAAf8C,EAAM9C,MACS,iBAAf8C,EAAM9C,SAGH2H,iBAAA,WACN,YAAYoB,wBAAwBlC,KAAKR,WAAY,QAG/C4B,uBAAA,WACN,YAAYc,wBAAwBlC,KAAKR,WAAa,EAAG,MAClDQ,KAAKkC,wBAAwBlC,KAAKR,WAAa,EAAG,QAGnD6B,qBAAA,WACN,YAAYa,wBAAwBlC,KAAKR,WAAY,QAG/CgC,iBAAA,WACN,YAAYU,wBAAwBlC,KAAKR,WAAY,QAG/CoC,aAAA,WACN,YAAYM,wBAAwBlC,KAAKR,WAAY,QAG/C+B,gBAAA,WACN,YAAYW,wBAAwBlC,KAAKR,WAAY,QAG/Ca,eAAA,WACN,GAAIL,KAAKkC,wBAAwBlC,KAAKR,WAAY,KAChD,SAGF,GAA8C,MAA1CQ,KAAKV,UAAUU,KAAKR,YAAYnG,MAClC,SA0BF,IAAM8I,EAA0BnC,KAAKiC,UAAUjC,KAAKR,WAAa,GACjE,MAA8B,SAAvB2C,EAAchJ,MACS,YAAvBgJ,EAAchJ,MACS,UAAvBgJ,EAAchJ,MACS,aAAvBgJ,EAAchJ,QAGf+G,aAAA,WACN,YAAYgC,wBAAwBlC,KAAKR,WAAY,QAG/CqB,YAAA,WACN,MAA+C,aAAnCvB,UAAUU,KAAKR,YAAYrG,QAGjCyH,aAAA,WACN,MAA+C,cAAnCtB,UAAUU,KAAKR,YAAYrG,QAGjCuI,WAAA,WACN,YAAYQ,wBAAwBlC,KAAKR,WAAY,QAG/CmC,YAAA,WACN,YAAYO,wBAAwBlC,KAAKR,WAAY,QAG/CuC,oBAAA,WACN,IAAM9F,EAAkB+D,KAAKV,UAAUU,KAAKR,YACtC4C,EAAqBpC,KAAKiC,UAAUjC,KAAKN,gBAAgBtG,MAC/D,YAAY6E,MAAMT,UAAU4E,EAAoBnG,EAAM7C,UAGhD6H,gCAAA,WACN,IAAMnH,EAAgD,GACtDuI,OAAOC,OAAOxI,EAASqD,GACvBrD,EAAQe,WAAamD,EACrB,IAAMuE,EAASlG,EAAa2D,KAAK+B,2BAAgCpH,EAAWb,GAC5EkG,KAAKD,yBAA2BnC,EAAgB2E,2BAzalD,WACE,YAAYhD,wBC3CViD,EAA8B,CAClC,WACA,WACA,WACA,WACA,OACA,WACA,SACA,QAKIC,EAAkB,IAExB,SAASC,EAActE,EAAauE,GAClC,GAAmB,iBAARvE,EACT,UAAUnF,kDAEZ,IAAM2J,EAAI,IAAIvE,IAAID,EAAKuE,GACvB,MAAO,CACL5E,SAAU6E,EAAE7E,SAASP,UAAU,EAAGoF,EAAE7E,SAASlF,OAAS,GACtDyF,SAAUsE,EAAEtE,SACZE,SAAUoE,EAAEpE,SACZE,SAAUkE,EAAElE,SACZqC,KAAM6B,EAAE7B,KACRhC,SAAU6D,EAAE7D,SACZG,OAAoB,IAAZ0D,EAAE1D,OAAe0D,EAAE1D,OAAO1B,UAAU,EAAGoF,EAAE1D,OAAOrG,aAAU8B,EAClEyE,KAAgB,IAAVwD,EAAExD,KAAawD,EAAExD,KAAK5B,UAAU,EAAGoF,EAAExD,KAAKvG,aAAU8B,GAO9D,SAASkI,EAAUD,EAAmBE,EAAsBC,GAO1D,IAAIJ,EACJ,GAA4B,iBAAjBG,EAAKH,QACd,IACEA,EAAU,IAAItE,IAAIyE,EAAKH,SACvBC,EAAE7E,SAAW4E,EAAQ5E,SAAW4E,EAAQ5E,SAASP,UAAU,EAAGmF,EAAQ5E,SAASlF,OAAS,GAAK,GAC7F+J,EAAEtE,SAAWqE,EAAQrE,SACrBsE,EAAEpE,SAAWmE,EAAQnE,SACrBoE,EAAElE,SAAWiE,EAAQjE,SACrBkE,EAAE7B,KAAO4B,EAAQ5B,KACjB6B,EAAE7D,SAAW4D,EAAQ5D,SACrB6D,EAAE1D,OAASyD,EAAQzD,OAASyD,EAAQzD,OAAO1B,UAAU,EAAGmF,EAAQzD,OAAOrG,QAAU,GACjF+J,EAAExD,KAAOuD,EAAQvD,KAAOuD,EAAQvD,KAAK5B,UAAU,EAAGmF,EAAQvD,KAAKvG,QAAU,GACzE,SACA,UAAUI,8BAA8B6J,EAAKH,cA0BjD,GApB6B,iBAAlBG,EAAK/E,WACd6E,EAAE7E,kBF0G+BA,EAAkBgF,GA/HvD,IAA0B1J,EAkIxB,OAFA0E,GAhIwB1E,EAgII0E,GA/HlBhC,SA+H4B,KA9H7B1C,EAAMO,OAAO,EAAGP,EAAMR,OA8HO,IA9HSA,QAExCQ,EA8HH0J,GAA0B,KAAbhF,EACRA,EAGFC,EAAuBD,GEjHfiF,CAAqBF,EAAK/E,SAAUgF,IAGtB,iBAAlBD,EAAKxE,WACdsE,EAAEtE,kBF4D+BA,EAAkByE,GACrD,GAAIA,GAA0B,KAAbzE,EACf,OAAOA,EAET,IAAMF,EAAM,IAAIC,IAAI,uBAEpB,OADAD,EAAIE,SAAWA,EACRF,EAAIE,SElEI2E,CAAqBH,EAAKxE,SAAUyE,IAGtB,iBAAlBD,EAAKtE,WACdoE,EAAEpE,kBF+C+BA,EAAkBuE,GACrD,GAAIA,GAA0B,KAAbvE,EACf,OAAOA,EAET,IAAMJ,EAAM,IAAIC,IAAI,uBAEpB,OADAD,EAAII,SAAWA,EACRJ,EAAII,SErDI0E,CAAqBJ,EAAKtE,SAAUuE,IAGtB,iBAAlBD,EAAKpE,WACdkE,EAAElE,kBFgC+BA,EAAkBqE,GACrD,OAAIA,GAA0B,KAAbrE,EACRA,EAELjB,EAAoBiB,GACfC,EAA2BD,GAE3BD,EAAuBC,GEvCjByE,CAAqBL,EAAKpE,SAAUqE,IAG1B,iBAAdD,EAAK/B,OACd6B,EAAE7B,cF8E2BA,EAAchD,EAA8BgF,GAK3E,OAJIjF,EAAuBC,KAAcgD,IACvCA,EAAO,IAGLgC,GAAsB,KAAThC,EACRA,EAGFnC,EAAmBmC,GEvFfqC,CAAiBN,EAAK/B,KAAM6B,EAAE7E,SAAUgF,IAGtB,iBAAlBD,EAAK/D,SAAuB,CAErC,GADA6D,EAAE7D,SAAW+D,EAAK/D,SACd4D,aF/E2B5D,EAAkBgE,GACnD,SAAKhE,EAASlG,QAIM,MAAhBkG,EAAS,MAIRgE,GAIDhE,EAASlG,OAAS,GAUF,MAAfkG,EAAS,IAA6B,KAAfA,EAAS,IAA6B,KAAfA,EAAS,KEwD1CsE,CAAmBT,EAAE7D,SAAUgE,GAAY,CAMzD,IAAMO,EAAaX,EAAQ5D,SAASwE,YAAY,KAC5CD,GAAc,IAGhBV,EAAE7D,SAAW4D,EAAQ5D,SAASvB,UAAU,EAAG8F,EAAa,GAAKV,EAAE7D,UAGnE6D,EAAE7D,kBFuC+BA,EAAkBhB,EAClBgF,GACnC,GAAIA,GAA0B,KAAbhE,EACf,OAAOA,EAGT,GAAIhB,IAAaJ,EAAgB6F,SAASzF,GAExC,OADY,IAAIM,IAAON,MAAYgB,GACxBA,SAGb,IAAM0E,EAA8B,KAAf1E,EAAS,GAO9B,OANAA,EAAW,IAAIV,IAAKoF,EAAiC1E,EAAlB,KAAOA,EACvB,uBAAuBA,SACrC0E,IACH1E,EAAWA,EAASvB,UAAU,EAAGuB,EAASlG,SAGrCkG,EEzDQ2E,CAAqBd,EAAE7D,SAAU6D,EAAE7E,SAAUgF,GAW5D,MAR2B,iBAAhBD,EAAK5D,SACd0D,EAAE1D,gBFJ6BA,EAAgB6D,GAEjD,GADA7D,EAAS5B,EAAiB4B,EAAQ,KAC9B6D,GAAwB,KAAX7D,EACf,OAAOA,EAET,IAAMd,EAAM,IAAIC,IAAI,uBAEpB,OADAD,EAAIc,OAASA,EACNd,EAAIc,OAASd,EAAIc,OAAO1B,UAAU,EAAGY,EAAIc,OAAOrG,QAAU,GEHpD8K,CAAmBb,EAAK5D,OAAQ6D,IAGpB,iBAAdD,EAAK1D,OACdwD,EAAExD,cFlB2BA,EAAc2D,GAE7C,GADA3D,EAAO9B,EAAiB8B,EAAM,KAC1B2D,GAAsB,KAAT3D,EACf,OAAOA,EAET,IAAMhB,EAAM,IAAIC,IAAI,uBAEpB,OADAD,EAAIgB,KAAOA,EACJhB,EAAIgB,KAAOhB,EAAIgB,KAAK5B,UAAU,EAAGY,EAAIgB,KAAKvG,QAAU,GEWhD+K,CAAiBd,EAAK1D,KAAM2D,IAGhCH,EAGT,SAASiB,EAAoBxK,GAC3B,OAAOA,EAAMgC,QAAQ,kBAAmB,QAU1C,SAASyI,EAAgBnL,EACAmB,GAOvB,IANA,IACMiK,QACsBjK,EAAQI,WAAa,OAVpCmB,QAAQ,yBAA0B,cAWzCjD,EAAsB,44RAExB+B,EAAS,GACJvB,EAAI,EAAGA,EAAID,EAAOE,SAAUD,EAAG,CACtC,IAAMqD,EAAQtD,EAAOC,GACfoL,EAAYpL,EAAI,EAAID,EAAOC,EAAI,GAAK,KACpCqL,EAAiBrL,EAAID,EAAOE,OAAS,EAAIF,EAAOC,EAAI,GAAK,KAG/D,GAAqB,iBAAVqD,EASX,GAAsB,KAAlBA,EAAM1C,QAAV,CAUA,IAAM2K,EAAmC,iBAAfjI,EAAMvC,KAM1ByK,OAAuCxJ,IAArBb,EAAQC,SAAyBD,EAAQC,SACR,KACrDqK,EACe,KAAjBnI,EAAMd,QACY,KAAjBc,EAAMnB,SACmB,IAAxBmB,EAAMnB,OAAOjC,SACZsL,EAAgBX,SAASvH,EAAMnB,SAW/BsJ,IAAiBF,GAClBjI,EAAM1C,UAAYwK,GACC,KAAnB9H,EAAMb,WAAmB6I,GAAcA,EAAUnJ,QAChDmJ,EAAU9I,SAGXiJ,EAFuB,iBAAdH,EAEO7L,EAAoBI,KADvByL,EAAUpL,OAAS,EAAIoL,EAAU,GAAK,IAGT,iBAAnBA,EAAUvK,OAShC0K,GAAkC,KAAjBnI,EAAMnB,QAAiBkJ,GACpB,iBAAdA,GAA0BA,EAAUnL,OAAS,IAEtDuL,EAAgBD,EAAgBX,SADnBQ,EAAUA,EAAUnL,OAAS,KAWxCuL,IACFjK,GAAU,KAGZA,GAAU0J,EAAoB5H,EAAMnB,QAEhCoJ,IACF/J,OAAc8B,EAAMvC,MA3FA,OA8FlBuC,EAAM1C,QAgBNY,GAPG+J,GAAgBF,GACoB,iBAAdA,IACPA,EAAU5I,WACVgJ,GACiB,KAAjBnI,EAAMnB,cACd,IAIHmB,EAAM1C,UAAYwK,EAItBG,IACH/J,OAAc4J,OAGhB5J,OAAc8B,EAAM1C,YAQlB0C,EAAM1C,UAAYwK,GAA0BG,GAC3B,KAAjBjI,EAAMd,QACJ/C,EAAoBI,KAAKyD,EAAMd,OAAO,MACxChB,GAAU,MAIdA,GAAU0J,EAAoB5H,EAAMd,QAEhCiJ,IACFjK,GAAU,KAGZA,GAAU8B,EAAMb,aAxHhB,CACE,GAAuB,KAAnBa,EAAMb,SAAiB,CACzBjB,GAAU0J,EAAoB5H,EAAMnB,QACpC,SAEFX,OAAc0J,EAAoB5H,EAAMnB,YAAWmB,EAAMb,cAbzDjB,GAAU0J,EAAoB5H,GAmIlC,OAAO9B,0BASP,WAAY2I,EAAoCH,YAApCG,IAAAA,EAAgC,SALpCvJ,oBACAgJ,OAAc,QACd9G,KAAY,QACZ4I,kBAAyB,GAG/B,IAEE,GAAoB,iBAATvB,EAAmB,CAC5B,IAAMwB,EAAS,IAAIjF,EAAOyD,GAG1B,GAFAwB,EAAOzK,QACPiJ,EAAOwB,EAAOnK,OACVwI,EAAS,CACX,GAAuB,iBAAZA,EAGT,UAAU1J,0DAFV6J,EAAKH,QAAUA,UAIiB,iBAAlBG,EAAK/E,SACrB,UAAU9E,oFAEH0J,EACT,UAAU1J,kDAIZ,IAAK6J,GAAwB,iBAATA,EAClB,UAAU7J,mFAGZ,IAiBIsL,EANJvE,KAAKzG,QAAUsJ,EAXE,CACf9D,SAAU0D,EACV1E,SAAU0E,EACVnE,SAAUmE,EACVjE,SAAUiE,EACV/D,SAAU+D,EACV1B,KAAM0B,EACNvD,OAAQuD,EACRrD,KAAMqD,GAG2BK,GAAM,GAErChF,EAAuBkC,KAAKzG,QAAQwE,YAAciC,KAAKzG,QAAQwH,OACjEf,KAAKzG,QAAQwH,KAAO,IAOtB,cAAkByB,kBAChB,IADG+B,kBACqBhL,QAAxB,CAEA,IAAMO,EAAgD,GAChDP,EAAUyG,KAAKzG,QAAQgL,GAE7B,OADAvE,KAAKvE,KAAK8I,GAAa,GACfA,GACN,IAAK,WACHlC,OAAOC,OAAOxI,EAASqD,GACvBrD,EAAQe,WAAamD,EACrB,MACF,IAAK,WACHqE,OAAOC,OAAOxI,EAASqD,GACvBrD,EAAQe,WAAasD,EACrB,MACF,IAAK,WACHkE,OAAOC,OAAOxI,EAASqD,GACvBrD,EAAQe,WAAa0D,EACrB,MACF,IAAK,WACH8D,OAAOC,OAAOxI,EAASsD,GAErBtD,EAAQe,WADN4C,EAAoBlE,GACDoF,EAEAF,EAEvB,MACF,IAAK,OACH4D,OAAOC,OAAOxI,EAASqD,GACvBrD,EAAQe,WAAa+D,EACrB,MACF,IAAK,WACChB,EAAgBoC,KAAKuC,OAAOxE,WAC9BsE,OAAOC,OAAOxI,EAASuD,GACvBvD,EAAQe,WAAaiE,IAErBuD,OAAOC,OAAOxI,EAASqD,GACvBrD,EAAQe,WAAamE,GAEvB,MACF,IAAK,SACHqD,OAAOC,OAAOxI,EAASqD,GACvBrD,EAAQe,WAAaoE,EACrB,MACF,IAAK,OACHoD,OAAOC,OAAOxI,EAASqD,GACvBrD,EAAQe,WAAasE,EAGzB,IACE,IAAMxG,EAASkB,EAAMN,EAAmBO,GACxCkG,KAAKuC,OAAOgC,GAAa/I,EAAe7C,EAAQqH,KAAKvE,KAAK8I,GAAYzK,GACtEkG,KAAKqE,kBAAkBE,GAAaT,EAAgBnL,EAAQmB,GAC5D,SAEA,UAAUb,qBAAqBsL,eAAsBvE,KAAKzG,QAAQgL,WAGtE,MAAOC,GACP,UAAUvL,+CAA+CuL,EAAIC,UA/GnE,2BAmHEjM,KAAA,SAAKyF,EAAqC0E,YAArC1E,IAAAA,EAAiC,IACpC,IA8BIsG,EA9BAG,EAAyB,CAC3B3F,SAAU,GACVhB,SAAU,GACVO,SAAU,GACVE,SAAU,GACVE,SAAU,GACVqC,KAAM,GACN7B,OAAQ,GACRE,KAAM,IAGR,GAAsB,iBAAXnB,GAAuB0E,EAChC,UAAU1J,kDAGZ,QAAqB,IAAVgF,EACT,SAGF,IAEIyG,EAAS7B,EAAU6B,EADA,iBAAVzG,EACkBA,EAEAyE,EAAczE,EAAO0E,IAFd,GAIpC,MAAO6B,GAEP,SAIF,IAAKD,UAAkBhL,QACrB,IAAKyG,KAAKuC,OAAOgC,GAAW/H,KAAKkI,EAAOH,IACtC,SAIJ,YAGF/H,KAAA,SAAKyB,EAAqC0E,YAArC1E,IAAAA,EAAiC,IACpC,IAAIyG,EAAyB,CAC3B3F,SAAU,GACVhB,SAAU,GACVO,SAAU,GACVE,SAAU,GACVE,SAAU,GACVqC,KAAM,GACN7B,OAAQ,GACRE,KAAM,IAGR,GAAsB,iBAAXnB,GAAuB0E,EAChC,UAAU1J,kDAGZ,QAAqB,IAAVgF,EAAX,CAIA,IAEIyG,EAAS7B,EAAU6B,EADA,iBAAVzG,EACkBA,EAEAyE,EAAczE,EAAO0E,IAFd,GAIpC,MAAO6B,GAEP,YAGF,IAOID,EAPApK,EAAc,GAQlB,IAAKoK,KANHpK,EAAOwK,OADLhC,EACc,CAAC1E,EAAO0E,GAER,CAAC1E,QAII1E,QAAS,CAC9B,IAAIqL,EAAQ5E,KAAKuC,OAAOgC,GAAW/H,KAAKkI,EAAOH,IAC/C,IAAKK,EACH,YAIF,IADA,MAAIC,EAAS,OACQ7E,KAAKvE,KAAK8I,GAAWO,0BAAW,eAAxC1K,OACa,iBAAbA,EAAIV,MAAyC,iBAAbU,EAAIV,OAE7CmL,EAAOzK,EAAIV,MADCkL,OAAU,IACM,IAIhCzK,EAAOoK,GAAa,CAClBtG,MAAOyG,EAAOH,IAAc,GAC5BM,OAAAA,GAIJ,OAAO1K,6BAGT,WACE,YAAYkK,kBAAkBtG,+BAGhC,WACE,YAAYsG,kBAAkB/F,+BAGhC,WACE,YAAY+F,kBAAkB7F,+BAGhC,WACE,YAAY6F,kBAAkB3F,2BAGhC,WACE,YAAY2F,kBAAkBtD,2BAGhC,WACE,YAAYsD,kBAAkBtF,6BAGhC,WACE,YAAYsF,kBAAkBnF,yBAGhC,WACE,YAAYmF,kBAAkBjF"}