{"version":3,"file":"css-anchor-positioning.umd.cjs","sources":["../node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs","../node_modules/@floating-ui/core/dist/floating-ui.core.mjs","../node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs","../node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs","../node_modules/css-tree/lib/walker/create.js","../node_modules/css-tree/lib/tokenizer/types.js","../node_modules/css-tree/lib/tokenizer/char-code-definitions.js","../node_modules/css-tree/lib/tokenizer/utils.js","../node_modules/css-tree/lib/tokenizer/names.js","../node_modules/css-tree/lib/tokenizer/adopt-buffer.js","../node_modules/css-tree/lib/tokenizer/OffsetToLocation.js","../node_modules/css-tree/lib/tokenizer/TokenStream.js","../node_modules/css-tree/lib/tokenizer/index.js","../node_modules/css-tree/lib/syntax/node/AnPlusB.js","../node_modules/css-tree/lib/syntax/node/Atrule.js","../node_modules/css-tree/lib/syntax/node/AtrulePrelude.js","../node_modules/css-tree/lib/syntax/node/AttributeSelector.js","../node_modules/css-tree/lib/syntax/node/Block.js","../node_modules/css-tree/lib/syntax/node/Brackets.js","../node_modules/css-tree/lib/syntax/node/CDC.js","../node_modules/css-tree/lib/syntax/node/CDO.js","../node_modules/css-tree/lib/syntax/node/ClassSelector.js","../node_modules/css-tree/lib/syntax/node/Combinator.js","../node_modules/css-tree/lib/syntax/node/Comment.js","../node_modules/css-tree/lib/syntax/node/Condition.js","../node_modules/css-tree/lib/utils/names.js","../node_modules/css-tree/lib/syntax/node/Declaration.js","../node_modules/css-tree/lib/syntax/node/DeclarationList.js","../node_modules/css-tree/lib/syntax/node/Dimension.js","../node_modules/css-tree/lib/syntax/node/Feature.js","../node_modules/css-tree/lib/syntax/node/FeatureFunction.js","../node_modules/css-tree/lib/syntax/node/FeatureRange.js","../node_modules/css-tree/lib/syntax/node/Function.js","../node_modules/css-tree/lib/syntax/node/GeneralEnclosed.js","../node_modules/css-tree/lib/syntax/node/Hash.js","../node_modules/css-tree/lib/syntax/node/Identifier.js","../node_modules/css-tree/lib/syntax/node/IdSelector.js","../node_modules/css-tree/lib/syntax/node/Layer.js","../node_modules/css-tree/lib/syntax/node/LayerList.js","../node_modules/css-tree/lib/syntax/node/MediaQuery.js","../node_modules/css-tree/lib/syntax/node/MediaQueryList.js","../node_modules/css-tree/lib/syntax/node/NestingSelector.js","../node_modules/css-tree/lib/syntax/node/Nth.js","../node_modules/css-tree/lib/syntax/node/Number.js","../node_modules/css-tree/lib/syntax/node/Operator.js","../node_modules/css-tree/lib/syntax/node/Parentheses.js","../node_modules/css-tree/lib/syntax/node/Percentage.js","../node_modules/css-tree/lib/syntax/node/PseudoClassSelector.js","../node_modules/css-tree/lib/syntax/node/PseudoElementSelector.js","../node_modules/css-tree/lib/syntax/node/Ratio.js","../node_modules/css-tree/lib/syntax/node/Raw.js","../node_modules/css-tree/lib/syntax/node/Rule.js","../node_modules/css-tree/lib/syntax/node/Scope.js","../node_modules/css-tree/lib/syntax/node/Selector.js","../node_modules/css-tree/lib/syntax/node/SelectorList.js","../node_modules/css-tree/lib/utils/string.js","../node_modules/css-tree/lib/syntax/node/String.js","../node_modules/css-tree/lib/syntax/node/StyleSheet.js","../node_modules/css-tree/lib/syntax/node/SupportsDeclaration.js","../node_modules/css-tree/lib/syntax/node/TypeSelector.js","../node_modules/css-tree/lib/syntax/node/UnicodeRange.js","../node_modules/css-tree/lib/utils/url.js","../node_modules/css-tree/lib/syntax/node/Url.js","../node_modules/css-tree/lib/syntax/node/Value.js","../node_modules/css-tree/lib/syntax/node/WhiteSpace.js","../node_modules/css-tree/lib/walker/index.js","../node_modules/css-tree/lib/syntax/config/walker.js","../src/syntax.ts","../node_modules/css-tree/lib/generator/sourceMap.js","../node_modules/css-tree/lib/generator/token-before.js","../node_modules/css-tree/lib/generator/create.js","../node_modules/css-tree/lib/generator/index.js","../node_modules/css-tree/lib/syntax/config/generator.js","../node_modules/css-tree/lib/utils/List.js","../node_modules/css-tree/lib/utils/create-custom-error.js","../node_modules/css-tree/lib/parser/SyntaxError.js","../node_modules/css-tree/lib/parser/sequence.js","../node_modules/css-tree/lib/parser/create.js","../node_modules/css-tree/lib/syntax/scope/default.js","../node_modules/css-tree/lib/syntax/scope/atrulePrelude.js","../node_modules/css-tree/lib/syntax/scope/selector.js","../node_modules/css-tree/lib/syntax/function/expression.js","../node_modules/css-tree/lib/syntax/function/var.js","../node_modules/css-tree/lib/syntax/scope/value.js","../node_modules/css-tree/lib/syntax/atrule/container.js","../node_modules/css-tree/lib/syntax/atrule/font-face.js","../node_modules/css-tree/lib/syntax/atrule/import.js","../node_modules/css-tree/lib/syntax/atrule/index.js","../node_modules/css-tree/lib/syntax/atrule/layer.js","../node_modules/css-tree/lib/syntax/atrule/media.js","../node_modules/css-tree/lib/syntax/atrule/nest.js","../node_modules/css-tree/lib/syntax/atrule/page.js","../node_modules/css-tree/lib/syntax/atrule/scope.js","../node_modules/css-tree/lib/syntax/atrule/starting-style.js","../node_modules/css-tree/lib/syntax/atrule/supports.js","../node_modules/css-tree/lib/syntax/pseudo/lang.js","../node_modules/css-tree/lib/syntax/pseudo/index.js","../node_modules/css-tree/lib/parser/index.js","../node_modules/css-tree/lib/syntax/config/parser.js","../node_modules/css-tree/lib/utils/clone.js","../node_modules/nanoid/non-secure/index.js","../src/utils.ts","../src/cascade.ts","../src/dom.ts","../src/fetch.ts","../node_modules/nanoid/url-alphabet/index.js","../node_modules/nanoid/index.browser.js","../src/position-area.ts","../src/fallback.ts","../src/validate.ts","../src/parse.ts","../src/transform.ts","../src/polyfill.ts","../src/index.ts"],"sourcesContent":["/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n","import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    x,\n    y,\n    width: rects.floating.width,\n    height: rects.floating.height\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const initialSideAxis = getSideAxis(initialPlacement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';\n      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          const ignoreCrossAxisOverflow = checkCrossAxis === 'alignment' ? initialSideAxis !== getSideAxis(nextPlacement) : false;\n          if (!ignoreCrossAxisOverflow ||\n          // We leave the current main axis only if every placement on that axis\n          // overflows the main axis.\n          overflowsData.every(d => d.overflows[0] > 0 && getSideAxis(d.placement) === initialSideAxis)) {\n            // Try next placement and re-run the lifecycle.\n            return {\n              data: {\n                index: nextIndex,\n                overflows: overflowsData\n              },\n              reset: {\n                placement: nextPlacement\n              }\n            };\n          }\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$filter2;\n                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {\n                  if (hasFallbackAxisSideDirection) {\n                    const currentSideAxis = getSideAxis(d.placement);\n                    return currentSideAxis === initialSideAxis ||\n                    // Create a bias to the `y` side axis due to horizontal\n                    // reading directions favoring greater width.\n                    currentSideAxis === 'y';\n                  }\n                  return true;\n                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: rawValue.mainAxis || 0,\n    crossAxis: rawValue.crossAxis || 0,\n    alignmentAxis: rawValue.alignmentAxis\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y,\n          enabled: {\n            [mainAxis]: checkMainAxis,\n            [crossAxis]: checkCrossAxis\n          }\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      var _state$middlewareData, _state$middlewareData2;\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const maximumClippingHeight = height - overflow.top - overflow.bottom;\n      const maximumClippingWidth = width - overflow.left - overflow.right;\n      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);\n      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {\n        availableWidth = maximumClippingWidth;\n      }\n      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {\n        availableHeight = maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n","function hasWindow() {\n  return typeof window !== 'undefined';\n}\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  if (!hasWindow() || typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isTopLayer(element) {\n  return [':popover-open', ':modal'].some(selector => {\n    try {\n      return element.matches(selector);\n    } catch (e) {\n      return false;\n    }\n  });\n}\nfunction isContainingBlock(elementOrCss) {\n  const webkit = isWebKit();\n  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  // https://drafts.csswg.org/css-transforms-2/#individual-transforms\n  return ['transform', 'translate', 'scale', 'rotate', 'perspective'].some(value => css[value] ? css[value] !== 'none' : false) || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'translate', 'scale', 'rotate', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else if (isTopLayer(currentNode)) {\n      return null;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    const frameElement = getFrameElement(win);\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getFrameElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isTopLayer, isWebKit };\n","import { rectToClientRect, arrow as arrow$1, autoPlacement as autoPlacement$1, detectOverflow as detectOverflow$1, flip as flip$1, hide as hide$1, inline as inline$1, limitShift as limitShift$1, offset as offset$1, shift as shift$1, size as size$1, computePosition as computePosition$1 } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getFrameElement, getNodeScroll, getDocumentElement, isTopLayer, getNodeName, isOverflowElement, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = getFrameElement(currentWin);\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = getFrameElement(currentWin);\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\n// If <html> has a CSS width greater than the viewport, then this will be\n// incorrect for RTL.\nfunction getWindowScrollBarX(element, rect) {\n  const leftScroll = getNodeScroll(element).scrollLeft;\n  if (!rect) {\n    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;\n  }\n  return rect.left + leftScroll;\n}\n\nfunction getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {\n  if (ignoreScrollbarX === void 0) {\n    ignoreScrollbarX = false;\n  }\n  const htmlRect = documentElement.getBoundingClientRect();\n  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 :\n  // RTL <body> scrollbar.\n  getWindowScrollBarX(documentElement, htmlRect));\n  const y = htmlRect.top + scroll.scrollTop;\n  return {\n    x,\n    y\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y,\n      width: clippingAncestor.width,\n      height: clippingAncestor.height\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n\n  // If the <body> scrollbar appears on the left (e.g. RTL systems). Use\n  // Firefox with layout.scrollbar.side = 3 in about:config to test this.\n  function setLeftRTLScrollbarOffset() {\n    offsets.x = getWindowScrollBarX(documentElement);\n  }\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      setLeftRTLScrollbarOffset();\n    }\n  }\n  if (isFixed && !isOffsetParentAnElement && documentElement) {\n    setLeftRTLScrollbarOffset();\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);\n  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;\n  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction isStaticPositioned(element) {\n  return getComputedStyle(element).position === 'static';\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  let rawOffsetParent = element.offsetParent;\n\n  // Firefox returns the <html> element as the offsetParent if it's non-static,\n  // while Chrome and Safari return the <body> element. The <body> element must\n  // be used to perform the correct calculations even if the <html> element is\n  // non-static.\n  if (getDocumentElement(element) === rawOffsetParent) {\n    rawOffsetParent = rawOffsetParent.ownerDocument.body;\n  }\n  return rawOffsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const win = getWindow(element);\n  if (isTopLayer(element)) {\n    return win;\n  }\n  if (!isHTMLElement(element)) {\n    let svgOffsetParent = getParentNode(element);\n    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = getParentNode(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {\n    return win;\n  }\n  return offsetParent || getContainingBlock(element) || win;\n}\n\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  const floatingDimensions = await getDimensionsFn(data.floating);\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      width: floatingDimensions.width,\n      height: floatingDimensions.height\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\nfunction rectsAreEqual(a, b) {\n  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;\n}\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const elementRectForRootMargin = element.getBoundingClientRect();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = elementRectForRootMargin;\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          // If the reference is clipped, the ratio is 0. Throttle the refresh\n          // to prevent an infinite loop of updates.\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1000);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {\n        // It's possible that even though the ratio is reported as 1, the\n        // element is not actually fully within the IntersectionObserver's root\n        // area anymore. This can happen under performance constraints. This may\n        // be a bug in the browser's IntersectionObserver implementation. To\n        // work around this, we compare the element's bounding rect now with\n        // what it was at the time we created the IntersectionObserver. If they\n        // are not equal then the element moved, so we refresh.\n        refresh();\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (_e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nconst detectOverflow = detectOverflow$1;\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = offset$1;\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = autoPlacement$1;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = shift$1;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = flip$1;\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = size$1;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = hide$1;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = arrow$1;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = inline$1;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = limitShift$1;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, platform, shift, size };\n","const { hasOwnProperty } = Object.prototype;\nconst noop = function() {};\n\nfunction ensureFunction(value) {\n    return typeof value === 'function' ? value : noop;\n}\n\nfunction invokeForType(fn, type) {\n    return function(node, item, list) {\n        if (node.type === type) {\n            fn.call(this, node, item, list);\n        }\n    };\n}\n\nfunction getWalkersFromStructure(name, nodeType) {\n    const structure = nodeType.structure;\n    const walkers = [];\n\n    for (const key in structure) {\n        if (hasOwnProperty.call(structure, key) === false) {\n            continue;\n        }\n\n        let fieldTypes = structure[key];\n        const walker = {\n            name: key,\n            type: false,\n            nullable: false\n        };\n\n        if (!Array.isArray(fieldTypes)) {\n            fieldTypes = [fieldTypes];\n        }\n\n        for (const fieldType of fieldTypes) {\n            if (fieldType === null) {\n                walker.nullable = true;\n            } else if (typeof fieldType === 'string') {\n                walker.type = 'node';\n            } else if (Array.isArray(fieldType)) {\n                walker.type = 'list';\n            }\n        }\n\n        if (walker.type) {\n            walkers.push(walker);\n        }\n    }\n\n    if (walkers.length) {\n        return {\n            context: nodeType.walkContext,\n            fields: walkers\n        };\n    }\n\n    return null;\n}\n\nfunction getTypesFromConfig(config) {\n    const types = {};\n\n    for (const name in config.node) {\n        if (hasOwnProperty.call(config.node, name)) {\n            const nodeType = config.node[name];\n\n            if (!nodeType.structure) {\n                throw new Error('Missed `structure` field in `' + name + '` node type definition');\n            }\n\n            types[name] = getWalkersFromStructure(name, nodeType);\n        }\n    }\n\n    return types;\n}\n\nfunction createTypeIterator(config, reverse) {\n    const fields = config.fields.slice();\n    const contextName = config.context;\n    const useContext = typeof contextName === 'string';\n\n    if (reverse) {\n        fields.reverse();\n    }\n\n    return function(node, context, walk, walkReducer) {\n        let prevContextValue;\n\n        if (useContext) {\n            prevContextValue = context[contextName];\n            context[contextName] = node;\n        }\n\n        for (const field of fields) {\n            const ref = node[field.name];\n\n            if (!field.nullable || ref) {\n                if (field.type === 'list') {\n                    const breakWalk = reverse\n                        ? ref.reduceRight(walkReducer, false)\n                        : ref.reduce(walkReducer, false);\n\n                    if (breakWalk) {\n                        return true;\n                    }\n                } else if (walk(ref)) {\n                    return true;\n                }\n            }\n        }\n\n        if (useContext) {\n            context[contextName] = prevContextValue;\n        }\n    };\n}\n\nfunction createFastTraveralMap({\n    StyleSheet,\n    Atrule,\n    Rule,\n    Block,\n    DeclarationList\n}) {\n    return {\n        Atrule: {\n            StyleSheet,\n            Atrule,\n            Rule,\n            Block\n        },\n        Rule: {\n            StyleSheet,\n            Atrule,\n            Rule,\n            Block\n        },\n        Declaration: {\n            StyleSheet,\n            Atrule,\n            Rule,\n            Block,\n            DeclarationList\n        }\n    };\n}\n\nexport function createWalker(config) {\n    const types = getTypesFromConfig(config);\n    const iteratorsNatural = {};\n    const iteratorsReverse = {};\n    const breakWalk = Symbol('break-walk');\n    const skipNode = Symbol('skip-node');\n\n    for (const name in types) {\n        if (hasOwnProperty.call(types, name) && types[name] !== null) {\n            iteratorsNatural[name] = createTypeIterator(types[name], false);\n            iteratorsReverse[name] = createTypeIterator(types[name], true);\n        }\n    }\n\n    const fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);\n    const fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);\n\n    const walk = function(root, options) {\n        function walkNode(node, item, list) {\n            const enterRet = enter.call(context, node, item, list);\n\n            if (enterRet === breakWalk) {\n                return true;\n            }\n\n            if (enterRet === skipNode) {\n                return false;\n            }\n\n            if (iterators.hasOwnProperty(node.type)) {\n                if (iterators[node.type](node, context, walkNode, walkReducer)) {\n                    return true;\n                }\n            }\n\n            if (leave.call(context, node, item, list) === breakWalk) {\n                return true;\n            }\n\n            return false;\n        }\n\n        let enter = noop;\n        let leave = noop;\n        let iterators = iteratorsNatural;\n        let walkReducer = (ret, data, item, list) => ret || walkNode(data, item, list);\n        const context = {\n            break: breakWalk,\n            skip: skipNode,\n\n            root,\n            stylesheet: null,\n            atrule: null,\n            atrulePrelude: null,\n            rule: null,\n            selector: null,\n            block: null,\n            declaration: null,\n            function: null\n        };\n\n        if (typeof options === 'function') {\n            enter = options;\n        } else if (options) {\n            enter = ensureFunction(options.enter);\n            leave = ensureFunction(options.leave);\n\n            if (options.reverse) {\n                iterators = iteratorsReverse;\n            }\n\n            if (options.visit) {\n                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {\n                    iterators = options.reverse\n                        ? fastTraversalIteratorsReverse[options.visit]\n                        : fastTraversalIteratorsNatural[options.visit];\n                } else if (!types.hasOwnProperty(options.visit)) {\n                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).sort().join(', ') + ')');\n                }\n\n                enter = invokeForType(enter, options.visit);\n                leave = invokeForType(leave, options.visit);\n            }\n        }\n\n        if (enter === noop && leave === noop) {\n            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\\'t a function');\n        }\n\n        walkNode(root);\n    };\n\n    walk.break = breakWalk;\n    walk.skip = skipNode;\n\n    walk.find = function(ast, fn) {\n        let found = null;\n\n        walk(ast, function(node, item, list) {\n            if (fn.call(this, node, item, list)) {\n                found = node;\n                return breakWalk;\n            }\n        });\n\n        return found;\n    };\n\n    walk.findLast = function(ast, fn) {\n        let found = null;\n\n        walk(ast, {\n            reverse: true,\n            enter(node, item, list) {\n                if (fn.call(this, node, item, list)) {\n                    found = node;\n                    return breakWalk;\n                }\n            }\n        });\n\n        return found;\n    };\n\n    walk.findAll = function(ast, fn) {\n        const found = [];\n\n        walk(ast, function(node, item, list) {\n            if (fn.call(this, node, item, list)) {\n                found.push(node);\n            }\n        });\n\n        return found;\n    };\n\n    return walk;\n};\n","// CSS Syntax Module Level 3\n// https://www.w3.org/TR/css-syntax-3/\nexport const EOF = 0;                 // <EOF-token>\nexport const Ident = 1;               // <ident-token>\nexport const Function = 2;            // <function-token>\nexport const AtKeyword = 3;           // <at-keyword-token>\nexport const Hash = 4;                // <hash-token>\nexport const String = 5;              // <string-token>\nexport const BadString = 6;           // <bad-string-token>\nexport const Url = 7;                 // <url-token>\nexport const BadUrl = 8;              // <bad-url-token>\nexport const Delim = 9;               // <delim-token>\nexport const Number = 10;             // <number-token>\nexport const Percentage = 11;         // <percentage-token>\nexport const Dimension = 12;          // <dimension-token>\nexport const WhiteSpace = 13;         // <whitespace-token>\nexport const CDO = 14;                // <CDO-token>\nexport const CDC = 15;                // <CDC-token>\nexport const Colon = 16;              // <colon-token>     :\nexport const Semicolon = 17;          // <semicolon-token> ;\nexport const Comma = 18;              // <comma-token>     ,\nexport const LeftSquareBracket = 19;  // <[-token>\nexport const RightSquareBracket = 20; // <]-token>\nexport const LeftParenthesis = 21;    // <(-token>\nexport const RightParenthesis = 22;   // <)-token>\nexport const LeftCurlyBracket = 23;   // <{-token>\nexport const RightCurlyBracket = 24;  // <}-token>\nexport const Comment = 25;\n","const EOF = 0;\n\n// https://drafts.csswg.org/css-syntax-3/\n// § 4.2. Definitions\n\n// digit\n// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).\nexport function isDigit(code) {\n    return code >= 0x0030 && code <= 0x0039;\n}\n\n// hex digit\n// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),\n// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).\nexport function isHexDigit(code) {\n    return (\n        isDigit(code) || // 0 .. 9\n        (code >= 0x0041 && code <= 0x0046) || // A .. F\n        (code >= 0x0061 && code <= 0x0066)    // a .. f\n    );\n}\n\n// uppercase letter\n// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).\nexport function isUppercaseLetter(code) {\n    return code >= 0x0041 && code <= 0x005A;\n}\n\n// lowercase letter\n// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).\nexport function isLowercaseLetter(code) {\n    return code >= 0x0061 && code <= 0x007A;\n}\n\n// letter\n// An uppercase letter or a lowercase letter.\nexport function isLetter(code) {\n    return isUppercaseLetter(code) || isLowercaseLetter(code);\n}\n\n// non-ASCII code point\n// A code point with a value equal to or greater than U+0080 <control>.\n//\n// 2024-09-02: The latest spec narrows the range for non-ASCII characters (see https://github.com/csstree/csstree/issues/188).\n// However, all modern browsers support a wider range, and strictly following the latest spec could result\n// in some CSS being parsed incorrectly, even though it works in the browser. Therefore, this function adheres\n// to the previous, broader definition of non-ASCII characters.\nexport function isNonAscii(code) {\n    return code >= 0x0080;\n}\n\n// name-start code point\n// A letter, a non-ASCII code point, or U+005F LOW LINE (_).\nexport function isNameStart(code) {\n    return isLetter(code) || isNonAscii(code) || code === 0x005F;\n}\n\n// name code point\n// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).\nexport function isName(code) {\n    return isNameStart(code) || isDigit(code) || code === 0x002D;\n}\n\n// non-printable code point\n// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,\n// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.\nexport function isNonPrintable(code) {\n    return (\n        (code >= 0x0000 && code <= 0x0008) ||\n        (code === 0x000B) ||\n        (code >= 0x000E && code <= 0x001F) ||\n        (code === 0x007F)\n    );\n}\n\n// newline\n// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,\n// as they are converted to U+000A LINE FEED during preprocessing.\n// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED\nexport function isNewline(code) {\n    return code === 0x000A || code === 0x000D || code === 0x000C;\n}\n\n// whitespace\n// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.\nexport function isWhiteSpace(code) {\n    return isNewline(code) || code === 0x0020 || code === 0x0009;\n}\n\n// § 4.3.8. Check if two code points are a valid escape\nexport function isValidEscape(first, second) {\n    // If the first code point is not U+005C REVERSE SOLIDUS (\\), return false.\n    if (first !== 0x005C) {\n        return false;\n    }\n\n    // Otherwise, if the second code point is a newline or EOF, return false.\n    if (isNewline(second) || second === EOF) {\n        return false;\n    }\n\n    // Otherwise, return true.\n    return true;\n}\n\n// § 4.3.9. Check if three code points would start an identifier\nexport function isIdentifierStart(first, second, third) {\n    // Look at the first code point:\n\n    // U+002D HYPHEN-MINUS\n    if (first === 0x002D) {\n        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,\n        // or the second and third code points are a valid escape, return true. Otherwise, return false.\n        return (\n            isNameStart(second) ||\n            second === 0x002D ||\n            isValidEscape(second, third)\n        );\n    }\n\n    // name-start code point\n    if (isNameStart(first)) {\n        // Return true.\n        return true;\n    }\n\n    // U+005C REVERSE SOLIDUS (\\)\n    if (first === 0x005C) {\n        // If the first and second code points are a valid escape, return true. Otherwise, return false.\n        return isValidEscape(first, second);\n    }\n\n    // anything else\n    // Return false.\n    return false;\n}\n\n// § 4.3.10. Check if three code points would start a number\nexport function isNumberStart(first, second, third) {\n    // Look at the first code point:\n\n    // U+002B PLUS SIGN (+)\n    // U+002D HYPHEN-MINUS (-)\n    if (first === 0x002B || first === 0x002D) {\n        // If the second code point is a digit, return true.\n        if (isDigit(second)) {\n            return 2;\n        }\n\n        // Otherwise, if the second code point is a U+002E FULL STOP (.)\n        // and the third code point is a digit, return true.\n        // Otherwise, return false.\n        return second === 0x002E && isDigit(third) ? 3 : 0;\n    }\n\n    // U+002E FULL STOP (.)\n    if (first === 0x002E) {\n        // If the second code point is a digit, return true. Otherwise, return false.\n        return isDigit(second) ? 2 : 0;\n    }\n\n    // digit\n    if (isDigit(first)) {\n        // Return true.\n        return 1;\n    }\n\n    // anything else\n    // Return false.\n    return 0;\n}\n\n//\n// Misc\n//\n\n// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)\nexport function isBOM(code) {\n    // UTF-16BE\n    if (code === 0xFEFF) {\n        return 1;\n    }\n\n    // UTF-16LE\n    if (code === 0xFFFE) {\n        return 1;\n    }\n\n    return 0;\n}\n\n// Fast code category\n// Only ASCII code points has a special meaning, that's why we define a maps for 0..127 codes only\nconst CATEGORY = new Array(0x80);\nexport const EofCategory = 0x80;\nexport const WhiteSpaceCategory = 0x82;\nexport const DigitCategory = 0x83;\nexport const NameStartCategory = 0x84;\nexport const NonPrintableCategory = 0x85;\n\nfor (let i = 0; i < CATEGORY.length; i++) {\n    CATEGORY[i] =\n        isWhiteSpace(i) && WhiteSpaceCategory ||\n        isDigit(i) && DigitCategory ||\n        isNameStart(i) && NameStartCategory ||\n        isNonPrintable(i) && NonPrintableCategory ||\n        i || EofCategory;\n}\n\nexport function charCodeCategory(code) {\n    return code < 0x80 ? CATEGORY[code] : NameStartCategory;\n}\n","import {\n    isDigit,\n    isHexDigit,\n    isUppercaseLetter,\n    isName,\n    isWhiteSpace,\n    isValidEscape\n} from './char-code-definitions.js';\n\nfunction getCharCode(source, offset) {\n    return offset < source.length ? source.charCodeAt(offset) : 0;\n}\n\nexport function getNewlineLength(source, offset, code) {\n    if (code === 13 /* \\r */ && getCharCode(source, offset + 1) === 10 /* \\n */) {\n        return 2;\n    }\n\n    return 1;\n}\n\nexport function cmpChar(testStr, offset, referenceCode) {\n    let code = testStr.charCodeAt(offset);\n\n    // code.toLowerCase() for A..Z\n    if (isUppercaseLetter(code)) {\n        code = code | 32;\n    }\n\n    return code === referenceCode;\n}\n\nexport function cmpStr(testStr, start, end, referenceStr) {\n    if (end - start !== referenceStr.length) {\n        return false;\n    }\n\n    if (start < 0 || end > testStr.length) {\n        return false;\n    }\n\n    for (let i = start; i < end; i++) {\n        const referenceCode = referenceStr.charCodeAt(i - start);\n        let testCode = testStr.charCodeAt(i);\n\n        // testCode.toLowerCase() for A..Z\n        if (isUppercaseLetter(testCode)) {\n            testCode = testCode | 32;\n        }\n\n        if (testCode !== referenceCode) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nexport function findWhiteSpaceStart(source, offset) {\n    for (; offset >= 0; offset--) {\n        if (!isWhiteSpace(source.charCodeAt(offset))) {\n            break;\n        }\n    }\n\n    return offset + 1;\n}\n\nexport function findWhiteSpaceEnd(source, offset) {\n    for (; offset < source.length; offset++) {\n        if (!isWhiteSpace(source.charCodeAt(offset))) {\n            break;\n        }\n    }\n\n    return offset;\n}\n\nexport function findDecimalNumberEnd(source, offset) {\n    for (; offset < source.length; offset++) {\n        if (!isDigit(source.charCodeAt(offset))) {\n            break;\n        }\n    }\n\n    return offset;\n}\n\n// § 4.3.7. Consume an escaped code point\nexport function consumeEscaped(source, offset) {\n    // It assumes that the U+005C REVERSE SOLIDUS (\\) has already been consumed and\n    // that the next input code point has already been verified to be part of a valid escape.\n    offset += 2;\n\n    // hex digit\n    if (isHexDigit(getCharCode(source, offset - 1))) {\n        // Consume as many hex digits as possible, but no more than 5.\n        // Note that this means 1-6 hex digits have been consumed in total.\n        for (const maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {\n            if (!isHexDigit(getCharCode(source, offset))) {\n                break;\n            }\n        }\n\n        // If the next input code point is whitespace, consume it as well.\n        const code = getCharCode(source, offset);\n        if (isWhiteSpace(code)) {\n            offset += getNewlineLength(source, offset, code);\n        }\n    }\n\n    return offset;\n}\n\n// §4.3.11. Consume a name\n// Note: This algorithm does not do the verification of the first few code points that are necessary\n// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,\n// ensure that the stream starts with an identifier before calling this algorithm.\nexport function consumeName(source, offset) {\n    // Let result initially be an empty string.\n    // Repeatedly consume the next input code point from the stream:\n    for (; offset < source.length; offset++) {\n        const code = source.charCodeAt(offset);\n\n        // name code point\n        if (isName(code)) {\n            // Append the code point to result.\n            continue;\n        }\n\n        // the stream starts with a valid escape\n        if (isValidEscape(code, getCharCode(source, offset + 1))) {\n            // Consume an escaped code point. Append the returned code point to result.\n            offset = consumeEscaped(source, offset) - 1;\n            continue;\n        }\n\n        // anything else\n        // Reconsume the current input code point. Return result.\n        break;\n    }\n\n    return offset;\n}\n\n// §4.3.12. Consume a number\nexport function consumeNumber(source, offset) {\n    let code = source.charCodeAt(offset);\n\n    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),\n    // consume it and append it to repr.\n    if (code === 0x002B || code === 0x002D) {\n        code = source.charCodeAt(offset += 1);\n    }\n\n    // 3. While the next input code point is a digit, consume it and append it to repr.\n    if (isDigit(code)) {\n        offset = findDecimalNumberEnd(source, offset + 1);\n        code = source.charCodeAt(offset);\n    }\n\n    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:\n    if (code === 0x002E && isDigit(source.charCodeAt(offset + 1))) {\n        // 4.1 Consume them.\n        // 4.2 Append them to repr.\n        offset += 2;\n\n        // 4.3 Set type to \"number\".\n        // TODO\n\n        // 4.4 While the next input code point is a digit, consume it and append it to repr.\n\n        offset = findDecimalNumberEnd(source, offset);\n    }\n\n    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)\n    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:\n    if (cmpChar(source, offset, 101 /* e */)) {\n        let sign = 0;\n        code = source.charCodeAt(offset + 1);\n\n        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...\n        if (code === 0x002D || code === 0x002B) {\n            sign = 1;\n            code = source.charCodeAt(offset + 2);\n        }\n\n        // ... followed by a digit\n        if (isDigit(code)) {\n            // 5.1 Consume them.\n            // 5.2 Append them to repr.\n\n            // 5.3 Set type to \"number\".\n            // TODO\n\n            // 5.4 While the next input code point is a digit, consume it and append it to repr.\n            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);\n        }\n    }\n\n    return offset;\n}\n\n// § 4.3.14. Consume the remnants of a bad url\n// ... its sole use is to consume enough of the input stream to reach a recovery point\n// where normal tokenizing can resume.\nexport function consumeBadUrlRemnants(source, offset) {\n    // Repeatedly consume the next input code point from the stream:\n    for (; offset < source.length; offset++) {\n        const code = source.charCodeAt(offset);\n\n        // U+0029 RIGHT PARENTHESIS ())\n        // EOF\n        if (code === 0x0029) {\n            // Return.\n            offset++;\n            break;\n        }\n\n        if (isValidEscape(code, getCharCode(source, offset + 1))) {\n            // Consume an escaped code point.\n            // Note: This allows an escaped right parenthesis (\"\\)\") to be encountered\n            // without ending the <bad-url-token>. This is otherwise identical to\n            // the \"anything else\" clause.\n            offset = consumeEscaped(source, offset);\n        }\n    }\n\n    return offset;\n}\n\n// § 4.3.7. Consume an escaped code point\n// Note: This algorithm assumes that escaped is valid without leading U+005C REVERSE SOLIDUS (\\)\nexport function decodeEscaped(escaped) {\n    // Single char escaped that's not a hex digit\n    if (escaped.length === 1 && !isHexDigit(escaped.charCodeAt(0))) {\n        return escaped[0];\n    }\n\n    // Interpret the hex digits as a hexadecimal number.\n    let code = parseInt(escaped, 16);\n\n    if (\n        (code === 0) ||                       // If this number is zero,\n        (code >= 0xD800 && code <= 0xDFFF) || // or is for a surrogate,\n        (code > 0x10FFFF)                     // or is greater than the maximum allowed code point\n    ) {\n        // ... return U+FFFD REPLACEMENT CHARACTER\n        code = 0xFFFD;\n    }\n\n    // Otherwise, return the code point with that value.\n    return String.fromCodePoint(code);\n}\n","export default [\n    'EOF-token',\n    'ident-token',\n    'function-token',\n    'at-keyword-token',\n    'hash-token',\n    'string-token',\n    'bad-string-token',\n    'url-token',\n    'bad-url-token',\n    'delim-token',\n    'number-token',\n    'percentage-token',\n    'dimension-token',\n    'whitespace-token',\n    'CDO-token',\n    'CDC-token',\n    'colon-token',\n    'semicolon-token',\n    'comma-token',\n    '[-token',\n    ']-token',\n    '(-token',\n    ')-token',\n    '{-token',\n    '}-token',\n    'comment-token'\n];\n","const MIN_SIZE = 16 * 1024;\n\nexport function adoptBuffer(buffer = null, size) {\n    if (buffer === null || buffer.length < size) {\n        return new Uint32Array(Math.max(size + 1024, MIN_SIZE));\n    }\n\n    return buffer;\n};\n","import { adoptBuffer } from './adopt-buffer.js';\nimport { isBOM } from './char-code-definitions.js';\n\nconst N = 10;\nconst F = 12;\nconst R = 13;\n\nfunction computeLinesAndColumns(host) {\n    const source = host.source;\n    const sourceLength = source.length;\n    const startOffset = source.length > 0 ? isBOM(source.charCodeAt(0)) : 0;\n    const lines = adoptBuffer(host.lines, sourceLength);\n    const columns = adoptBuffer(host.columns, sourceLength);\n    let line = host.startLine;\n    let column = host.startColumn;\n\n    for (let i = startOffset; i < sourceLength; i++) {\n        const code = source.charCodeAt(i);\n\n        lines[i] = line;\n        columns[i] = column++;\n\n        if (code === N || code === R || code === F) {\n            if (code === R && i + 1 < sourceLength && source.charCodeAt(i + 1) === N) {\n                i++;\n                lines[i] = line;\n                columns[i] = column;\n            }\n\n            line++;\n            column = 1;\n        }\n    }\n\n    lines[sourceLength] = line;\n    columns[sourceLength] = column;\n\n    host.lines = lines;\n    host.columns = columns;\n    host.computed = true;\n}\n\nexport class OffsetToLocation {\n    constructor(source, startOffset, startLine, startColumn) {\n        this.setSource(source, startOffset, startLine, startColumn);\n        this.lines = null;\n        this.columns = null;\n    }\n    setSource(source = '', startOffset = 0, startLine = 1, startColumn = 1) {\n        this.source = source;\n        this.startOffset = startOffset;\n        this.startLine = startLine;\n        this.startColumn = startColumn;\n        this.computed = false;\n    }\n    getLocation(offset, filename) {\n        if (!this.computed) {\n            computeLinesAndColumns(this);\n        }\n\n        return {\n            source: filename,\n            offset: this.startOffset + offset,\n            line: this.lines[offset],\n            column: this.columns[offset]\n        };\n    }\n    getLocationRange(start, end, filename) {\n        if (!this.computed) {\n            computeLinesAndColumns(this);\n        }\n\n        return {\n            source: filename,\n            start: {\n                offset: this.startOffset + start,\n                line: this.lines[start],\n                column: this.columns[start]\n            },\n            end: {\n                offset: this.startOffset + end,\n                line: this.lines[end],\n                column: this.columns[end]\n            }\n        };\n    }\n};\n","import { adoptBuffer } from './adopt-buffer.js';\nimport { cmpStr } from './utils.js';\nimport tokenNames from './names.js';\nimport {\n    WhiteSpace,\n    Comment,\n    Delim,\n    EOF,\n    Function as FunctionToken,\n    LeftParenthesis,\n    RightParenthesis,\n    LeftSquareBracket,\n    RightSquareBracket,\n    LeftCurlyBracket,\n    RightCurlyBracket\n} from './types.js';\n\nconst OFFSET_MASK = 0x00FFFFFF;\nconst TYPE_SHIFT = 24;\nconst balancePair = new Uint8Array(32); // 32b of memory ought to be enough for anyone (any number of tokens)\nbalancePair[FunctionToken] = RightParenthesis;\nbalancePair[LeftParenthesis] = RightParenthesis;\nbalancePair[LeftSquareBracket] = RightSquareBracket;\nbalancePair[LeftCurlyBracket] = RightCurlyBracket;\n\nfunction isBlockOpenerToken(tokenType) {\n    return balancePair[tokenType] !== 0;\n}\n\nexport class TokenStream {\n    constructor(source, tokenize) {\n        this.setSource(source, tokenize);\n    }\n    reset() {\n        this.eof = false;\n        this.tokenIndex = -1;\n        this.tokenType = 0;\n        this.tokenStart = this.firstCharOffset;\n        this.tokenEnd = this.firstCharOffset;\n    }\n    setSource(source = '', tokenize = () => {}) {\n        source = String(source || '');\n\n        const sourceLength = source.length;\n        const offsetAndType = adoptBuffer(this.offsetAndType, source.length + 1); // +1 because of eof-token\n        const balance = adoptBuffer(this.balance, source.length + 1);\n        let tokenCount = 0;\n        let firstCharOffset = -1;\n        let balanceCloseType = 0;\n        let balanceStart = source.length;\n\n        // capture buffers\n        this.offsetAndType = null;\n        this.balance = null;\n        balance.fill(0);\n\n        tokenize(source, (type, start, end) => {\n            const index = tokenCount++;\n\n            // type & offset\n            offsetAndType[index] = (type << TYPE_SHIFT) | end;\n\n            if (firstCharOffset === -1) {\n                firstCharOffset = start;\n            }\n\n            // balance\n            balance[index] = balanceStart;\n\n            if (type === balanceCloseType) {\n                const prevBalanceStart = balance[balanceStart];\n\n                // set reference to balance end for a block opener\n                balance[balanceStart] = index;\n\n                // pop state\n                balanceStart = prevBalanceStart;\n                balanceCloseType = balancePair[offsetAndType[prevBalanceStart] >> TYPE_SHIFT];\n            } else if (isBlockOpenerToken(type)) { // check for FunctionToken, <(-token>, <[-token> and <{-token>\n                // push state\n                balanceStart = index;\n                balanceCloseType = balancePair[type];\n            }\n        });\n\n        // finalize buffers\n        offsetAndType[tokenCount] = (EOF << TYPE_SHIFT) | sourceLength; // <EOF-token>\n        balance[tokenCount] = tokenCount; // prevents false positive balance match with any token\n\n        // reverse references from balance start to end\n        // tokens\n        //   token:   a ( [ b c ] d e ) {\n        //   index:   0 1 2 3 4 5 6 7 8 9\n        // before\n        //   balance: 0 8 5 2 2 2 1 1 1 0\n        //            - > > < < < < < < -\n        // after\n        //   balance: 9 8 5 5 5 2 8 8 1 9\n        //            > > > > > < > > < >\n        for (let i = 0; i < tokenCount; i++) {\n            const balanceStart = balance[i];\n\n            if (balanceStart <= i) {\n                const balanceEnd = balance[balanceStart];\n\n                if (balanceEnd !== i) {\n                    balance[i] = balanceEnd;\n                }\n            } else if (balanceStart > tokenCount) {\n                balance[i] = tokenCount;\n            }\n        }\n\n        // balance[0] = tokenCount;\n\n        this.source = source;\n        this.firstCharOffset = firstCharOffset === -1 ? 0 : firstCharOffset;\n        this.tokenCount = tokenCount;\n        this.offsetAndType = offsetAndType;\n        this.balance = balance;\n\n        this.reset();\n        this.next();\n    }\n\n    lookupType(offset) {\n        offset += this.tokenIndex;\n\n        if (offset < this.tokenCount) {\n            return this.offsetAndType[offset] >> TYPE_SHIFT;\n        }\n\n        return EOF;\n    }\n    lookupTypeNonSC(idx) {\n        for (let offset = this.tokenIndex; offset < this.tokenCount; offset++) {\n            const tokenType = this.offsetAndType[offset] >> TYPE_SHIFT;\n\n            if (tokenType !== WhiteSpace && tokenType !== Comment) {\n                if (idx-- === 0) {\n                    return tokenType;\n                }\n            }\n        }\n\n        return EOF;\n    }\n    lookupOffset(offset) {\n        offset += this.tokenIndex;\n\n        if (offset < this.tokenCount) {\n            return this.offsetAndType[offset - 1] & OFFSET_MASK;\n        }\n\n        return this.source.length;\n    }\n    lookupOffsetNonSC(idx) {\n        for (let offset = this.tokenIndex; offset < this.tokenCount; offset++) {\n            const tokenType = this.offsetAndType[offset] >> TYPE_SHIFT;\n\n            if (tokenType !== WhiteSpace && tokenType !== Comment) {\n                if (idx-- === 0) {\n                    return offset - this.tokenIndex;\n                }\n            }\n        }\n\n        return EOF;\n    }\n    lookupValue(offset, referenceStr) {\n        offset += this.tokenIndex;\n\n        if (offset < this.tokenCount) {\n            return cmpStr(\n                this.source,\n                this.offsetAndType[offset - 1] & OFFSET_MASK,\n                this.offsetAndType[offset] & OFFSET_MASK,\n                referenceStr\n            );\n        }\n\n        return false;\n    }\n    getTokenStart(tokenIndex) {\n        if (tokenIndex === this.tokenIndex) {\n            return this.tokenStart;\n        }\n\n        if (tokenIndex > 0) {\n            return tokenIndex < this.tokenCount\n                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK\n                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;\n        }\n\n        return this.firstCharOffset;\n    }\n    substrToCursor(start) {\n        return this.source.substring(start, this.tokenStart);\n    }\n\n    isBalanceEdge(pos) {\n        return this.balance[this.tokenIndex] < pos;\n        // return this.balance[this.balance[pos]] !== this.tokenIndex;\n    }\n    isDelim(code, offset) {\n        if (offset) {\n            return (\n                this.lookupType(offset) === Delim &&\n                this.source.charCodeAt(this.lookupOffset(offset)) === code\n            );\n        }\n\n        return (\n            this.tokenType === Delim &&\n            this.source.charCodeAt(this.tokenStart) === code\n        );\n    }\n\n    skip(tokenCount) {\n        let next = this.tokenIndex + tokenCount;\n\n        if (next < this.tokenCount) {\n            this.tokenIndex = next;\n            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;\n            next = this.offsetAndType[next];\n            this.tokenType = next >> TYPE_SHIFT;\n            this.tokenEnd = next & OFFSET_MASK;\n        } else {\n            this.tokenIndex = this.tokenCount;\n            this.next();\n        }\n    }\n    next() {\n        let next = this.tokenIndex + 1;\n\n        if (next < this.tokenCount) {\n            this.tokenIndex = next;\n            this.tokenStart = this.tokenEnd;\n            next = this.offsetAndType[next];\n            this.tokenType = next >> TYPE_SHIFT;\n            this.tokenEnd = next & OFFSET_MASK;\n        } else {\n            this.eof = true;\n            this.tokenIndex = this.tokenCount;\n            this.tokenType = EOF;\n            this.tokenStart = this.tokenEnd = this.source.length;\n        }\n    }\n    skipSC() {\n        while (this.tokenType === WhiteSpace || this.tokenType === Comment) {\n            this.next();\n        }\n    }\n    skipUntilBalanced(startToken, stopConsume) {\n        let cursor = startToken;\n        let balanceEnd = 0;\n        let offset = 0;\n\n        loop:\n        for (; cursor < this.tokenCount; cursor++) {\n            balanceEnd = this.balance[cursor];\n\n            // stop scanning on balance edge that points to offset before start token\n            if (balanceEnd < startToken) {\n                break loop;\n            }\n\n            offset = cursor > 0 ? this.offsetAndType[cursor - 1] & OFFSET_MASK : this.firstCharOffset;\n\n            // check stop condition\n            switch (stopConsume(this.source.charCodeAt(offset))) {\n                case 1: // just stop\n                    break loop;\n\n                case 2: // stop & included\n                    cursor++;\n                    break loop;\n\n                default:\n                    // fast forward to the end of balanced block for an open block tokens\n                    if (isBlockOpenerToken(this.offsetAndType[cursor] >> TYPE_SHIFT)) {\n                        cursor = balanceEnd;\n                    }\n            }\n        }\n\n        this.skip(cursor - this.tokenIndex);\n    }\n\n    forEachToken(fn) {\n        for (let i = 0, offset = this.firstCharOffset; i < this.tokenCount; i++) {\n            const start = offset;\n            const item = this.offsetAndType[i];\n            const end = item & OFFSET_MASK;\n            const type = item >> TYPE_SHIFT;\n\n            offset = end;\n\n            fn(type, start, end, i);\n        }\n    }\n    dump() {\n        const tokens = new Array(this.tokenCount);\n\n        this.forEachToken((type, start, end, index) => {\n            tokens[index] = {\n                idx: index,\n                type: tokenNames[type],\n                chunk: this.source.substring(start, end),\n                balance: this.balance[index]\n            };\n        });\n\n        return tokens;\n    }\n};\n","import * as TYPE from './types.js';\nimport {\n    isNewline,\n    isName,\n    isValidEscape,\n    isNumberStart,\n    isIdentifierStart,\n    isBOM,\n    charCodeCategory,\n    WhiteSpaceCategory,\n    DigitCategory,\n    NameStartCategory,\n    NonPrintableCategory\n} from './char-code-definitions.js';\nimport {\n    cmpStr,\n    getNewlineLength,\n    findWhiteSpaceEnd,\n    consumeEscaped,\n    consumeName,\n    consumeNumber,\n    consumeBadUrlRemnants\n} from './utils.js';\n\nexport function tokenize(source, onToken) {\n    function getCharCode(offset) {\n        return offset < sourceLength ? source.charCodeAt(offset) : 0;\n    }\n\n    // § 4.3.3. Consume a numeric token\n    function consumeNumericToken() {\n        // Consume a number and let number be the result.\n        offset = consumeNumber(source, offset);\n\n        // If the next 3 input code points would start an identifier, then:\n        if (isIdentifierStart(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {\n            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.\n            // Consume a name. Set the <dimension-token>’s unit to the returned value.\n            // Return the <dimension-token>.\n            type = TYPE.Dimension;\n            offset = consumeName(source, offset);\n            return;\n        }\n\n        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.\n        if (getCharCode(offset) === 0x0025) {\n            // Create a <percentage-token> with the same value as number, and return it.\n            type = TYPE.Percentage;\n            offset++;\n            return;\n        }\n\n        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.\n        type = TYPE.Number;\n    }\n\n    // § 4.3.4. Consume an ident-like token\n    function consumeIdentLikeToken() {\n        const nameStartOffset = offset;\n\n        // Consume a name, and let string be the result.\n        offset = consumeName(source, offset);\n\n        // If string’s value is an ASCII case-insensitive match for \"url\",\n        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.\n        if (cmpStr(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {\n            // While the next two input code points are whitespace, consume the next input code point.\n            offset = findWhiteSpaceEnd(source, offset + 1);\n\n            // If the next one or two input code points are U+0022 QUOTATION MARK (\"), U+0027 APOSTROPHE ('),\n            // or whitespace followed by U+0022 QUOTATION MARK (\") or U+0027 APOSTROPHE ('),\n            // then create a <function-token> with its value set to string and return it.\n            if (getCharCode(offset) === 0x0022 ||\n                getCharCode(offset) === 0x0027) {\n                type = TYPE.Function;\n                offset = nameStartOffset + 4;\n                return;\n            }\n\n            // Otherwise, consume a url token, and return it.\n            consumeUrlToken();\n            return;\n        }\n\n        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.\n        // Create a <function-token> with its value set to string and return it.\n        if (getCharCode(offset) === 0x0028) {\n            type = TYPE.Function;\n            offset++;\n            return;\n        }\n\n        // Otherwise, create an <ident-token> with its value set to string and return it.\n        type = TYPE.Ident;\n    }\n\n    // § 4.3.5. Consume a string token\n    function consumeStringToken(endingCodePoint) {\n        // This algorithm may be called with an ending code point, which denotes the code point\n        // that ends the string. If an ending code point is not specified,\n        // the current input code point is used.\n        if (!endingCodePoint) {\n            endingCodePoint = getCharCode(offset++);\n        }\n\n        // Initially create a <string-token> with its value set to the empty string.\n        type = TYPE.String;\n\n        // Repeatedly consume the next input code point from the stream:\n        for (; offset < source.length; offset++) {\n            const code = source.charCodeAt(offset);\n\n            switch (charCodeCategory(code)) {\n                // ending code point\n                case endingCodePoint:\n                    // Return the <string-token>.\n                    offset++;\n                    return;\n\n                    // EOF\n                    // case EofCategory:\n                    // This is a parse error. Return the <string-token>.\n                    // return;\n\n                // newline\n                case WhiteSpaceCategory:\n                    if (isNewline(code)) {\n                        // This is a parse error. Reconsume the current input code point,\n                        // create a <bad-string-token>, and return it.\n                        offset += getNewlineLength(source, offset, code);\n                        type = TYPE.BadString;\n                        return;\n                    }\n                    break;\n\n                // U+005C REVERSE SOLIDUS (\\)\n                case 0x005C:\n                    // If the next input code point is EOF, do nothing.\n                    if (offset === source.length - 1) {\n                        break;\n                    }\n\n                    const nextCode = getCharCode(offset + 1);\n\n                    // Otherwise, if the next input code point is a newline, consume it.\n                    if (isNewline(nextCode)) {\n                        offset += getNewlineLength(source, offset + 1, nextCode);\n                    } else if (isValidEscape(code, nextCode)) {\n                        // Otherwise, (the stream starts with a valid escape) consume\n                        // an escaped code point and append the returned code point to\n                        // the <string-token>’s value.\n                        offset = consumeEscaped(source, offset) - 1;\n                    }\n                    break;\n\n                // anything else\n                // Append the current input code point to the <string-token>’s value.\n            }\n        }\n    }\n\n    // § 4.3.6. Consume a url token\n    // Note: This algorithm assumes that the initial \"url(\" has already been consumed.\n    // This algorithm also assumes that it’s being called to consume an \"unquoted\" value, like url(foo).\n    // A quoted value, like url(\"foo\"), is parsed as a <function-token>. Consume an ident-like token\n    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.\n    function consumeUrlToken() {\n        // Initially create a <url-token> with its value set to the empty string.\n        type = TYPE.Url;\n\n        // Consume as much whitespace as possible.\n        offset = findWhiteSpaceEnd(source, offset);\n\n        // Repeatedly consume the next input code point from the stream:\n        for (; offset < source.length; offset++) {\n            const code = source.charCodeAt(offset);\n\n            switch (charCodeCategory(code)) {\n                // U+0029 RIGHT PARENTHESIS ())\n                case 0x0029:\n                    // Return the <url-token>.\n                    offset++;\n                    return;\n\n                    // EOF\n                    // case EofCategory:\n                    // This is a parse error. Return the <url-token>.\n                    // return;\n\n                // whitespace\n                case WhiteSpaceCategory:\n                    // Consume as much whitespace as possible.\n                    offset = findWhiteSpaceEnd(source, offset);\n\n                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,\n                    // consume it and return the <url-token>\n                    // (if EOF was encountered, this is a parse error);\n                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {\n                        if (offset < source.length) {\n                            offset++;\n                        }\n                        return;\n                    }\n\n                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,\n                    // and return it.\n                    offset = consumeBadUrlRemnants(source, offset);\n                    type = TYPE.BadUrl;\n                    return;\n\n                // U+0022 QUOTATION MARK (\")\n                // U+0027 APOSTROPHE (')\n                // U+0028 LEFT PARENTHESIS (()\n                // non-printable code point\n                case 0x0022:\n                case 0x0027:\n                case 0x0028:\n                case NonPrintableCategory:\n                    // This is a parse error. Consume the remnants of a bad url,\n                    // create a <bad-url-token>, and return it.\n                    offset = consumeBadUrlRemnants(source, offset);\n                    type = TYPE.BadUrl;\n                    return;\n\n                // U+005C REVERSE SOLIDUS (\\)\n                case 0x005C:\n                    // If the stream starts with a valid escape, consume an escaped code point and\n                    // append the returned code point to the <url-token>’s value.\n                    if (isValidEscape(code, getCharCode(offset + 1))) {\n                        offset = consumeEscaped(source, offset) - 1;\n                        break;\n                    }\n\n                    // Otherwise, this is a parse error. Consume the remnants of a bad url,\n                    // create a <bad-url-token>, and return it.\n                    offset = consumeBadUrlRemnants(source, offset);\n                    type = TYPE.BadUrl;\n                    return;\n\n                // anything else\n                // Append the current input code point to the <url-token>’s value.\n            }\n        }\n    }\n\n    // ensure source is a string\n    source = String(source || '');\n\n    const sourceLength = source.length;\n    let start = isBOM(getCharCode(0));\n    let offset = start;\n    let type;\n\n    // https://drafts.csswg.org/css-syntax-3/#consume-token\n    // § 4.3.1. Consume a token\n    while (offset < sourceLength) {\n        const code = source.charCodeAt(offset);\n\n        switch (charCodeCategory(code)) {\n            // whitespace\n            case WhiteSpaceCategory:\n                // Consume as much whitespace as possible. Return a <whitespace-token>.\n                type = TYPE.WhiteSpace;\n                offset = findWhiteSpaceEnd(source, offset + 1);\n                break;\n\n            // U+0022 QUOTATION MARK (\")\n            case 0x0022:\n                // Consume a string token and return it.\n                consumeStringToken();\n                break;\n\n            // U+0023 NUMBER SIGN (#)\n            case 0x0023:\n                // If the next input code point is a name code point or the next two input code points are a valid escape, then:\n                if (isName(getCharCode(offset + 1)) || isValidEscape(getCharCode(offset + 1), getCharCode(offset + 2))) {\n                    // Create a <hash-token>.\n                    type = TYPE.Hash;\n\n                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to \"id\".\n                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {\n                    //     // TODO: set id flag\n                    // }\n\n                    // Consume a name, and set the <hash-token>’s value to the returned string.\n                    offset = consumeName(source, offset + 1);\n\n                    // Return the <hash-token>.\n                } else {\n                    // Otherwise, return a <delim-token> with its value set to the current input code point.\n                    type = TYPE.Delim;\n                    offset++;\n                }\n\n                break;\n\n            // U+0027 APOSTROPHE (')\n            case 0x0027:\n                // Consume a string token and return it.\n                consumeStringToken();\n                break;\n\n            // U+0028 LEFT PARENTHESIS (()\n            case 0x0028:\n                // Return a <(-token>.\n                type = TYPE.LeftParenthesis;\n                offset++;\n                break;\n\n            // U+0029 RIGHT PARENTHESIS ())\n            case 0x0029:\n                // Return a <)-token>.\n                type = TYPE.RightParenthesis;\n                offset++;\n                break;\n\n            // U+002B PLUS SIGN (+)\n            case 0x002B:\n                // If the input stream starts with a number, ...\n                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {\n                    // ... reconsume the current input code point, consume a numeric token, and return it.\n                    consumeNumericToken();\n                } else {\n                    // Otherwise, return a <delim-token> with its value set to the current input code point.\n                    type = TYPE.Delim;\n                    offset++;\n                }\n                break;\n\n            // U+002C COMMA (,)\n            case 0x002C:\n                // Return a <comma-token>.\n                type = TYPE.Comma;\n                offset++;\n                break;\n\n            // U+002D HYPHEN-MINUS (-)\n            case 0x002D:\n                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.\n                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {\n                    consumeNumericToken();\n                } else {\n                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.\n                    if (getCharCode(offset + 1) === 0x002D &&\n                        getCharCode(offset + 2) === 0x003E) {\n                        type = TYPE.CDC;\n                        offset = offset + 3;\n                    } else {\n                        // Otherwise, if the input stream starts with an identifier, ...\n                        if (isIdentifierStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {\n                            // ... reconsume the current input code point, consume an ident-like token, and return it.\n                            consumeIdentLikeToken();\n                        } else {\n                            // Otherwise, return a <delim-token> with its value set to the current input code point.\n                            type = TYPE.Delim;\n                            offset++;\n                        }\n                    }\n                }\n                break;\n\n            // U+002E FULL STOP (.)\n            case 0x002E:\n                // If the input stream starts with a number, ...\n                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {\n                    // ... reconsume the current input code point, consume a numeric token, and return it.\n                    consumeNumericToken();\n                } else {\n                    // Otherwise, return a <delim-token> with its value set to the current input code point.\n                    type = TYPE.Delim;\n                    offset++;\n                }\n\n                break;\n\n            // U+002F SOLIDUS (/)\n            case 0x002F:\n                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),\n                if (getCharCode(offset + 1) === 0x002A) {\n                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)\n                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.\n                    type = TYPE.Comment;\n                    offset = source.indexOf('*/', offset + 2);\n                    offset = offset === -1 ? source.length : offset + 2;\n                } else {\n                    type = TYPE.Delim;\n                    offset++;\n                }\n                break;\n\n            // U+003A COLON (:)\n            case 0x003A:\n                // Return a <colon-token>.\n                type = TYPE.Colon;\n                offset++;\n                break;\n\n            // U+003B SEMICOLON (;)\n            case 0x003B:\n                // Return a <semicolon-token>.\n                type = TYPE.Semicolon;\n                offset++;\n                break;\n\n            // U+003C LESS-THAN SIGN (<)\n            case 0x003C:\n                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...\n                if (getCharCode(offset + 1) === 0x0021 &&\n                    getCharCode(offset + 2) === 0x002D &&\n                    getCharCode(offset + 3) === 0x002D) {\n                    // ... consume them and return a <CDO-token>.\n                    type = TYPE.CDO;\n                    offset = offset + 4;\n                } else {\n                    // Otherwise, return a <delim-token> with its value set to the current input code point.\n                    type = TYPE.Delim;\n                    offset++;\n                }\n\n                break;\n\n            // U+0040 COMMERCIAL AT (@)\n            case 0x0040:\n                // If the next 3 input code points would start an identifier, ...\n                if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {\n                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.\n                    type = TYPE.AtKeyword;\n                    offset = consumeName(source, offset + 1);\n                } else {\n                    // Otherwise, return a <delim-token> with its value set to the current input code point.\n                    type = TYPE.Delim;\n                    offset++;\n                }\n\n                break;\n\n            // U+005B LEFT SQUARE BRACKET ([)\n            case 0x005B:\n                // Return a <[-token>.\n                type = TYPE.LeftSquareBracket;\n                offset++;\n                break;\n\n            // U+005C REVERSE SOLIDUS (\\)\n            case 0x005C:\n                // If the input stream starts with a valid escape, ...\n                if (isValidEscape(code, getCharCode(offset + 1))) {\n                    // ... reconsume the current input code point, consume an ident-like token, and return it.\n                    consumeIdentLikeToken();\n                } else {\n                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.\n                    type = TYPE.Delim;\n                    offset++;\n                }\n                break;\n\n            // U+005D RIGHT SQUARE BRACKET (])\n            case 0x005D:\n                // Return a <]-token>.\n                type = TYPE.RightSquareBracket;\n                offset++;\n                break;\n\n            // U+007B LEFT CURLY BRACKET ({)\n            case 0x007B:\n                // Return a <{-token>.\n                type = TYPE.LeftCurlyBracket;\n                offset++;\n                break;\n\n            // U+007D RIGHT CURLY BRACKET (})\n            case 0x007D:\n                // Return a <}-token>.\n                type = TYPE.RightCurlyBracket;\n                offset++;\n                break;\n\n            // digit\n            case DigitCategory:\n                // Reconsume the current input code point, consume a numeric token, and return it.\n                consumeNumericToken();\n                break;\n\n            // name-start code point\n            case NameStartCategory:\n                // Reconsume the current input code point, consume an ident-like token, and return it.\n                consumeIdentLikeToken();\n                break;\n\n                // EOF\n                // case EofCategory:\n                // Return an <EOF-token>.\n                // break;\n\n            // anything else\n            default:\n                // Return a <delim-token> with its value set to the current input code point.\n                type = TYPE.Delim;\n                offset++;\n        }\n\n        // put token to stream\n        onToken(type, start, start = offset);\n    }\n}\n\nexport * from './types.js';\nexport * as tokenTypes from './types.js';\nexport { default as tokenNames } from './names.js';\nexport * from './char-code-definitions.js';\nexport * from './utils.js';\nexport * from './OffsetToLocation.js';\nexport * from './TokenStream.js';\n","import {\n    isDigit,\n    WhiteSpace,\n    Comment,\n    Ident,\n    Number,\n    Dimension\n} from '../../tokenizer/index.js';\n\nconst PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)\nconst HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)\nconst N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)\nconst DISALLOW_SIGN = true;\nconst ALLOW_SIGN = false;\n\nfunction checkInteger(offset, disallowSign) {\n    let pos = this.tokenStart + offset;\n    const code = this.charCodeAt(pos);\n\n    if (code === PLUSSIGN || code === HYPHENMINUS) {\n        if (disallowSign) {\n            this.error('Number sign is not allowed');\n        }\n        pos++;\n    }\n\n    for (; pos < this.tokenEnd; pos++) {\n        if (!isDigit(this.charCodeAt(pos))) {\n            this.error('Integer is expected', pos);\n        }\n    }\n}\n\nfunction checkTokenIsInteger(disallowSign) {\n    return checkInteger.call(this, 0, disallowSign);\n}\n\nfunction expectCharCode(offset, code) {\n    if (!this.cmpChar(this.tokenStart + offset, code)) {\n        let msg = '';\n\n        switch (code) {\n            case N:\n                msg = 'N is expected';\n                break;\n            case HYPHENMINUS:\n                msg = 'HyphenMinus is expected';\n                break;\n        }\n\n        this.error(msg, this.tokenStart + offset);\n    }\n}\n\n// ... <signed-integer>\n// ... ['+' | '-'] <signless-integer>\nfunction consumeB() {\n    let offset = 0;\n    let sign = 0;\n    let type = this.tokenType;\n\n    while (type === WhiteSpace || type === Comment) {\n        type = this.lookupType(++offset);\n    }\n\n    if (type !== Number) {\n        if (this.isDelim(PLUSSIGN, offset) ||\n            this.isDelim(HYPHENMINUS, offset)) {\n            sign = this.isDelim(PLUSSIGN, offset) ? PLUSSIGN : HYPHENMINUS;\n\n            do {\n                type = this.lookupType(++offset);\n            } while (type === WhiteSpace || type === Comment);\n\n            if (type !== Number) {\n                this.skip(offset);\n                checkTokenIsInteger.call(this, DISALLOW_SIGN);\n            }\n        } else {\n            return null;\n        }\n    }\n\n    if (offset > 0) {\n        this.skip(offset);\n    }\n\n    if (sign === 0) {\n        type = this.charCodeAt(this.tokenStart);\n        if (type !== PLUSSIGN && type !== HYPHENMINUS) {\n            this.error('Number sign is expected');\n        }\n    }\n\n    checkTokenIsInteger.call(this, sign !== 0);\n    return sign === HYPHENMINUS ? '-' + this.consume(Number) : this.consume(Number);\n}\n\n// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb\nexport const name = 'AnPlusB';\nexport const structure = {\n    a: [String, null],\n    b: [String, null]\n};\n\nexport function parse() {\n    /* eslint-disable brace-style*/\n    const start = this.tokenStart;\n    let a = null;\n    let b = null;\n\n    // <integer>\n    if (this.tokenType === Number) {\n        checkTokenIsInteger.call(this, ALLOW_SIGN);\n        b = this.consume(Number);\n    }\n\n    // -n\n    // -n <signed-integer>\n    // -n ['+' | '-'] <signless-integer>\n    // -n- <signless-integer>\n    // <dashndashdigit-ident>\n    else if (this.tokenType === Ident && this.cmpChar(this.tokenStart, HYPHENMINUS)) {\n        a = '-1';\n\n        expectCharCode.call(this, 1, N);\n\n        switch (this.tokenEnd - this.tokenStart) {\n            // -n\n            // -n <signed-integer>\n            // -n ['+' | '-'] <signless-integer>\n            case 2:\n                this.next();\n                b = consumeB.call(this);\n                break;\n\n            // -n- <signless-integer>\n            case 3:\n                expectCharCode.call(this, 2, HYPHENMINUS);\n\n                this.next();\n                this.skipSC();\n\n                checkTokenIsInteger.call(this, DISALLOW_SIGN);\n\n                b = '-' + this.consume(Number);\n                break;\n\n            // <dashndashdigit-ident>\n            default:\n                expectCharCode.call(this, 2, HYPHENMINUS);\n                checkInteger.call(this, 3, DISALLOW_SIGN);\n                this.next();\n\n                b = this.substrToCursor(start + 2);\n        }\n    }\n\n    // '+'? n\n    // '+'? n <signed-integer>\n    // '+'? n ['+' | '-'] <signless-integer>\n    // '+'? n- <signless-integer>\n    // '+'? <ndashdigit-ident>\n    else if (this.tokenType === Ident || (this.isDelim(PLUSSIGN) && this.lookupType(1) === Ident)) {\n        let sign = 0;\n        a = '1';\n\n        // just ignore a plus\n        if (this.isDelim(PLUSSIGN)) {\n            sign = 1;\n            this.next();\n        }\n\n        expectCharCode.call(this, 0, N);\n\n        switch (this.tokenEnd - this.tokenStart) {\n            // '+'? n\n            // '+'? n <signed-integer>\n            // '+'? n ['+' | '-'] <signless-integer>\n            case 1:\n                this.next();\n                b = consumeB.call(this);\n                break;\n\n            // '+'? n- <signless-integer>\n            case 2:\n                expectCharCode.call(this, 1, HYPHENMINUS);\n\n                this.next();\n                this.skipSC();\n\n                checkTokenIsInteger.call(this, DISALLOW_SIGN);\n\n                b = '-' + this.consume(Number);\n                break;\n\n            // '+'? <ndashdigit-ident>\n            default:\n                expectCharCode.call(this, 1, HYPHENMINUS);\n                checkInteger.call(this, 2, DISALLOW_SIGN);\n                this.next();\n\n                b = this.substrToCursor(start + sign + 1);\n        }\n    }\n\n    // <ndashdigit-dimension>\n    // <ndash-dimension> <signless-integer>\n    // <n-dimension>\n    // <n-dimension> <signed-integer>\n    // <n-dimension> ['+' | '-'] <signless-integer>\n    else if (this.tokenType === Dimension) {\n        const code = this.charCodeAt(this.tokenStart);\n        const sign = code === PLUSSIGN || code === HYPHENMINUS;\n        let i = this.tokenStart + sign;\n\n        for (; i < this.tokenEnd; i++) {\n            if (!isDigit(this.charCodeAt(i))) {\n                break;\n            }\n        }\n\n        if (i === this.tokenStart + sign) {\n            this.error('Integer is expected', this.tokenStart + sign);\n        }\n\n        expectCharCode.call(this, i - this.tokenStart, N);\n        a = this.substring(start, i);\n\n        // <n-dimension>\n        // <n-dimension> <signed-integer>\n        // <n-dimension> ['+' | '-'] <signless-integer>\n        if (i + 1 === this.tokenEnd) {\n            this.next();\n            b = consumeB.call(this);\n        } else {\n            expectCharCode.call(this, i - this.tokenStart + 1, HYPHENMINUS);\n\n            // <ndash-dimension> <signless-integer>\n            if (i + 2 === this.tokenEnd) {\n                this.next();\n                this.skipSC();\n                checkTokenIsInteger.call(this, DISALLOW_SIGN);\n                b = '-' + this.consume(Number);\n            }\n            // <ndashdigit-dimension>\n            else {\n                checkInteger.call(this, i - this.tokenStart + 2, DISALLOW_SIGN);\n                this.next();\n                b = this.substrToCursor(i + 1);\n            }\n        }\n    } else {\n        this.error();\n    }\n\n    if (a !== null && a.charCodeAt(0) === PLUSSIGN) {\n        a = a.substr(1);\n    }\n\n    if (b !== null && b.charCodeAt(0) === PLUSSIGN) {\n        b = b.substr(1);\n    }\n\n    return {\n        type: 'AnPlusB',\n        loc: this.getLocation(start, this.tokenStart),\n        a,\n        b\n    };\n}\n\nexport function generate(node) {\n    if (node.a) {\n        const a =\n            node.a === '+1' && 'n' ||\n            node.a ===  '1' && 'n' ||\n            node.a === '-1' && '-n' ||\n            node.a + 'n';\n\n        if (node.b) {\n            const b = node.b[0] === '-' || node.b[0] === '+'\n                ? node.b\n                : '+' + node.b;\n            this.tokenize(a + b);\n        } else {\n            this.tokenize(a);\n        }\n    } else {\n        this.tokenize(node.b);\n    }\n}\n","import {\n    AtKeyword,\n    Semicolon,\n    LeftCurlyBracket,\n    RightCurlyBracket\n} from '../../tokenizer/index.js';\n\nfunction consumeRaw() {\n    return this.Raw(this.consumeUntilLeftCurlyBracketOrSemicolon, true);\n}\n\nfunction isDeclarationBlockAtrule() {\n    for (let offset = 1, type; type = this.lookupType(offset); offset++) {\n        if (type === RightCurlyBracket) {\n            return true;\n        }\n\n        if (type === LeftCurlyBracket ||\n            type === AtKeyword) {\n            return false;\n        }\n    }\n\n    return false;\n}\n\n\nexport const name = 'Atrule';\nexport const walkContext = 'atrule';\nexport const structure = {\n    name: String,\n    prelude: ['AtrulePrelude', 'Raw', null],\n    block: ['Block', null]\n};\n\nexport function parse(isDeclaration = false) {\n    const start = this.tokenStart;\n    let name;\n    let nameLowerCase;\n    let prelude = null;\n    let block = null;\n\n    this.eat(AtKeyword);\n\n    name = this.substrToCursor(start + 1);\n    nameLowerCase = name.toLowerCase();\n    this.skipSC();\n\n    // parse prelude\n    if (this.eof === false &&\n        this.tokenType !== LeftCurlyBracket &&\n        this.tokenType !== Semicolon) {\n        if (this.parseAtrulePrelude) {\n            prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name, isDeclaration), consumeRaw);\n        } else {\n            prelude = consumeRaw.call(this, this.tokenIndex);\n        }\n\n        this.skipSC();\n    }\n\n    switch (this.tokenType) {\n        case Semicolon:\n            this.next();\n            break;\n\n        case LeftCurlyBracket:\n            if (hasOwnProperty.call(this.atrule, nameLowerCase) &&\n                typeof this.atrule[nameLowerCase].block === 'function') {\n                block = this.atrule[nameLowerCase].block.call(this, isDeclaration);\n            } else {\n                // TODO: should consume block content as Raw?\n                block = this.Block(isDeclarationBlockAtrule.call(this));\n            }\n\n            break;\n    }\n\n    return {\n        type: 'Atrule',\n        loc: this.getLocation(start, this.tokenStart),\n        name,\n        prelude,\n        block\n    };\n}\n\nexport function generate(node) {\n    this.token(AtKeyword, '@' + node.name);\n\n    if (node.prelude !== null) {\n        this.node(node.prelude);\n    }\n\n    if (node.block) {\n        this.node(node.block);\n    } else {\n        this.token(Semicolon, ';');\n    }\n}\n","import {\n    Semicolon,\n    LeftCurlyBracket\n} from '../../tokenizer/index.js';\n\nexport const name = 'AtrulePrelude';\nexport const walkContext = 'atrulePrelude';\nexport const structure = {\n    children: [[]]\n};\n\nexport function parse(name) {\n    let children = null;\n\n    if (name !== null) {\n        name = name.toLowerCase();\n    }\n\n    this.skipSC();\n\n    if (hasOwnProperty.call(this.atrule, name) &&\n        typeof this.atrule[name].prelude === 'function') {\n        // custom consumer\n        children = this.atrule[name].prelude.call(this);\n    } else {\n        // default consumer\n        children = this.readSequence(this.scope.AtrulePrelude);\n    }\n\n    this.skipSC();\n\n    if (this.eof !== true &&\n        this.tokenType !== LeftCurlyBracket &&\n        this.tokenType !== Semicolon) {\n        this.error('Semicolon or block is expected');\n    }\n\n    return {\n        type: 'AtrulePrelude',\n        loc: this.getLocationFromList(children),\n        children\n    };\n}\n\nexport function generate(node) {\n    this.children(node);\n}\n","import {\n    Ident,\n    String as StringToken,\n    Delim,\n    LeftSquareBracket,\n    RightSquareBracket\n} from '../../tokenizer/index.js';\n\nconst DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)\nconst ASTERISK = 0x002A;         // U+002A ASTERISK (*)\nconst EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)\nconst CIRCUMFLEXACCENT = 0x005E; // U+005E (^)\nconst VERTICALLINE = 0x007C;     // U+007C VERTICAL LINE (|)\nconst TILDE = 0x007E;            // U+007E TILDE (~)\n\nfunction getAttributeName() {\n    if (this.eof) {\n        this.error('Unexpected end of input');\n    }\n\n    const start = this.tokenStart;\n    let expectIdent = false;\n\n    if (this.isDelim(ASTERISK)) {\n        expectIdent = true;\n        this.next();\n    } else if (!this.isDelim(VERTICALLINE)) {\n        this.eat(Ident);\n    }\n\n    if (this.isDelim(VERTICALLINE)) {\n        if (this.charCodeAt(this.tokenStart + 1) !== EQUALSSIGN) {\n            this.next();\n            this.eat(Ident);\n        } else if (expectIdent) {\n            this.error('Identifier is expected', this.tokenEnd);\n        }\n    } else if (expectIdent) {\n        this.error('Vertical line is expected');\n    }\n\n    return {\n        type: 'Identifier',\n        loc: this.getLocation(start, this.tokenStart),\n        name: this.substrToCursor(start)\n    };\n}\n\nfunction getOperator() {\n    const start = this.tokenStart;\n    const code = this.charCodeAt(start);\n\n    if (code !== EQUALSSIGN &&        // =\n        code !== TILDE &&             // ~=\n        code !== CIRCUMFLEXACCENT &&  // ^=\n        code !== DOLLARSIGN &&        // $=\n        code !== ASTERISK &&          // *=\n        code !== VERTICALLINE         // |=\n    ) {\n        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');\n    }\n\n    this.next();\n\n    if (code !== EQUALSSIGN) {\n        if (!this.isDelim(EQUALSSIGN)) {\n            this.error('Equal sign is expected');\n        }\n\n        this.next();\n    }\n\n    return this.substrToCursor(start);\n}\n\n// '[' <wq-name> ']'\n// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'\nexport const name = 'AttributeSelector';\nexport const structure = {\n    name: 'Identifier',\n    matcher: [String, null],\n    value: ['String', 'Identifier', null],\n    flags: [String, null]\n};\n\nexport function parse() {\n    const start = this.tokenStart;\n    let name;\n    let matcher = null;\n    let value = null;\n    let flags = null;\n\n    this.eat(LeftSquareBracket);\n    this.skipSC();\n\n    name = getAttributeName.call(this);\n    this.skipSC();\n\n    if (this.tokenType !== RightSquareBracket) {\n        // avoid case `[name i]`\n        if (this.tokenType !== Ident) {\n            matcher = getOperator.call(this);\n\n            this.skipSC();\n\n            value = this.tokenType === StringToken\n                ? this.String()\n                : this.Identifier();\n\n            this.skipSC();\n        }\n\n        // attribute flags\n        if (this.tokenType === Ident) {\n            flags = this.consume(Ident);\n\n            this.skipSC();\n        }\n    }\n\n    this.eat(RightSquareBracket);\n\n    return {\n        type: 'AttributeSelector',\n        loc: this.getLocation(start, this.tokenStart),\n        name,\n        matcher,\n        value,\n        flags\n    };\n}\n\nexport function generate(node) {\n    this.token(Delim, '[');\n    this.node(node.name);\n\n    if (node.matcher !== null) {\n        this.tokenize(node.matcher);\n        this.node(node.value);\n    }\n\n    if (node.flags !== null) {\n        this.token(Ident, node.flags);\n    }\n\n    this.token(Delim, ']');\n}\n","import {\n    WhiteSpace,\n    Comment,\n    Semicolon,\n    AtKeyword,\n    LeftCurlyBracket,\n    RightCurlyBracket\n} from '../../tokenizer/index.js';\n\nconst AMPERSAND = 0x0026;       // U+0026 AMPERSAND (&)\n\nfunction consumeRaw() {\n    return this.Raw(null, true);\n}\nfunction consumeRule() {\n    return this.parseWithFallback(this.Rule, consumeRaw);\n}\nfunction consumeRawDeclaration() {\n    return this.Raw(this.consumeUntilSemicolonIncluded, true);\n}\nfunction consumeDeclaration() {\n    if (this.tokenType === Semicolon) {\n        return consumeRawDeclaration.call(this, this.tokenIndex);\n    }\n\n    const node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);\n\n    if (this.tokenType === Semicolon) {\n        this.next();\n    }\n\n    return node;\n}\n\nexport const name = 'Block';\nexport const walkContext = 'block';\nexport const structure = {\n    children: [[\n        'Atrule',\n        'Rule',\n        'Declaration'\n    ]]\n};\n\nexport function parse(isStyleBlock) {\n    const consumer = isStyleBlock ? consumeDeclaration : consumeRule;\n    const start = this.tokenStart;\n    let children = this.createList();\n\n    this.eat(LeftCurlyBracket);\n\n    scan:\n    while (!this.eof) {\n        switch (this.tokenType) {\n            case RightCurlyBracket:\n                break scan;\n\n            case WhiteSpace:\n            case Comment:\n                this.next();\n                break;\n\n            case AtKeyword:\n                children.push(this.parseWithFallback(this.Atrule.bind(this, isStyleBlock), consumeRaw));\n                break;\n\n            default:\n                if (isStyleBlock && this.isDelim(AMPERSAND))  {\n                    children.push(consumeRule.call(this));\n                } else {\n                    children.push(consumer.call(this));\n                }\n        }\n    }\n\n    if (!this.eof) {\n        this.eat(RightCurlyBracket);\n    }\n\n    return {\n        type: 'Block',\n        loc: this.getLocation(start, this.tokenStart),\n        children\n    };\n}\n\nexport function generate(node) {\n    this.token(LeftCurlyBracket, '{');\n    this.children(node, prev => {\n        if (prev.type === 'Declaration') {\n            this.token(Semicolon, ';');\n        }\n    });\n    this.token(RightCurlyBracket, '}');\n}\n","import {\n    Delim,\n    LeftSquareBracket,\n    RightSquareBracket\n} from '../../tokenizer/index.js';\n\nexport const name = 'Brackets';\nexport const structure = {\n    children: [[]]\n};\n\nexport function parse(readSequence, recognizer) {\n    const start = this.tokenStart;\n    let children = null;\n\n    this.eat(LeftSquareBracket);\n\n    children = readSequence.call(this, recognizer);\n\n    if (!this.eof) {\n        this.eat(RightSquareBracket);\n    }\n\n    return {\n        type: 'Brackets',\n        loc: this.getLocation(start, this.tokenStart),\n        children\n    };\n}\n\nexport function generate(node) {\n    this.token(Delim, '[');\n    this.children(node);\n    this.token(Delim, ']');\n}\n","import { CDC } from '../../tokenizer/index.js';\n\nexport const name = 'CDC';\nexport const structure = [];\n\nexport function parse() {\n    const start = this.tokenStart;\n\n    this.eat(CDC); // -->\n\n    return {\n        type: 'CDC',\n        loc: this.getLocation(start, this.tokenStart)\n    };\n}\n\nexport function generate() {\n    this.token(CDC, '-->');\n}\n","import { CDO } from '../../tokenizer/index.js';\n\nexport const name = 'CDO';\nexport const structure = [];\n\nexport function parse() {\n    const start = this.tokenStart;\n\n    this.eat(CDO); // <!--\n\n    return {\n        type: 'CDO',\n        loc: this.getLocation(start, this.tokenStart)\n    };\n}\n\nexport function generate() {\n    this.token(CDO, '<!--');\n}\n","import { Delim, Ident } from '../../tokenizer/index.js';\n\nconst FULLSTOP = 0x002E; // U+002E FULL STOP (.)\n\n// '.' ident\nexport const name = 'ClassSelector';\nexport const structure = {\n    name: String\n};\n\nexport function parse() {\n    this.eatDelim(FULLSTOP);\n\n    return {\n        type: 'ClassSelector',\n        loc: this.getLocation(this.tokenStart - 1, this.tokenEnd),\n        name: this.consume(Ident)\n    };\n}\n\nexport function generate(node) {\n    this.token(Delim, '.');\n    this.token(Ident, node.name);\n}\n","import { WhiteSpace, Delim } from '../../tokenizer/index.js';\n\nconst PLUSSIGN = 0x002B;        // U+002B PLUS SIGN (+)\nconst SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)\nconst GREATERTHANSIGN = 0x003E; // U+003E GREATER-THAN SIGN (>)\nconst TILDE = 0x007E;           // U+007E TILDE (~)\n\nexport const name = 'Combinator';\nexport const structure = {\n    name: String\n};\n\n// + | > | ~ | /deep/\nexport function parse() {\n    const start = this.tokenStart;\n    let name;\n\n    switch (this.tokenType) {\n        case WhiteSpace:\n            name = ' ';\n            break;\n\n        case Delim:\n            switch (this.charCodeAt(this.tokenStart)) {\n                case GREATERTHANSIGN:\n                case PLUSSIGN:\n                case TILDE:\n                    this.next();\n                    break;\n\n                case SOLIDUS:\n                    this.next();\n                    this.eatIdent('deep');\n                    this.eatDelim(SOLIDUS);\n                    break;\n\n                default:\n                    this.error('Combinator is expected');\n            }\n\n            name = this.substrToCursor(start);\n            break;\n    }\n\n    return {\n        type: 'Combinator',\n        loc: this.getLocation(start, this.tokenStart),\n        name\n    };\n}\n\nexport function generate(node) {\n    this.tokenize(node.name);\n}\n","import { Comment } from '../../tokenizer/index.js';\n\nconst ASTERISK = 0x002A;        // U+002A ASTERISK (*)\nconst SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)\n\n\nexport const name = 'Comment';\nexport const structure = {\n    value: String\n};\n\nexport function parse() {\n    const start = this.tokenStart;\n    let end = this.tokenEnd;\n\n    this.eat(Comment);\n\n    if ((end - start + 2) >= 2 &&\n        this.charCodeAt(end - 2) === ASTERISK &&\n        this.charCodeAt(end - 1) === SOLIDUS) {\n        end -= 2;\n    }\n\n    return {\n        type: 'Comment',\n        loc: this.getLocation(start, this.tokenStart),\n        value: this.substring(start + 2, end)\n    };\n}\n\nexport function generate(node) {\n    this.token(Comment, '/*' + node.value + '*/');\n}\n","import {\n    WhiteSpace,\n    Comment,\n    Ident,\n    LeftParenthesis,\n    RightParenthesis,\n    Function as FunctionToken,\n    Colon,\n    EOF\n} from '../../tokenizer/index.js';\n\nconst likelyFeatureToken = new Set([Colon, RightParenthesis, EOF]);\n\nexport const name = 'Condition';\nexport const structure = {\n    kind: String,\n    children: [[\n        'Identifier',\n        'Feature',\n        'FeatureFunction',\n        'FeatureRange',\n        'SupportsDeclaration'\n    ]]\n};\n\nfunction featureOrRange(kind) {\n    if (this.lookupTypeNonSC(1) === Ident &&\n        likelyFeatureToken.has(this.lookupTypeNonSC(2))) {\n        return this.Feature(kind);\n    }\n\n    return this.FeatureRange(kind);\n}\n\nconst parentheses = {\n    media: featureOrRange,\n    container: featureOrRange,\n    supports() {\n        return this.SupportsDeclaration();\n    }\n};\n\nexport function parse(kind = 'media') {\n    const children = this.createList();\n\n    scan: while (!this.eof) {\n        switch (this.tokenType) {\n            case Comment:\n            case WhiteSpace:\n                this.next();\n                continue;\n\n            case Ident:\n                children.push(this.Identifier());\n                break;\n\n            case LeftParenthesis: {\n                let term = this.parseWithFallback(\n                    () => parentheses[kind].call(this, kind),\n                    () => null\n                );\n\n                if (!term) {\n                    term = this.parseWithFallback(\n                        () => {\n                            this.eat(LeftParenthesis);\n                            const res = this.Condition(kind);\n                            this.eat(RightParenthesis);\n                            return res;\n                        },\n                        () => {\n                            return this.GeneralEnclosed(kind);\n                        }\n                    );\n                }\n\n                children.push(term);\n                break;\n            }\n\n            case FunctionToken: {\n                let term = this.parseWithFallback(\n                    () => this.FeatureFunction(kind),\n                    () => null\n                );\n\n                if (!term) {\n                    term = this.GeneralEnclosed(kind);\n                }\n\n                children.push(term);\n                break;\n            }\n\n            default:\n                break scan;\n        }\n    }\n\n    if (children.isEmpty) {\n        this.error('Condition is expected');\n    }\n\n    return {\n        type: 'Condition',\n        loc: this.getLocationFromList(children),\n        kind,\n        children\n    };\n}\n\nexport function generate(node) {\n    node.children.forEach(child => {\n        if (child.type === 'Condition') {\n            this.token(LeftParenthesis, '(');\n            this.node(child);\n            this.token(RightParenthesis, ')');\n        } else {\n            this.node(child);\n        }\n    });\n}\n\n","const keywords = new Map();\nconst properties = new Map();\nconst HYPHENMINUS = 45; // '-'.charCodeAt()\n\nexport const keyword = getKeywordDescriptor;\nexport const property = getPropertyDescriptor;\nexport const vendorPrefix = getVendorPrefix;\nexport function isCustomProperty(str, offset) {\n    offset = offset || 0;\n\n    return str.length - offset >= 2 &&\n           str.charCodeAt(offset) === HYPHENMINUS &&\n           str.charCodeAt(offset + 1) === HYPHENMINUS;\n}\n\nfunction getVendorPrefix(str, offset) {\n    offset = offset || 0;\n\n    // verdor prefix should be at least 3 chars length\n    if (str.length - offset >= 3) {\n        // vendor prefix starts with hyper minus following non-hyper minus\n        if (str.charCodeAt(offset) === HYPHENMINUS &&\n            str.charCodeAt(offset + 1) !== HYPHENMINUS) {\n            // vendor prefix should contain a hyper minus at the ending\n            const secondDashIndex = str.indexOf('-', offset + 2);\n\n            if (secondDashIndex !== -1) {\n                return str.substring(offset, secondDashIndex + 1);\n            }\n        }\n    }\n\n    return '';\n}\n\nfunction getKeywordDescriptor(keyword) {\n    if (keywords.has(keyword)) {\n        return keywords.get(keyword);\n    }\n\n    const name = keyword.toLowerCase();\n    let descriptor = keywords.get(name);\n\n    if (descriptor === undefined) {\n        const custom = isCustomProperty(name, 0);\n        const vendor = !custom ? getVendorPrefix(name, 0) : '';\n        descriptor = Object.freeze({\n            basename: name.substr(vendor.length),\n            name,\n            prefix: vendor,\n            vendor,\n            custom\n        });\n    }\n\n    keywords.set(keyword, descriptor);\n\n    return descriptor;\n}\n\nfunction getPropertyDescriptor(property) {\n    if (properties.has(property)) {\n        return properties.get(property);\n    }\n\n    let name = property;\n    let hack = property[0];\n\n    if (hack === '/') {\n        hack = property[1] === '/' ? '//' : '/';\n    } else if (hack !== '_' &&\n               hack !== '*' &&\n               hack !== '$' &&\n               hack !== '#' &&\n               hack !== '+' &&\n               hack !== '&') {\n        hack = '';\n    }\n\n    const custom = isCustomProperty(name, hack.length);\n\n    // re-use result when possible (the same as for lower case)\n    if (!custom) {\n        name = name.toLowerCase();\n        if (properties.has(name)) {\n            const descriptor = properties.get(name);\n            properties.set(property, descriptor);\n            return descriptor;\n        }\n    }\n\n    const vendor = !custom ? getVendorPrefix(name, hack.length) : '';\n    const prefix = name.substr(0, hack.length + vendor.length);\n    const descriptor = Object.freeze({\n        basename: name.substr(prefix.length),\n        name: name.substr(hack.length),\n        hack,\n        vendor,\n        prefix,\n        custom\n    });\n\n    properties.set(property, descriptor);\n\n    return descriptor;\n}\n","import { isCustomProperty } from '../../utils/names.js';\nimport {\n    Ident,\n    Hash,\n    Colon,\n    Semicolon,\n    Delim,\n    WhiteSpace\n} from '../../tokenizer/index.js';\n\nconst EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)\nconst NUMBERSIGN = 0x0023;      // U+0023 NUMBER SIGN (#)\nconst DOLLARSIGN = 0x0024;      // U+0024 DOLLAR SIGN ($)\nconst AMPERSAND = 0x0026;       // U+0026 AMPERSAND (&)\nconst ASTERISK = 0x002A;        // U+002A ASTERISK (*)\nconst PLUSSIGN = 0x002B;        // U+002B PLUS SIGN (+)\nconst SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)\n\nfunction consumeValueRaw() {\n    return this.Raw(this.consumeUntilExclamationMarkOrSemicolon, true);\n}\n\nfunction consumeCustomPropertyRaw() {\n    return this.Raw(this.consumeUntilExclamationMarkOrSemicolon, false);\n}\n\nfunction consumeValue() {\n    const startValueToken = this.tokenIndex;\n    const value = this.Value();\n\n    if (value.type !== 'Raw' &&\n        this.eof === false &&\n        this.tokenType !== Semicolon &&\n        this.isDelim(EXCLAMATIONMARK) === false &&\n        this.isBalanceEdge(startValueToken) === false) {\n        this.error();\n    }\n\n    return value;\n}\n\nexport const name = 'Declaration';\nexport const walkContext = 'declaration';\nexport const structure = {\n    important: [Boolean, String],\n    property: String,\n    value: ['Value', 'Raw']\n};\n\nexport function parse() {\n    const start = this.tokenStart;\n    const startToken = this.tokenIndex;\n    const property = readProperty.call(this);\n    const customProperty = isCustomProperty(property);\n    const parseValue = customProperty ? this.parseCustomProperty : this.parseValue;\n    const consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;\n    let important = false;\n    let value;\n\n    this.skipSC();\n    this.eat(Colon);\n\n    const valueStart = this.tokenIndex;\n\n    if (!customProperty) {\n        this.skipSC();\n    }\n\n    if (parseValue) {\n        value = this.parseWithFallback(consumeValue, consumeRaw);\n    } else {\n        value = consumeRaw.call(this, this.tokenIndex);\n    }\n\n    if (customProperty && value.type === 'Value' && value.children.isEmpty) {\n        for (let offset = valueStart - this.tokenIndex; offset <= 0; offset++) {\n            if (this.lookupType(offset) === WhiteSpace) {\n                value.children.appendData({\n                    type: 'WhiteSpace',\n                    loc: null,\n                    value: ' '\n                });\n                break;\n            }\n        }\n    }\n\n    if (this.isDelim(EXCLAMATIONMARK)) {\n        important = getImportant.call(this);\n        this.skipSC();\n    }\n\n    // Do not include semicolon to range per spec\n    // https://drafts.csswg.org/css-syntax/#declaration-diagram\n\n    if (this.eof === false &&\n        this.tokenType !== Semicolon &&\n        this.isBalanceEdge(startToken) === false) {\n        this.error();\n    }\n\n    return {\n        type: 'Declaration',\n        loc: this.getLocation(start, this.tokenStart),\n        important,\n        property,\n        value\n    };\n}\n\nexport function generate(node) {\n    this.token(Ident, node.property);\n    this.token(Colon, ':');\n    this.node(node.value);\n\n    if (node.important) {\n        this.token(Delim, '!');\n        this.token(Ident, node.important === true ? 'important' : node.important);\n    }\n}\n\nfunction readProperty() {\n    const start = this.tokenStart;\n\n    // hacks\n    if (this.tokenType === Delim) {\n        switch (this.charCodeAt(this.tokenStart)) {\n            case ASTERISK:\n            case DOLLARSIGN:\n            case PLUSSIGN:\n            case NUMBERSIGN:\n            case AMPERSAND:\n                this.next();\n                break;\n\n            // TODO: not sure we should support this hack\n            case SOLIDUS:\n                this.next();\n                if (this.isDelim(SOLIDUS)) {\n                    this.next();\n                }\n                break;\n        }\n    }\n\n    if (this.tokenType === Hash) {\n        this.eat(Hash);\n    } else {\n        this.eat(Ident);\n    }\n\n    return this.substrToCursor(start);\n}\n\n// ! ws* important\nfunction getImportant() {\n    this.eat(Delim);\n    this.skipSC();\n\n    const important = this.consume(Ident);\n\n    // store original value in case it differ from `important`\n    // for better original source restoring and hacks like `!ie` support\n    return important === 'important' ? true : important;\n}\n","import {\n    WhiteSpace,\n    Comment,\n    Semicolon,\n    AtKeyword\n} from '../../tokenizer/index.js';\n\nconst AMPERSAND = 0x0026;       // U+0026 AMPERSAND (&)\n\nfunction consumeRaw() {\n    return this.Raw(this.consumeUntilSemicolonIncluded, true);\n}\n\nexport const name = 'DeclarationList';\nexport const structure = {\n    children: [[\n        'Declaration',\n        'Atrule',\n        'Rule'\n    ]]\n};\n\nexport function parse() {\n    const children = this.createList();\n\n    scan:\n    while (!this.eof) {\n        switch (this.tokenType) {\n            case WhiteSpace:\n            case Comment:\n            case Semicolon:\n                this.next();\n                break;\n\n            case AtKeyword:\n                children.push(this.parseWithFallback(this.Atrule.bind(this, true), consumeRaw));\n                break;\n\n            default:\n                if (this.isDelim(AMPERSAND))  {\n                    children.push(this.parseWithFallback(this.Rule, consumeRaw));\n                } else {\n                    children.push(this.parseWithFallback(this.Declaration, consumeRaw));\n                }\n        }\n    }\n\n    return {\n        type: 'DeclarationList',\n        loc: this.getLocationFromList(children),\n        children\n    };\n}\n\nexport function generate(node) {\n    this.children(node, prev => {\n        if (prev.type === 'Declaration') {\n            this.token(Semicolon, ';');\n        }\n    });\n}\n\n","import { Dimension } from '../../tokenizer/index.js';\n\nexport const name = 'Dimension';\nexport const structure = {\n    value: String,\n    unit: String\n};\n\nexport function parse() {\n    const start = this.tokenStart;\n    const value = this.consumeNumber(Dimension);\n\n    return {\n        type: 'Dimension',\n        loc: this.getLocation(start, this.tokenStart),\n        value,\n        unit: this.substring(start + value.length, this.tokenStart)\n    };\n}\n\nexport function generate(node) {\n    this.token(Dimension, node.value + node.unit);\n}\n","import {\n    Ident,\n    Number,\n    Dimension,\n    Function as FunctionToken,\n    LeftParenthesis,\n    RightParenthesis,\n    Colon,\n    Delim\n} from '../../tokenizer/index.js';\n\nconst SOLIDUS = 0x002F;  // U+002F SOLIDUS (/)\n\nexport const name = 'Feature';\nexport const structure = {\n    kind: String,\n    name: String,\n    value: ['Identifier', 'Number', 'Dimension', 'Ratio', 'Function', null]\n};\n\nexport function parse(kind) {\n    const start = this.tokenStart;\n    let name;\n    let value = null;\n\n    this.eat(LeftParenthesis);\n    this.skipSC();\n\n    name = this.consume(Ident);\n    this.skipSC();\n\n    if (this.tokenType !== RightParenthesis) {\n        this.eat(Colon);\n        this.skipSC();\n\n        switch (this.tokenType) {\n            case Number:\n                if (this.lookupNonWSType(1) === Delim) {\n                    value = this.Ratio();\n                } else {\n                    value = this.Number();\n                }\n\n                break;\n\n            case Dimension:\n                value = this.Dimension();\n                break;\n\n            case Ident:\n                value = this.Identifier();\n                break;\n\n            case FunctionToken:\n                value = this.parseWithFallback(\n                    () => {\n                        const res = this.Function(this.readSequence, this.scope.Value);\n\n                        this.skipSC();\n\n                        if (this.isDelim(SOLIDUS)) {\n                            this.error();\n                        }\n\n                        return res;\n                    },\n                    () => {\n                        return this.Ratio();\n                    }\n                );\n                break;\n\n            default:\n                this.error('Number, dimension, ratio or identifier is expected');\n        }\n\n        this.skipSC();\n    }\n\n    if (!this.eof) {\n        this.eat(RightParenthesis);\n    }\n\n    return {\n        type: 'Feature',\n        loc: this.getLocation(start, this.tokenStart),\n        kind,\n        name,\n        value\n    };\n}\n\nexport function generate(node) {\n    this.token(LeftParenthesis, '(');\n    this.token(Ident, node.name);\n\n    if (node.value !== null) {\n        this.token(Colon, ':');\n        this.node(node.value);\n    }\n\n    this.token(RightParenthesis, ')');\n}\n","import {\n    Function as FunctionToken,\n    RightParenthesis\n} from '../../tokenizer/index.js';\n\nexport const name = 'FeatureFunction';\nexport const structure = {\n    kind: String,\n    feature: String,\n    value: ['Declaration', 'Selector']\n};\n\nfunction getFeatureParser(kind, name) {\n    const featuresOfKind = this.features[kind] || {};\n    const parser = featuresOfKind[name];\n\n    if (typeof parser !== 'function') {\n        this.error(`Unknown feature ${name}()`);\n    }\n\n    return parser;\n}\n\nexport function parse(kind = 'unknown') {\n    const start = this.tokenStart;\n    const functionName = this.consumeFunctionName();\n    const valueParser = getFeatureParser.call(this, kind, functionName.toLowerCase());\n\n    this.skipSC();\n\n    const value = this.parseWithFallback(\n        () => {\n            const startValueToken = this.tokenIndex;\n            const value = valueParser.call(this);\n\n            if (this.eof === false &&\n                this.isBalanceEdge(startValueToken) === false) {\n                this.error();\n            }\n\n            return value;\n        },\n        () => this.Raw(null, false)\n    );\n\n    if (!this.eof) {\n        this.eat(RightParenthesis);\n    }\n\n    return {\n        type: 'FeatureFunction',\n        loc: this.getLocation(start, this.tokenStart),\n        kind,\n        feature: functionName,\n        value\n    };\n}\n\nexport function generate(node) {\n    this.token(FunctionToken, node.feature + '(');\n    this.node(node.value);\n    this.token(RightParenthesis, ')');\n}\n","import {\n    Ident,\n    Number,\n    Dimension,\n    Function as FunctionToken,\n    LeftParenthesis,\n    RightParenthesis\n} from '../../tokenizer/index.js';\n\nconst SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)\nconst LESSTHANSIGN = 0x003C;    // U+003C LESS-THAN SIGN (<)\nconst EQUALSSIGN = 0x003D;      // U+003D EQUALS SIGN (=)\nconst GREATERTHANSIGN = 0x003E; // U+003E GREATER-THAN SIGN (>)\n\nexport const name = 'FeatureRange';\nexport const structure = {\n    kind: String,\n    left: ['Identifier', 'Number', 'Dimension', 'Ratio', 'Function'],\n    leftComparison: String,\n    middle: ['Identifier', 'Number', 'Dimension', 'Ratio', 'Function'],\n    rightComparison: [String, null],\n    right: ['Identifier', 'Number', 'Dimension', 'Ratio', 'Function', null]\n};\n\nfunction readTerm() {\n    this.skipSC();\n\n    switch (this.tokenType) {\n        case Number:\n            if (this.isDelim(SOLIDUS, this.lookupOffsetNonSC(1))) {\n                return this.Ratio();\n            } else {\n                return this.Number();\n            }\n\n        case Dimension:\n            return this.Dimension();\n\n        case Ident:\n            return this.Identifier();\n\n        case FunctionToken:\n            return this.parseWithFallback(\n                () => {\n                    const res = this.Function(this.readSequence, this.scope.Value);\n\n                    this.skipSC();\n\n                    if (this.isDelim(SOLIDUS)) {\n                        this.error();\n                    }\n\n                    return res;\n                },\n                () => {\n                    return this.Ratio();\n                }\n            );\n\n        default:\n            this.error('Number, dimension, ratio or identifier is expected');\n    }\n}\n\nfunction readComparison(expectColon) {\n    this.skipSC();\n\n    if (this.isDelim(LESSTHANSIGN) ||\n        this.isDelim(GREATERTHANSIGN)) {\n        const value = this.source[this.tokenStart];\n\n        this.next();\n\n        if (this.isDelim(EQUALSSIGN)) {\n            this.next();\n            return value + '=';\n        }\n\n        return value;\n    }\n\n    if (this.isDelim(EQUALSSIGN)) {\n        return '=';\n    }\n\n    this.error(`Expected ${expectColon ? '\":\", ' : ''}\"<\", \">\", \"=\" or \")\"`);\n}\n\nexport function parse(kind = 'unknown') {\n    const start = this.tokenStart;\n\n    this.skipSC();\n    this.eat(LeftParenthesis);\n\n    const left = readTerm.call(this);\n    const leftComparison = readComparison.call(this, left.type === 'Identifier');\n    const middle = readTerm.call(this);\n    let rightComparison = null;\n    let right = null;\n\n    if (this.lookupNonWSType(0) !== RightParenthesis) {\n        rightComparison = readComparison.call(this);\n        right = readTerm.call(this);\n    }\n\n    this.skipSC();\n    this.eat(RightParenthesis);\n\n    return {\n        type: 'FeatureRange',\n        loc: this.getLocation(start, this.tokenStart),\n        kind,\n        left,\n        leftComparison,\n        middle,\n        rightComparison,\n        right\n    };\n}\n\nexport function generate(node) {\n    this.token(LeftParenthesis, '(');\n    this.node(node.left);\n    this.tokenize(node.leftComparison);\n    this.node(node.middle);\n\n    if (node.right) {\n        this.tokenize(node.rightComparison);\n        this.node(node.right);\n    }\n\n    this.token(RightParenthesis, ')');\n}\n","import {\n    Function as FunctionToken,\n    RightParenthesis\n} from '../../tokenizer/index.js';\n\n\nexport const name = 'Function';\nexport const walkContext = 'function';\nexport const structure = {\n    name: String,\n    children: [[]]\n};\n\n// <function-token> <sequence> )\nexport function parse(readSequence, recognizer) {\n    const start = this.tokenStart;\n    const name = this.consumeFunctionName();\n    const nameLowerCase = name.toLowerCase();\n    let children;\n\n    children = recognizer.hasOwnProperty(nameLowerCase)\n        ? recognizer[nameLowerCase].call(this, recognizer)\n        : readSequence.call(this, recognizer);\n\n    if (!this.eof) {\n        this.eat(RightParenthesis);\n    }\n\n    return {\n        type: 'Function',\n        loc: this.getLocation(start, this.tokenStart),\n        name,\n        children\n    };\n}\n\nexport function generate(node) {\n    this.token(FunctionToken, node.name + '(');\n    this.children(node);\n    this.token(RightParenthesis, ')');\n}\n","import {\n    Function as FunctionToken,\n    LeftParenthesis,\n    RightParenthesis\n} from '../../tokenizer/index.js';\n\n\nexport const name = 'GeneralEnclosed';\nexport const structure = {\n    kind: String,\n    function: [String, null],\n    children: [[]]\n};\n\n// <function-token> <any-value> )\n// ( <any-value> )\nexport function parse(kind) {\n    const start = this.tokenStart;\n    let functionName = null;\n\n    if (this.tokenType === FunctionToken) {\n        functionName = this.consumeFunctionName();\n    } else {\n        this.eat(LeftParenthesis);\n    }\n\n    const children = this.parseWithFallback(\n        () => {\n            const startValueToken = this.tokenIndex;\n            const children = this.readSequence(this.scope.Value);\n\n            if (this.eof === false &&\n                this.isBalanceEdge(startValueToken) === false) {\n                this.error();\n            }\n\n            return children;\n        },\n        () => this.createSingleNodeList(\n            this.Raw(null, false)\n        )\n    );\n\n    if (!this.eof) {\n        this.eat(RightParenthesis);\n    }\n\n    return {\n        type: 'GeneralEnclosed',\n        loc: this.getLocation(start, this.tokenStart),\n        kind,\n        function: functionName,\n        children\n    };\n}\n\nexport function generate(node) {\n    if (node.function) {\n        this.token(FunctionToken, node.function + '(');\n    } else {\n        this.token(LeftParenthesis, '(');\n    }\n\n    this.children(node);\n    this.token(RightParenthesis, ')');\n}\n","import { Hash } from '../../tokenizer/index.js';\n\n// '#' ident\nexport const xxx = 'XXX';\nexport const name = 'Hash';\nexport const structure = {\n    value: String\n};\nexport function parse() {\n    const start = this.tokenStart;\n\n    this.eat(Hash);\n\n    return {\n        type: 'Hash',\n        loc: this.getLocation(start, this.tokenStart),\n        value: this.substrToCursor(start + 1)\n    };\n}\nexport function generate(node) {\n    this.token(Hash, '#' + node.value);\n}\n\n","import { Ident } from '../../tokenizer/index.js';\n\nexport const name = 'Identifier';\nexport const structure = {\n    name: String\n};\n\nexport function parse() {\n    return {\n        type: 'Identifier',\n        loc: this.getLocation(this.tokenStart, this.tokenEnd),\n        name: this.consume(Ident)\n    };\n}\n\nexport function generate(node) {\n    this.token(Ident, node.name);\n}\n","import { Hash, Delim } from '../../tokenizer/index.js';\n\nexport const name = 'IdSelector';\nexport const structure = {\n    name: String\n};\n\nexport function parse() {\n    const start = this.tokenStart;\n\n    // TODO: check value is an ident\n    this.eat(Hash);\n\n    return {\n        type: 'IdSelector',\n        loc: this.getLocation(start, this.tokenStart),\n        name: this.substrToCursor(start + 1)\n    };\n}\n\nexport function generate(node) {\n    // Using Delim instead of Hash is a hack to avoid for a whitespace between ident and id-selector\n    // in safe mode (e.g. \"a#id\"), because IE11 doesn't allow a sequence <ident-token> <hash-token>\n    // without a whitespace in values (e.g. \"1px solid#000\")\n    this.token(Delim, '#' + node.name);\n}\n","import { Ident, Delim } from '../../tokenizer/index.js';\n\nconst FULLSTOP = 0x002E; // U+002E FULL STOP (.)\n\nexport const name = 'Layer';\nexport const structure = {\n    name: String\n};\n\nexport function parse() {\n    let tokenStart = this.tokenStart;\n    let name = this.consume(Ident);\n\n    while (this.isDelim(FULLSTOP)) {\n        this.eat(Delim);\n        name += '.' + this.consume(Ident);\n    }\n\n    return {\n        type: 'Layer',\n        loc: this.getLocation(tokenStart, this.tokenStart),\n        name\n    };\n}\n\nexport function generate(node) {\n    this.tokenize(node.name);\n}\n","import { Comma } from '../../tokenizer/index.js';\n\nexport const name = 'LayerList';\nexport const structure = {\n    children: [[\n        'Layer'\n    ]]\n};\n\nexport function parse() {\n    const children = this.createList();\n\n    this.skipSC();\n\n    while (!this.eof) {\n        children.push(this.Layer());\n\n        if (this.lookupTypeNonSC(0) !== Comma) {\n            break;\n        }\n\n        this.skipSC();\n        this.next();\n        this.skipSC();\n    }\n\n    return {\n        type: 'LayerList',\n        loc: this.getLocationFromList(children),\n        children\n    };\n}\n\nexport function generate(node) {\n    this.children(node, () => this.token(Comma, ','));\n}\n","import {\n    Comma,\n    EOF,\n    Ident,\n    LeftCurlyBracket,\n    LeftParenthesis,\n    Function as FunctionToken,\n    Semicolon\n} from '../../tokenizer/index.js';\n\nexport const name = 'MediaQuery';\nexport const structure = {\n    modifier: [String, null],\n    mediaType: [String, null],\n    condition: ['Condition', null]\n};\n\nexport function parse() {\n    const start = this.tokenStart;\n    let modifier = null;\n    let mediaType = null;\n    let condition = null;\n\n    this.skipSC();\n\n    if (this.tokenType === Ident && this.lookupTypeNonSC(1) !== LeftParenthesis) {\n        // [ not | only ]? <media-type>\n        const ident = this.consume(Ident);\n        const identLowerCase = ident.toLowerCase();\n\n        if (identLowerCase === 'not' || identLowerCase === 'only') {\n            this.skipSC();\n            modifier = identLowerCase;\n            mediaType = this.consume(Ident);\n        } else {\n            mediaType = ident;\n        }\n\n        switch (this.lookupTypeNonSC(0)) {\n            case Ident: {\n                // and <media-condition-without-or>\n                this.skipSC();\n                this.eatIdent('and');\n                condition = this.Condition('media');\n                break;\n            }\n\n            case LeftCurlyBracket:\n            case Semicolon:\n            case Comma:\n            case EOF:\n                break;\n\n            default:\n                this.error('Identifier or parenthesis is expected');\n        }\n    } else {\n        switch (this.tokenType) {\n            case Ident:\n            case LeftParenthesis:\n            case FunctionToken: {\n                // <media-condition>\n                condition = this.Condition('media');\n                break;\n            }\n\n            case LeftCurlyBracket:\n            case Semicolon:\n            case EOF:\n                break;\n\n            default:\n                this.error('Identifier or parenthesis is expected');\n        }\n    }\n\n    return {\n        type: 'MediaQuery',\n        loc: this.getLocation(start, this.tokenStart),\n        modifier,\n        mediaType,\n        condition\n    };\n}\n\nexport function generate(node) {\n    if (node.mediaType) {\n        if (node.modifier) {\n            this.token(Ident, node.modifier);\n        }\n\n        this.token(Ident, node.mediaType);\n\n        if (node.condition) {\n            this.token(Ident, 'and');\n            this.node(node.condition);\n        }\n    } else if (node.condition) {\n        this.node(node.condition);\n    }\n}\n\n","import { Comma } from '../../tokenizer/index.js';\n\nexport const name = 'MediaQueryList';\nexport const structure = {\n    children: [[\n        'MediaQuery'\n    ]]\n};\n\nexport function parse() {\n    const children = this.createList();\n\n    this.skipSC();\n\n    while (!this.eof) {\n        children.push(this.MediaQuery());\n\n        if (this.tokenType !== Comma) {\n            break;\n        }\n\n        this.next();\n    }\n\n    return {\n        type: 'MediaQueryList',\n        loc: this.getLocationFromList(children),\n        children\n    };\n}\n\nexport function generate(node) {\n    this.children(node, () => this.token(Comma, ','));\n}\n","import { Delim } from '../../tokenizer/index.js';\n\nconst AMPERSAND = 0x0026;       // U+0026 AMPERSAND (&)\n\nexport const name = 'NestingSelector';\nexport const structure = {\n};\n\nexport function parse() {\n    const start = this.tokenStart;\n\n    this.eatDelim(AMPERSAND);\n\n    return {\n        type: 'NestingSelector',\n        loc: this.getLocation(start, this.tokenStart)\n    };\n}\n\nexport function generate() {\n    this.token(Delim, '&');\n}\n","import { Ident } from '../../tokenizer/index.js';\n\nexport const name = 'Nth';\nexport const structure = {\n    nth: ['AnPlusB', 'Identifier'],\n    selector: ['SelectorList', null]\n};\n\nexport function parse() {\n    this.skipSC();\n\n    const start = this.tokenStart;\n    let end = start;\n    let selector = null;\n    let nth;\n\n    if (this.lookupValue(0, 'odd') || this.lookupValue(0, 'even')) {\n        nth = this.Identifier();\n    } else {\n        nth = this.AnPlusB();\n    }\n\n    end = this.tokenStart;\n    this.skipSC();\n\n    if (this.lookupValue(0, 'of')) {\n        this.next();\n\n        selector = this.SelectorList();\n        end = this.tokenStart;\n    }\n\n    return {\n        type: 'Nth',\n        loc: this.getLocation(start, end),\n        nth,\n        selector\n    };\n}\n\nexport function generate(node) {\n    this.node(node.nth);\n    if (node.selector !== null) {\n        this.token(Ident, 'of');\n        this.node(node.selector);\n    }\n}\n","import { Number as NumberToken } from '../../tokenizer/index.js';\n\nexport const name = 'Number';\nexport const structure = {\n    value: String\n};\n\nexport function parse() {\n    return {\n        type: 'Number',\n        loc: this.getLocation(this.tokenStart, this.tokenEnd),\n        value: this.consume(NumberToken)\n    };\n}\n\nexport function generate(node) {\n    this.token(NumberToken, node.value);\n}\n","// '/' | '*' | ',' | ':' | '+' | '-'\nexport const name = 'Operator';\nexport const structure = {\n    value: String\n};\n\nexport function parse() {\n    const start = this.tokenStart;\n\n    this.next();\n\n    return {\n        type: 'Operator',\n        loc: this.getLocation(start, this.tokenStart),\n        value: this.substrToCursor(start)\n    };\n}\n\nexport function generate(node) {\n    this.tokenize(node.value);\n}\n","import {\n    LeftParenthesis,\n    RightParenthesis\n} from '../../tokenizer/index.js';\n\nexport const name = 'Parentheses';\nexport const structure = {\n    children: [[]]\n};\n\nexport function parse(readSequence, recognizer) {\n    const start = this.tokenStart;\n    let children = null;\n\n    this.eat(LeftParenthesis);\n\n    children = readSequence.call(this, recognizer);\n\n    if (!this.eof) {\n        this.eat(RightParenthesis);\n    }\n\n    return {\n        type: 'Parentheses',\n        loc: this.getLocation(start, this.tokenStart),\n        children\n    };\n}\n\nexport function generate(node) {\n    this.token(LeftParenthesis, '(');\n    this.children(node);\n    this.token(RightParenthesis, ')');\n}\n","import { Percentage } from '../../tokenizer/index.js';\n\nexport const name = 'Percentage';\nexport const structure = {\n    value: String\n};\n\nexport function parse() {\n    return {\n        type: 'Percentage',\n        loc: this.getLocation(this.tokenStart, this.tokenEnd),\n        value: this.consumeNumber(Percentage)\n    };\n}\n\nexport function generate(node) {\n    this.token(Percentage, node.value + '%');\n}\n","import {\n    Ident,\n    Function as FunctionToken,\n    Colon,\n    RightParenthesis\n} from '../../tokenizer/index.js';\n\n\nexport const name = 'PseudoClassSelector';\nexport const walkContext = 'function';\nexport const structure = {\n    name: String,\n    children: [['Raw'], null]\n};\n\n// : [ <ident> | <function-token> <any-value>? ) ]\nexport function parse() {\n    const start = this.tokenStart;\n    let children = null;\n    let name;\n    let nameLowerCase;\n\n    this.eat(Colon);\n\n    if (this.tokenType === FunctionToken) {\n        name = this.consumeFunctionName();\n        nameLowerCase = name.toLowerCase();\n\n        if (this.lookupNonWSType(0) == RightParenthesis) {\n            children = this.createList();\n        } else if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {\n            this.skipSC();\n            children = this.pseudo[nameLowerCase].call(this);\n            this.skipSC();\n        } else {\n            children = this.createList();\n            children.push(\n                this.Raw(null, false)\n            );\n        }\n\n        this.eat(RightParenthesis);\n    } else {\n        name = this.consume(Ident);\n    }\n\n    return {\n        type: 'PseudoClassSelector',\n        loc: this.getLocation(start, this.tokenStart),\n        name,\n        children\n    };\n}\n\nexport function generate(node) {\n    this.token(Colon, ':');\n\n    if (node.children === null) {\n        this.token(Ident, node.name);\n    } else {\n        this.token(FunctionToken, node.name + '(');\n        this.children(node);\n        this.token(RightParenthesis, ')');\n    }\n}\n","import {\n    Ident,\n    Function as FunctionToken,\n    Colon,\n    RightParenthesis\n} from '../../tokenizer/index.js';\n\nexport const name = 'PseudoElementSelector';\nexport const walkContext = 'function';\nexport const structure = {\n    name: String,\n    children: [['Raw'], null]\n};\n\n// :: [ <ident> | <function-token> <any-value>? ) ]\nexport function parse() {\n    const start = this.tokenStart;\n    let children = null;\n    let name;\n    let nameLowerCase;\n\n    this.eat(Colon);\n    this.eat(Colon);\n\n    if (this.tokenType === FunctionToken) {\n        name = this.consumeFunctionName();\n        nameLowerCase = name.toLowerCase();\n\n        if (this.lookupNonWSType(0) == RightParenthesis) {\n            children = this.createList();\n        } else if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {\n            this.skipSC();\n            children = this.pseudo[nameLowerCase].call(this);\n            this.skipSC();\n        } else {\n            children = this.createList();\n            children.push(\n                this.Raw(null, false)\n            );\n        }\n\n        this.eat(RightParenthesis);\n    } else {\n        name = this.consume(Ident);\n    }\n\n    return {\n        type: 'PseudoElementSelector',\n        loc: this.getLocation(start, this.tokenStart),\n        name,\n        children\n    };\n}\n\nexport function generate(node) {\n    this.token(Colon, ':');\n    this.token(Colon, ':');\n\n    if (node.children === null) {\n        this.token(Ident, node.name);\n    } else {\n        this.token(FunctionToken, node.name + '(');\n        this.children(node);\n        this.token(RightParenthesis, ')');\n    }\n}\n","import {\n    Delim,\n    Number as NumberToken,\n    Function as FunctionToken\n} from '../../tokenizer/index.js';\n\nconst SOLIDUS = 0x002F;  // U+002F SOLIDUS (/)\n\n// Media Queries Level 3 defines terms of <ratio> as a positive (not zero or negative)\n// integers (see https://drafts.csswg.org/mediaqueries-3/#values)\n// However, Media Queries Level 4 removes any definition of values\n// (see https://drafts.csswg.org/mediaqueries-4/#values) and refers to\n// CSS Values and Units for detail. In CSS Values and Units Level 4 a <ratio>\n// definition was added (see https://drafts.csswg.org/css-values-4/#ratios) which\n// defines ratio as \"<number [0,∞]> [ / <number [0,∞]> ]?\" and based on it\n// any constrains on terms were removed. Parser also doesn't test numbers\n// in any way to make possible for linting and fixing them by the tools using CSSTree.\n// An additional syntax examination may be applied by a lexer.\nfunction consumeTerm() {\n    this.skipSC();\n\n    switch (this.tokenType) {\n        case NumberToken:\n            return this.Number();\n\n        case FunctionToken:\n            return this.Function(this.readSequence, this.scope.Value);\n\n        default:\n            this.error('Number of function is expected');\n    }\n}\n\nexport const name = 'Ratio';\nexport const structure = {\n    left: ['Number', 'Function'],\n    right: ['Number', 'Function', null]\n};\n\n// <number [0,∞]> [ / <number [0,∞]> ]?\nexport function parse() {\n    const start = this.tokenStart;\n    const left = consumeTerm.call(this);\n    let right = null;\n\n    this.skipSC();\n    if (this.isDelim(SOLIDUS)) {\n        this.eatDelim(SOLIDUS);\n        right = consumeTerm.call(this);\n    }\n\n    return {\n        type: 'Ratio',\n        loc: this.getLocation(start, this.tokenStart),\n        left,\n        right\n    };\n}\n\nexport function generate(node) {\n    this.node(node.left);\n    this.token(Delim, '/');\n    if (node.right) {\n        this.node(node.right);\n    } else {\n        this.node(NumberToken, 1);\n    }\n}\n","import { WhiteSpace } from '../../tokenizer/index.js';\n\nfunction getOffsetExcludeWS() {\n    if (this.tokenIndex > 0) {\n        if (this.lookupType(-1) === WhiteSpace) {\n            return this.tokenIndex > 1\n                ? this.getTokenStart(this.tokenIndex - 1)\n                : this.firstCharOffset;\n        }\n    }\n\n    return this.tokenStart;\n}\n\nexport const name = 'Raw';\nexport const structure = {\n    value: String\n};\n\nexport function parse(consumeUntil, excludeWhiteSpace) {\n    const startOffset = this.getTokenStart(this.tokenIndex);\n    let endOffset;\n\n    this.skipUntilBalanced(this.tokenIndex, consumeUntil || this.consumeUntilBalanceEnd);\n\n    if (excludeWhiteSpace && this.tokenStart > startOffset) {\n        endOffset = getOffsetExcludeWS.call(this);\n    } else {\n        endOffset = this.tokenStart;\n    }\n\n    return {\n        type: 'Raw',\n        loc: this.getLocation(startOffset, endOffset),\n        value: this.substring(startOffset, endOffset)\n    };\n}\n\nexport function generate(node) {\n    this.tokenize(node.value);\n}\n","import { LeftCurlyBracket } from '../../tokenizer/index.js';\n\nfunction consumeRaw() {\n    return this.Raw(this.consumeUntilLeftCurlyBracket, true);\n}\n\nfunction consumePrelude() {\n    const prelude = this.SelectorList();\n\n    if (prelude.type !== 'Raw' &&\n        this.eof === false &&\n        this.tokenType !== LeftCurlyBracket) {\n        this.error();\n    }\n\n    return prelude;\n}\n\nexport const name = 'Rule';\nexport const walkContext = 'rule';\nexport const structure = {\n    prelude: ['SelectorList', 'Raw'],\n    block: ['Block']\n};\n\nexport function parse() {\n    const startToken = this.tokenIndex;\n    const startOffset = this.tokenStart;\n    let prelude;\n    let block;\n\n    if (this.parseRulePrelude) {\n        prelude = this.parseWithFallback(consumePrelude, consumeRaw);\n    } else {\n        prelude = consumeRaw.call(this, startToken);\n    }\n\n    block = this.Block(true);\n\n    return {\n        type: 'Rule',\n        loc: this.getLocation(startOffset, this.tokenStart),\n        prelude,\n        block\n    };\n}\nexport function generate(node) {\n    this.node(node.prelude);\n    this.node(node.block);\n}\n\n","import {\n    Ident,\n    LeftParenthesis,\n    RightParenthesis\n} from '../../tokenizer/index.js';\n\nexport const name = 'Scope';\nexport const structure = {\n    root: ['SelectorList', 'Raw', null],\n    limit: ['SelectorList', 'Raw', null]\n};\n\nexport function parse() {\n    let root = null;\n    let limit = null;\n\n    this.skipSC();\n\n    const startOffset = this.tokenStart;\n    if (this.tokenType === LeftParenthesis) {\n        this.next();\n        this.skipSC();\n        root = this.parseWithFallback(\n            this.SelectorList,\n            () => this.Raw(false, true)\n        );\n        this.skipSC();\n        this.eat(RightParenthesis);\n    }\n\n    if (this.lookupNonWSType(0) === Ident) {\n        this.skipSC();\n        this.eatIdent('to');\n        this.skipSC();\n        this.eat(LeftParenthesis);\n        this.skipSC();\n        limit = this.parseWithFallback(\n            this.SelectorList,\n            () => this.Raw(false, true)\n        );\n        this.skipSC();\n        this.eat(RightParenthesis);\n    }\n\n    return {\n        type: 'Scope',\n        loc: this.getLocation(startOffset, this.tokenStart),\n        root,\n        limit\n    };\n}\n\nexport function generate(node) {\n    if (node.root) {\n        this.token(LeftParenthesis, '(');\n        this.node(node.root);\n        this.token(RightParenthesis, ')');\n    }\n\n    if (node.limit) {\n        this.token(Ident, 'to');\n        this.token(LeftParenthesis, '(');\n        this.node(node.limit);\n        this.token(RightParenthesis, ')');\n    }\n}\n","export const name = 'Selector';\nexport const structure = {\n    children: [[\n        'TypeSelector',\n        'IdSelector',\n        'ClassSelector',\n        'AttributeSelector',\n        'PseudoClassSelector',\n        'PseudoElementSelector',\n        'Combinator'\n    ]]\n};\n\nexport function parse() {\n    const children = this.readSequence(this.scope.Selector);\n\n    // nothing were consumed\n    if (this.getFirstListNode(children) === null) {\n        this.error('Selector is expected');\n    }\n\n    return {\n        type: 'Selector',\n        loc: this.getLocationFromList(children),\n        children\n    };\n}\n\nexport function generate(node) {\n    this.children(node);\n}\n","import { Comma } from '../../tokenizer/index.js';\n\nexport const name = 'SelectorList';\nexport const walkContext = 'selector';\nexport const structure = {\n    children: [[\n        'Selector',\n        'Raw'\n    ]]\n};\n\nexport function parse() {\n    const children = this.createList();\n\n    while (!this.eof) {\n        children.push(this.Selector());\n\n        if (this.tokenType === Comma) {\n            this.next();\n            continue;\n        }\n\n        break;\n    }\n\n    return {\n        type: 'SelectorList',\n        loc: this.getLocationFromList(children),\n        children\n    };\n}\n\nexport function generate(node) {\n    this.children(node, () => this.token(Comma, ','));\n}\n","import {\n    isHexDigit,\n    isWhiteSpace,\n    isValidEscape,\n    consumeEscaped,\n    decodeEscaped\n} from '../tokenizer/index.js';\n\nconst REVERSE_SOLIDUS = 0x005c; // U+005C REVERSE SOLIDUS (\\)\nconst QUOTATION_MARK = 0x0022;  // \"\nconst APOSTROPHE = 0x0027;      // '\n\nexport function decode(str) {\n    const len = str.length;\n    const firstChar = str.charCodeAt(0);\n    const start = firstChar === QUOTATION_MARK || firstChar === APOSTROPHE ? 1 : 0;\n    const end = start === 1 && len > 1 && str.charCodeAt(len - 1) === firstChar ? len - 2 : len - 1;\n    let decoded = '';\n\n    for (let i = start; i <= end; i++) {\n        let code = str.charCodeAt(i);\n\n        if (code === REVERSE_SOLIDUS) {\n            // special case at the ending\n            if (i === end) {\n                // if the next input code point is EOF, do nothing\n                // otherwise include last quote as escaped\n                if (i !== len - 1) {\n                    decoded = str.substr(i + 1);\n                }\n                break;\n            }\n\n            code = str.charCodeAt(++i);\n\n            // consume escaped\n            if (isValidEscape(REVERSE_SOLIDUS, code)) {\n                const escapeStart = i - 1;\n                const escapeEnd = consumeEscaped(str, escapeStart);\n\n                i = escapeEnd - 1;\n                decoded += decodeEscaped(str.substring(escapeStart + 1, escapeEnd));\n            } else {\n                // \\r\\n\n                if (code === 0x000d && str.charCodeAt(i + 1) === 0x000a) {\n                    i++;\n                }\n            }\n        } else {\n            decoded += str[i];\n        }\n    }\n\n    return decoded;\n}\n\n// https://drafts.csswg.org/cssom/#serialize-a-string\n// § 2.1. Common Serializing Idioms\nexport function encode(str, apostrophe) {\n    const quote = apostrophe ? '\\'' : '\"';\n    const quoteCode = apostrophe ? APOSTROPHE : QUOTATION_MARK;\n    let encoded = '';\n    let wsBeforeHexIsNeeded = false;\n\n    for (let i = 0; i < str.length; i++) {\n        const code = str.charCodeAt(i);\n\n        // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).\n        if (code === 0x0000) {\n            encoded += '\\uFFFD';\n            continue;\n        }\n\n        // If the character is in the range [\\1-\\1f] (U+0001 to U+001F) or is U+007F,\n        // the character escaped as code point.\n        // Note: Do not compare with 0x0001 since 0x0000 is precessed before\n        if (code <= 0x001f || code === 0x007F) {\n            encoded += '\\\\' + code.toString(16);\n            wsBeforeHexIsNeeded = true;\n            continue;\n        }\n\n        // If the character is '\"' (U+0022) or \"\\\" (U+005C), the escaped character.\n        if (code === quoteCode || code === REVERSE_SOLIDUS) {\n            encoded += '\\\\' + str.charAt(i);\n            wsBeforeHexIsNeeded = false;\n        } else {\n            if (wsBeforeHexIsNeeded && (isHexDigit(code) || isWhiteSpace(code))) {\n                encoded += ' ';\n            }\n\n            // Otherwise, the character itself.\n            encoded += str.charAt(i);\n            wsBeforeHexIsNeeded = false;\n        }\n    }\n\n    return quote + encoded + quote;\n}\n","import { String as StringToken } from '../../tokenizer/index.js';\nimport { decode, encode } from '../../utils/string.js';\n\nexport const name = 'String';\nexport const structure = {\n    value: String\n};\n\nexport function parse() {\n    return {\n        type: 'String',\n        loc: this.getLocation(this.tokenStart, this.tokenEnd),\n        value: decode(this.consume(StringToken))\n    };\n}\n\nexport function generate(node) {\n    this.token(StringToken, encode(node.value));\n}\n","import {\n    WhiteSpace,\n    Comment,\n    AtKeyword,\n    CDO,\n    CDC\n} from '../../tokenizer/index.js';\n\nconst EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)\n\nfunction consumeRaw() {\n    return this.Raw(null, false);\n}\n\nexport const name = 'StyleSheet';\nexport const walkContext = 'stylesheet';\nexport const structure = {\n    children: [[\n        'Comment',\n        'CDO',\n        'CDC',\n        'Atrule',\n        'Rule',\n        'Raw'\n    ]]\n};\n\nexport function parse() {\n    const start = this.tokenStart;\n    const children = this.createList();\n    let child;\n\n    scan:\n    while (!this.eof) {\n        switch (this.tokenType) {\n            case WhiteSpace:\n                this.next();\n                continue;\n\n            case Comment:\n                // ignore comments except exclamation comments (i.e. /*! .. */) on top level\n                if (this.charCodeAt(this.tokenStart + 2) !== EXCLAMATIONMARK) {\n                    this.next();\n                    continue;\n                }\n\n                child = this.Comment();\n                break;\n\n            case CDO: // <!--\n                child = this.CDO();\n                break;\n\n            case CDC: // -->\n                child = this.CDC();\n                break;\n\n            // CSS Syntax Module Level 3\n            // §2.2 Error handling\n            // At the \"top level\" of a stylesheet, an <at-keyword-token> starts an at-rule.\n            case AtKeyword:\n                child = this.parseWithFallback(this.Atrule, consumeRaw);\n                break;\n\n            // Anything else starts a qualified rule ...\n            default:\n                child = this.parseWithFallback(this.Rule, consumeRaw);\n        }\n\n        children.push(child);\n    }\n\n    return {\n        type: 'StyleSheet',\n        loc: this.getLocation(start, this.tokenStart),\n        children\n    };\n}\n\nexport function generate(node) {\n    this.children(node);\n}\n","import {\n    LeftParenthesis,\n    RightParenthesis\n} from '../../tokenizer/index.js';\n\nexport const name = 'SupportsDeclaration';\nexport const structure = {\n    declaration: 'Declaration'\n};\n\nexport function parse() {\n    const start = this.tokenStart;\n\n    this.eat(LeftParenthesis);\n    this.skipSC();\n\n    const declaration = this.Declaration();\n\n    if (!this.eof) {\n        this.eat(RightParenthesis);\n    }\n\n    return {\n        type: 'SupportsDeclaration',\n        loc: this.getLocation(start, this.tokenStart),\n        declaration\n    };\n}\n\nexport function generate(node) {\n    this.token(LeftParenthesis, '(');\n    this.node(node.declaration);\n    this.token(RightParenthesis, ')');\n}\n","import { Ident } from '../../tokenizer/index.js';\n\nconst ASTERISK = 0x002A;     // U+002A ASTERISK (*)\nconst VERTICALLINE = 0x007C; // U+007C VERTICAL LINE (|)\n\nfunction eatIdentifierOrAsterisk() {\n    if (this.tokenType !== Ident &&\n        this.isDelim(ASTERISK) === false) {\n        this.error('Identifier or asterisk is expected');\n    }\n\n    this.next();\n}\n\nexport const name = 'TypeSelector';\nexport const structure = {\n    name: String\n};\n\n// ident\n// ident|ident\n// ident|*\n// *\n// *|ident\n// *|*\n// |ident\n// |*\nexport function parse() {\n    const start = this.tokenStart;\n\n    if (this.isDelim(VERTICALLINE)) {\n        this.next();\n        eatIdentifierOrAsterisk.call(this);\n    } else {\n        eatIdentifierOrAsterisk.call(this);\n\n        if (this.isDelim(VERTICALLINE)) {\n            this.next();\n            eatIdentifierOrAsterisk.call(this);\n        }\n    }\n\n    return {\n        type: 'TypeSelector',\n        loc: this.getLocation(start, this.tokenStart),\n        name: this.substrToCursor(start)\n    };\n}\n\nexport function generate(node) {\n    this.tokenize(node.name);\n}\n","import {\n    isHexDigit,\n    Ident,\n    Number,\n    Dimension\n} from '../../tokenizer/index.js';\n\nconst PLUSSIGN = 0x002B;     // U+002B PLUS SIGN (+)\nconst HYPHENMINUS = 0x002D;  // U+002D HYPHEN-MINUS (-)\nconst QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)\n\nfunction eatHexSequence(offset, allowDash) {\n    let len = 0;\n\n    for (let pos = this.tokenStart + offset; pos < this.tokenEnd; pos++) {\n        const code = this.charCodeAt(pos);\n\n        if (code === HYPHENMINUS && allowDash && len !== 0) {\n            eatHexSequence.call(this, offset + len + 1, false);\n            return -1;\n        }\n\n        if (!isHexDigit(code)) {\n            this.error(\n                allowDash && len !== 0\n                    ? 'Hyphen minus' + (len < 6 ? ' or hex digit' : '') + ' is expected'\n                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),\n                pos\n            );\n        }\n\n        if (++len > 6) {\n            this.error('Too many hex digits', pos);\n        };\n    }\n\n    this.next();\n    return len;\n}\n\nfunction eatQuestionMarkSequence(max) {\n    let count = 0;\n\n    while (this.isDelim(QUESTIONMARK)) {\n        if (++count > max) {\n            this.error('Too many question marks');\n        }\n\n        this.next();\n    }\n}\n\nfunction startsWith(code) {\n    if (this.charCodeAt(this.tokenStart) !== code) {\n        this.error((code === PLUSSIGN ? 'Plus sign' : 'Hyphen minus') + ' is expected');\n    }\n}\n\n// https://drafts.csswg.org/css-syntax/#urange\n// Informally, the <urange> production has three forms:\n// U+0001\n//      Defines a range consisting of a single code point, in this case the code point \"1\".\n// U+0001-00ff\n//      Defines a range of codepoints between the first and the second value, in this case\n//      the range between \"1\" and \"ff\" (255 in decimal) inclusive.\n// U+00??\n//      Defines a range of codepoints where the \"?\" characters range over all hex digits,\n//      in this case defining the same as the value U+0000-00ff.\n// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat \"?\" as a hexadecimal digit).\n//\n// <urange> =\n//   u '+' <ident-token> '?'* |\n//   u <dimension-token> '?'* |\n//   u <number-token> '?'* |\n//   u <number-token> <dimension-token> |\n//   u <number-token> <number-token> |\n//   u '+' '?'+\nfunction scanUnicodeRange() {\n    let hexLength = 0;\n\n    switch (this.tokenType) {\n        case Number:\n            // u <number-token> '?'*\n            // u <number-token> <dimension-token>\n            // u <number-token> <number-token>\n            hexLength = eatHexSequence.call(this, 1, true);\n\n            if (this.isDelim(QUESTIONMARK)) {\n                eatQuestionMarkSequence.call(this, 6 - hexLength);\n                break;\n            }\n\n            if (this.tokenType === Dimension ||\n                this.tokenType === Number) {\n                startsWith.call(this, HYPHENMINUS);\n                eatHexSequence.call(this, 1, false);\n                break;\n            }\n\n            break;\n\n        case Dimension:\n            // u <dimension-token> '?'*\n            hexLength = eatHexSequence.call(this, 1, true);\n\n            if (hexLength > 0) {\n                eatQuestionMarkSequence.call(this, 6 - hexLength);\n            }\n\n            break;\n\n        default:\n            // u '+' <ident-token> '?'*\n            // u '+' '?'+\n            this.eatDelim(PLUSSIGN);\n\n            if (this.tokenType === Ident) {\n                hexLength = eatHexSequence.call(this, 0, true);\n                if (hexLength > 0) {\n                    eatQuestionMarkSequence.call(this, 6 - hexLength);\n                }\n                break;\n            }\n\n            if (this.isDelim(QUESTIONMARK)) {\n                this.next();\n                eatQuestionMarkSequence.call(this, 5);\n                break;\n            }\n\n            this.error('Hex digit or question mark is expected');\n    }\n}\n\nexport const name = 'UnicodeRange';\nexport const structure = {\n    value: String\n};\n\nexport function parse() {\n    const start = this.tokenStart;\n\n    // U or u\n    this.eatIdent('u');\n    scanUnicodeRange.call(this);\n\n    return {\n        type: 'UnicodeRange',\n        loc: this.getLocation(start, this.tokenStart),\n        value: this.substrToCursor(start)\n    };\n}\n\nexport function generate(node) {\n    this.tokenize(node.value);\n}\n","import {\n    isHexDigit,\n    isWhiteSpace,\n    isValidEscape,\n    consumeEscaped,\n    decodeEscaped\n} from '../tokenizer/index.js';\n\nconst SPACE = 0x0020;            // U+0020 SPACE\nconst REVERSE_SOLIDUS = 0x005c;  // U+005C REVERSE SOLIDUS (\\)\nconst QUOTATION_MARK = 0x0022;   // \"\nconst APOSTROPHE = 0x0027;       // '\nconst LEFTPARENTHESIS = 0x0028;  // U+0028 LEFT PARENTHESIS (()\nconst RIGHTPARENTHESIS = 0x0029; // U+0029 RIGHT PARENTHESIS ())\n\nexport function decode(str) {\n    const len = str.length;\n    let start = 4; // length of \"url(\"\n    let end = str.charCodeAt(len - 1) === RIGHTPARENTHESIS ? len - 2 : len - 1;\n    let decoded = '';\n\n    while (start < end && isWhiteSpace(str.charCodeAt(start))) {\n        start++;\n    }\n\n    while (start < end && isWhiteSpace(str.charCodeAt(end))) {\n        end--;\n    }\n\n    for (let i = start; i <= end; i++) {\n        let code = str.charCodeAt(i);\n\n        if (code === REVERSE_SOLIDUS) {\n            // special case at the ending\n            if (i === end) {\n                // if the next input code point is EOF, do nothing\n                // otherwise include last left parenthesis as escaped\n                if (i !== len - 1) {\n                    decoded = str.substr(i + 1);\n                }\n                break;\n            }\n\n            code = str.charCodeAt(++i);\n\n            // consume escaped\n            if (isValidEscape(REVERSE_SOLIDUS, code)) {\n                const escapeStart = i - 1;\n                const escapeEnd = consumeEscaped(str, escapeStart);\n\n                i = escapeEnd - 1;\n                decoded += decodeEscaped(str.substring(escapeStart + 1, escapeEnd));\n            } else {\n                // \\r\\n\n                if (code === 0x000d && str.charCodeAt(i + 1) === 0x000a) {\n                    i++;\n                }\n            }\n        } else {\n            decoded += str[i];\n        }\n    }\n\n    return decoded;\n}\n\nexport function encode(str) {\n    let encoded = '';\n    let wsBeforeHexIsNeeded = false;\n\n    for (let i = 0; i < str.length; i++) {\n        const code = str.charCodeAt(i);\n\n        // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).\n        if (code === 0x0000) {\n            encoded += '\\uFFFD';\n            continue;\n        }\n\n        // If the character is in the range [\\1-\\1f] (U+0001 to U+001F) or is U+007F,\n        // the character escaped as code point.\n        // Note: Do not compare with 0x0001 since 0x0000 is precessed before\n        if (code <= 0x001f || code === 0x007F) {\n            encoded += '\\\\' + code.toString(16);\n            wsBeforeHexIsNeeded = true;\n            continue;\n        }\n\n        if (code === SPACE ||\n            code === REVERSE_SOLIDUS ||\n            code === QUOTATION_MARK ||\n            code === APOSTROPHE ||\n            code === LEFTPARENTHESIS ||\n            code === RIGHTPARENTHESIS) {\n            encoded += '\\\\' + str.charAt(i);\n            wsBeforeHexIsNeeded = false;\n        } else {\n            if (wsBeforeHexIsNeeded && isHexDigit(code)) {\n                encoded += ' ';\n            }\n\n            encoded += str.charAt(i);\n            wsBeforeHexIsNeeded = false;\n        }\n    }\n\n    return 'url(' + encoded + ')';\n}\n","import * as url from '../../utils/url.js';\nimport * as string from '../../utils/string.js';\nimport {\n    Function as FunctionToken,\n    String as StringToken,\n    Url,\n    RightParenthesis\n} from '../../tokenizer/index.js';\n\nexport const name = 'Url';\nexport const structure = {\n    value: String\n};\n\n// <url-token> | <function-token> <string> )\nexport function parse() {\n    const start = this.tokenStart;\n    let value;\n\n    switch (this.tokenType) {\n        case Url:\n            value = url.decode(this.consume(Url));\n            break;\n\n        case FunctionToken:\n            if (!this.cmpStr(this.tokenStart, this.tokenEnd, 'url(')) {\n                this.error('Function name must be `url`');\n            }\n\n            this.eat(FunctionToken);\n            this.skipSC();\n            value = string.decode(this.consume(StringToken));\n            this.skipSC();\n            if (!this.eof) {\n                this.eat(RightParenthesis);\n            }\n            break;\n\n        default:\n            this.error('Url or Function is expected');\n    }\n\n    return {\n        type: 'Url',\n        loc: this.getLocation(start, this.tokenStart),\n        value\n    };\n}\n\nexport function generate(node) {\n    this.token(Url, url.encode(node.value));\n}\n","export const name = 'Value';\nexport const structure = {\n    children: [[]]\n};\n\nexport function parse() {\n    const start = this.tokenStart;\n    const children = this.readSequence(this.scope.Value);\n\n    return {\n        type: 'Value',\n        loc: this.getLocation(start, this.tokenStart),\n        children\n    };\n}\n\nexport function generate(node) {\n    this.children(node);\n}\n","import { WhiteSpace } from '../../tokenizer/index.js';\n\nconst SPACE = Object.freeze({\n    type: 'WhiteSpace',\n    loc: null,\n    value: ' '\n});\n\nexport const name = 'WhiteSpace';\nexport const structure = {\n    value: String\n};\n\nexport function parse() {\n    this.eat(WhiteSpace);\n    return SPACE;\n\n    // return {\n    //     type: 'WhiteSpace',\n    //     loc: this.getLocation(this.tokenStart, this.tokenEnd),\n    //     value: this.consume(WHITESPACE)\n    // };\n}\n\nexport function generate(node) {\n    this.token(WhiteSpace, node.value);\n}\n","import { createWalker } from './create.js';\nimport config from '../syntax/config/walker.js';\n\nexport default createWalker(config);\n","import * as node from '../node/index.js';\n\nexport default {\n    node\n};\n","// Inset properties\nexport const INSET_PROPS = [\n  'left',\n  'right',\n  'top',\n  'bottom',\n  'inset-block-start',\n  'inset-block-end',\n  'inset-inline-start',\n  'inset-inline-end',\n  'inset-block',\n  'inset-inline',\n  'inset',\n] as const;\n\nexport type InsetProperty = (typeof INSET_PROPS)[number];\n\nexport function isInsetProp(\n  property: string | AnchorSide,\n): property is InsetProperty {\n  return INSET_PROPS.includes(property as InsetProperty);\n}\n\n// Margin properties\nexport const MARGIN_PROPERTIES = [\n  'margin-block-start',\n  'margin-block-end',\n  'margin-block',\n  'margin-inline-start',\n  'margin-inline-end',\n  'margin-inline',\n  'margin-bottom',\n  'margin-left',\n  'margin-right',\n  'margin-top',\n  'margin',\n] as const;\n\nexport type MarginProperty = (typeof MARGIN_PROPERTIES)[number];\n\nexport function isMarginProp(property: string): property is MarginProperty {\n  return MARGIN_PROPERTIES.includes(property as MarginProperty);\n}\n\n// Sizing properties\nexport const SIZING_PROPS = [\n  'width',\n  'height',\n  'min-width',\n  'min-height',\n  'max-width',\n  'max-height',\n  'block-size',\n  'inline-size',\n  'min-block-size',\n  'min-inline-size',\n  'max-block-size',\n  'max-inline-size',\n] as const;\n\nexport type SizingProperty = (typeof SIZING_PROPS)[number];\n\nexport function isSizingProp(property: string): property is SizingProperty {\n  return SIZING_PROPS.includes(property as SizingProperty);\n}\n\n// Self Alignment Properties\nexport const SELF_ALIGNMENT_PROPS = [\n  'justify-self',\n  'align-self',\n  'place-self',\n] as const;\n\nexport type SelfAlignmentProperty = (typeof SELF_ALIGNMENT_PROPS)[number];\n\nexport function isSelfAlignmentProp(\n  property: string,\n): property is SelfAlignmentProperty {\n  return SELF_ALIGNMENT_PROPS.includes(property as SelfAlignmentProperty);\n}\n\n// Accepted position try properties\nexport const ACCEPTED_POSITION_TRY_PROPERTIES = [\n  ...INSET_PROPS,\n  ...MARGIN_PROPERTIES,\n  ...SIZING_PROPS,\n  ...SELF_ALIGNMENT_PROPS,\n  'position-anchor',\n  'position-area',\n] as const;\n\nexport type AcceptedPositionTryProperty =\n  (typeof ACCEPTED_POSITION_TRY_PROPERTIES)[number];\n\nexport function isAcceptedPositionTryProp(\n  property: string,\n): property is AcceptedPositionTryProperty {\n  return ACCEPTED_POSITION_TRY_PROPERTIES.includes(\n    property as AcceptedPositionTryProperty,\n  );\n}\n\n// Accepted anchor-size() properties\nexport const ACCEPTED_ANCHOR_SIZE_PROPERTIES = [\n  ...SIZING_PROPS,\n  ...INSET_PROPS,\n  ...MARGIN_PROPERTIES,\n] as const;\n\nexport type AcceptedAnchorSizeProperty =\n  (typeof ACCEPTED_ANCHOR_SIZE_PROPERTIES)[number];\n\nexport function isAcceptedAnchorSizeProp(\n  property: string,\n): property is AcceptedAnchorSizeProperty {\n  return ACCEPTED_ANCHOR_SIZE_PROPERTIES.includes(\n    property as AcceptedAnchorSizeProperty,\n  );\n}\n\n// Anchor Side properties\nexport const ANCHOR_SIDES = [\n  'top',\n  'left',\n  'right',\n  'bottom',\n  'start',\n  'end',\n  'self-start',\n  'self-end',\n  'center',\n  'inside',\n  'outside',\n];\nexport type AnchorSideKeyword = (typeof ANCHOR_SIDES)[number];\n\nexport type AnchorSide = AnchorSideKeyword | number;\n\nexport function isAnchorSide(property: string): property is AnchorSideKeyword {\n  return ANCHOR_SIDES.includes(property as AnchorSideKeyword);\n}\n\n// Anchor Size\nexport const ANCHOR_SIZES = [\n  'width',\n  'height',\n  'block',\n  'inline',\n  'self-block',\n  'self-inline',\n] as const;\n\nexport type AnchorSize = (typeof ANCHOR_SIZES)[number];\n\nexport function isAnchorSize(property: string): property is AnchorSize {\n  return ANCHOR_SIZES.includes(property as AnchorSize);\n}\n","import { SourceMapGenerator } from 'source-map-js/lib/source-map-generator.js';\n\nconst trackNodes = new Set(['Atrule', 'Selector', 'Declaration']);\n\nexport function generateSourceMap(handlers) {\n    const map = new SourceMapGenerator();\n    const generated = {\n        line: 1,\n        column: 0\n    };\n    const original = {\n        line: 0, // should be zero to add first mapping\n        column: 0\n    };\n    const activatedGenerated = {\n        line: 1,\n        column: 0\n    };\n    const activatedMapping = {\n        generated: activatedGenerated\n    };\n    let line = 1;\n    let column = 0;\n    let sourceMappingActive = false;\n\n    const origHandlersNode = handlers.node;\n    handlers.node = function(node) {\n        if (node.loc && node.loc.start && trackNodes.has(node.type)) {\n            const nodeLine = node.loc.start.line;\n            const nodeColumn = node.loc.start.column - 1;\n\n            if (original.line !== nodeLine ||\n                original.column !== nodeColumn) {\n                original.line = nodeLine;\n                original.column = nodeColumn;\n\n                generated.line = line;\n                generated.column = column;\n\n                if (sourceMappingActive) {\n                    sourceMappingActive = false;\n                    if (generated.line !== activatedGenerated.line ||\n                        generated.column !== activatedGenerated.column) {\n                        map.addMapping(activatedMapping);\n                    }\n                }\n\n                sourceMappingActive = true;\n                map.addMapping({\n                    source: node.loc.source,\n                    original,\n                    generated\n                });\n            }\n        }\n\n        origHandlersNode.call(this, node);\n\n        if (sourceMappingActive && trackNodes.has(node.type)) {\n            activatedGenerated.line = line;\n            activatedGenerated.column = column;\n        }\n    };\n\n    const origHandlersEmit = handlers.emit;\n    handlers.emit = function(value, type, auto) {\n        for (let i = 0; i < value.length; i++) {\n            if (value.charCodeAt(i) === 10) { // \\n\n                line++;\n                column = 0;\n            } else {\n                column++;\n            }\n        }\n\n        origHandlersEmit(value, type, auto);\n    };\n\n    const origHandlersResult = handlers.result;\n    handlers.result = function() {\n        if (sourceMappingActive) {\n            map.addMapping(activatedMapping);\n        }\n\n        return {\n            css: origHandlersResult(),\n            map\n        };\n    };\n\n    return handlers;\n};\n","import {\n    WhiteSpace,\n    Delim,\n    Ident,\n    Function as FunctionToken,\n    Url,\n    BadUrl,\n    AtKeyword,\n    Hash,\n    Percentage,\n    Dimension,\n    Number as NumberToken,\n    String as StringToken,\n    Colon,\n    LeftParenthesis,\n    RightParenthesis,\n    CDC\n} from '../tokenizer/index.js';\n\nconst PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)\nconst HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)\n\nconst code = (type, value) => {\n    if (type === Delim) {\n        type = value;\n    }\n\n    if (typeof type === 'string') {\n        const charCode = type.charCodeAt(0);\n        return charCode > 0x7F ? 0x8000 : charCode << 8;\n    }\n\n    return type;\n};\n\n// https://www.w3.org/TR/css-syntax-3/#serialization\n// The only requirement for serialization is that it must \"round-trip\" with parsing,\n// that is, parsing the stylesheet must produce the same data structures as parsing,\n// serializing, and parsing again, except for consecutive <whitespace-token>s,\n// which may be collapsed into a single token.\n\nconst specPairs = [\n    [Ident, Ident],\n    [Ident, FunctionToken],\n    [Ident, Url],\n    [Ident, BadUrl],\n    [Ident, '-'],\n    [Ident, NumberToken],\n    [Ident, Percentage],\n    [Ident, Dimension],\n    [Ident, CDC],\n    [Ident, LeftParenthesis],\n\n    [AtKeyword, Ident],\n    [AtKeyword, FunctionToken],\n    [AtKeyword, Url],\n    [AtKeyword, BadUrl],\n    [AtKeyword, '-'],\n    [AtKeyword, NumberToken],\n    [AtKeyword, Percentage],\n    [AtKeyword, Dimension],\n    [AtKeyword, CDC],\n\n    [Hash, Ident],\n    [Hash, FunctionToken],\n    [Hash, Url],\n    [Hash, BadUrl],\n    [Hash, '-'],\n    [Hash, NumberToken],\n    [Hash, Percentage],\n    [Hash, Dimension],\n    [Hash, CDC],\n\n    [Dimension, Ident],\n    [Dimension, FunctionToken],\n    [Dimension, Url],\n    [Dimension, BadUrl],\n    [Dimension, '-'],\n    [Dimension, NumberToken],\n    [Dimension, Percentage],\n    [Dimension, Dimension],\n    [Dimension, CDC],\n\n    ['#', Ident],\n    ['#', FunctionToken],\n    ['#', Url],\n    ['#', BadUrl],\n    ['#', '-'],\n    ['#', NumberToken],\n    ['#', Percentage],\n    ['#', Dimension],\n    ['#', CDC], // https://github.com/w3c/csswg-drafts/pull/6874\n\n    ['-', Ident],\n    ['-', FunctionToken],\n    ['-', Url],\n    ['-', BadUrl],\n    ['-', '-'],\n    ['-', NumberToken],\n    ['-', Percentage],\n    ['-', Dimension],\n    ['-', CDC], // https://github.com/w3c/csswg-drafts/pull/6874\n\n    [NumberToken, Ident],\n    [NumberToken, FunctionToken],\n    [NumberToken, Url],\n    [NumberToken, BadUrl],\n    [NumberToken, NumberToken],\n    [NumberToken, Percentage],\n    [NumberToken, Dimension],\n    [NumberToken, '%'],\n    [NumberToken, CDC], // https://github.com/w3c/csswg-drafts/pull/6874\n\n    ['@', Ident],\n    ['@', FunctionToken],\n    ['@', Url],\n    ['@', BadUrl],\n    ['@', '-'],\n    ['@', CDC], // https://github.com/w3c/csswg-drafts/pull/6874\n\n    ['.', NumberToken],\n    ['.', Percentage],\n    ['.', Dimension],\n\n    ['+', NumberToken],\n    ['+', Percentage],\n    ['+', Dimension],\n\n    ['/', '*']\n];\n// validate with scripts/generate-safe\nconst safePairs = specPairs.concat([\n    [Ident, Hash],\n\n    [Dimension, Hash],\n\n    [Hash, Hash],\n\n    [AtKeyword, LeftParenthesis],\n    [AtKeyword, StringToken],\n    [AtKeyword, Colon],\n\n    [Percentage, Percentage],\n    [Percentage, Dimension],\n    [Percentage, FunctionToken],\n    [Percentage, '-'],\n\n    [RightParenthesis, Ident],\n    [RightParenthesis, FunctionToken],\n    [RightParenthesis, Percentage],\n    [RightParenthesis, Dimension],\n    [RightParenthesis, Hash],\n    [RightParenthesis, '-']\n]);\n\nfunction createMap(pairs) {\n    const isWhiteSpaceRequired = new Set(\n        pairs.map(([prev, next]) => (code(prev) << 16 | code(next)))\n    );\n\n    return function(prevCode, type, value) {\n        const nextCode = code(type, value);\n        const nextCharCode = value.charCodeAt(0);\n        const emitWs =\n            (nextCharCode === HYPHENMINUS &&\n                type !== Ident &&\n                type !== FunctionToken &&\n                type !== CDC) ||\n            (nextCharCode === PLUSSIGN)\n                ? isWhiteSpaceRequired.has(prevCode << 16 | nextCharCode << 8)\n                : isWhiteSpaceRequired.has(prevCode << 16 | nextCode);\n\n        if (emitWs) {\n            this.emit(' ', WhiteSpace, true);\n        }\n\n        return nextCode;\n    };\n}\n\nexport const spec = createMap(specPairs);\nexport const safe = createMap(safePairs);\n","import { tokenize, Delim, WhiteSpace } from '../tokenizer/index.js';\nimport { generateSourceMap } from './sourceMap.js';\nimport * as tokenBefore from './token-before.js';\n\nconst REVERSESOLIDUS = 0x005c; // U+005C REVERSE SOLIDUS (\\)\n\nfunction processChildren(node, delimeter) {\n    if (typeof delimeter === 'function') {\n        let prev = null;\n\n        node.children.forEach(node => {\n            if (prev !== null) {\n                delimeter.call(this, prev);\n            }\n\n            this.node(node);\n            prev = node;\n        });\n\n        return;\n    }\n\n    node.children.forEach(this.node, this);\n}\n\nfunction processChunk(chunk) {\n    tokenize(chunk, (type, start, end) => {\n        this.token(type, chunk.slice(start, end));\n    });\n}\n\nexport function createGenerator(config) {\n    const types = new Map();\n\n    for (let [name, item] of Object.entries(config.node)) {\n        const fn = item.generate || item;\n\n        if (typeof fn === 'function') {\n            types.set(name, item.generate || item);\n        }\n    }\n\n    return function(node, options) {\n        let buffer = '';\n        let prevCode = 0;\n        let handlers = {\n            node(node) {\n                if (types.has(node.type)) {\n                    types.get(node.type).call(publicApi, node);\n                } else {\n                    throw new Error('Unknown node type: ' + node.type);\n                }\n            },\n            tokenBefore: tokenBefore.safe,\n            token(type, value) {\n                prevCode = this.tokenBefore(prevCode, type, value);\n\n                this.emit(value, type, false);\n\n                if (type === Delim && value.charCodeAt(0) === REVERSESOLIDUS) {\n                    this.emit('\\n', WhiteSpace, true);\n                }\n            },\n            emit(value) {\n                buffer += value;\n            },\n            result() {\n                return buffer;\n            }\n        };\n\n        if (options) {\n            if (typeof options.decorator === 'function') {\n                handlers = options.decorator(handlers);\n            }\n\n            if (options.sourceMap) {\n                handlers = generateSourceMap(handlers);\n            }\n\n            if (options.mode in tokenBefore) {\n                handlers.tokenBefore = tokenBefore[options.mode];\n            }\n        }\n\n        const publicApi = {\n            node: (node) => handlers.node(node),\n            children: processChildren,\n            token: (type, value) => handlers.token(type, value),\n            tokenize: processChunk\n        };\n\n        handlers.node(node);\n\n        return handlers.result();\n    };\n};\n","import { createGenerator } from './create.js';\nimport config from '../syntax/config/generator.js';\n\nexport default createGenerator(config);\n","import * as node from '../node/index-generate.js';\n\nexport default {\n    node\n};\n","//\n//                              list\n//                            ┌──────┐\n//             ┌──────────────┼─head │\n//             │              │ tail─┼──────────────┐\n//             │              └──────┘              │\n//             ▼                                    ▼\n//            item        item        item        item\n//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐\n//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │\n//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null\n//          ├──────┤    ├──────┤    ├──────┤    ├──────┤\n//          │ data │    │ data │    │ data │    │ data │\n//          └──────┘    └──────┘    └──────┘    └──────┘\n//\n\nlet releasedCursors = null;\n\nexport class List {\n    static createItem(data) {\n        return {\n            prev: null,\n            next: null,\n            data\n        };\n    }\n\n    constructor() {\n        this.head = null;\n        this.tail = null;\n        this.cursor = null;\n    }\n    createItem(data) {\n        return List.createItem(data);\n    }\n\n    // cursor helpers\n    allocateCursor(prev, next) {\n        let cursor;\n\n        if (releasedCursors !== null) {\n            cursor = releasedCursors;\n            releasedCursors = releasedCursors.cursor;\n            cursor.prev = prev;\n            cursor.next = next;\n            cursor.cursor = this.cursor;\n        } else {\n            cursor = {\n                prev,\n                next,\n                cursor: this.cursor\n            };\n        }\n\n        this.cursor = cursor;\n\n        return cursor;\n    }\n    releaseCursor() {\n        const { cursor } = this;\n\n        this.cursor = cursor.cursor;\n        cursor.prev = null;\n        cursor.next = null;\n        cursor.cursor = releasedCursors;\n        releasedCursors = cursor;\n    }\n    updateCursors(prevOld, prevNew, nextOld, nextNew) {\n        let { cursor } = this;\n\n        while (cursor !== null) {\n            if (cursor.prev === prevOld) {\n                cursor.prev = prevNew;\n            }\n\n            if (cursor.next === nextOld) {\n                cursor.next = nextNew;\n            }\n\n            cursor = cursor.cursor;\n        }\n    }\n    *[Symbol.iterator]() {\n        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {\n            yield cursor.data;\n        }\n    }\n\n    // getters\n    get size() {\n        let size = 0;\n\n        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {\n            size++;\n        }\n\n        return size;\n    }\n    get isEmpty() {\n        return this.head === null;\n    }\n    get first() {\n        return this.head && this.head.data;\n    }\n    get last() {\n        return this.tail && this.tail.data;\n    }\n\n    // convertors\n    fromArray(array) {\n        let cursor = null;\n        this.head = null;\n\n        for (let data of array) {\n            const item = List.createItem(data);\n\n            if (cursor !== null) {\n                cursor.next = item;\n            } else {\n                this.head = item;\n            }\n\n            item.prev = cursor;\n            cursor = item;\n        }\n\n        this.tail = cursor;\n        return this;\n    }\n    toArray() {\n        return [...this];\n    }\n    toJSON() {\n        return [...this];\n    }\n\n    // array-like methods\n    forEach(fn, thisArg = this) {\n        // push cursor\n        const cursor = this.allocateCursor(null, this.head);\n\n        while (cursor.next !== null) {\n            const item = cursor.next;\n            cursor.next = item.next;\n            fn.call(thisArg, item.data, item, this);\n        }\n\n        // pop cursor\n        this.releaseCursor();\n    }\n    forEachRight(fn, thisArg = this) {\n        // push cursor\n        const cursor = this.allocateCursor(this.tail, null);\n\n        while (cursor.prev !== null) {\n            const item = cursor.prev;\n            cursor.prev = item.prev;\n            fn.call(thisArg, item.data, item, this);\n        }\n\n        // pop cursor\n        this.releaseCursor();\n    }\n    reduce(fn, initialValue, thisArg = this) {\n        // push cursor\n        let cursor = this.allocateCursor(null, this.head);\n        let acc = initialValue;\n        let item;\n\n        while (cursor.next !== null) {\n            item = cursor.next;\n            cursor.next = item.next;\n\n            acc = fn.call(thisArg, acc, item.data, item, this);\n        }\n\n        // pop cursor\n        this.releaseCursor();\n\n        return acc;\n    }\n    reduceRight(fn, initialValue, thisArg = this) {\n        // push cursor\n        let cursor = this.allocateCursor(this.tail, null);\n        let acc = initialValue;\n        let item;\n\n        while (cursor.prev !== null) {\n            item = cursor.prev;\n            cursor.prev = item.prev;\n\n            acc = fn.call(thisArg, acc, item.data, item, this);\n        }\n\n        // pop cursor\n        this.releaseCursor();\n\n        return acc;\n    }\n    some(fn, thisArg = this) {\n        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {\n            if (fn.call(thisArg, cursor.data, cursor, this)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n    map(fn, thisArg = this) {\n        const result = new List();\n\n        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {\n            result.appendData(fn.call(thisArg, cursor.data, cursor, this));\n        }\n\n        return result;\n    }\n    filter(fn, thisArg = this) {\n        const result = new List();\n\n        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {\n            if (fn.call(thisArg, cursor.data, cursor, this)) {\n                result.appendData(cursor.data);\n            }\n        }\n\n        return result;\n    }\n\n    nextUntil(start, fn, thisArg = this) {\n        if (start === null) {\n            return;\n        }\n\n        // push cursor\n        const cursor = this.allocateCursor(null, start);\n\n        while (cursor.next !== null) {\n            const item = cursor.next;\n            cursor.next = item.next;\n            if (fn.call(thisArg, item.data, item, this)) {\n                break;\n            }\n        }\n\n        // pop cursor\n        this.releaseCursor();\n    }\n    prevUntil(start, fn, thisArg = this) {\n        if (start === null) {\n            return;\n        }\n\n        // push cursor\n        const cursor = this.allocateCursor(start, null);\n\n        while (cursor.prev !== null) {\n            const item = cursor.prev;\n            cursor.prev = item.prev;\n            if (fn.call(thisArg, item.data, item, this)) {\n                break;\n            }\n        }\n\n        // pop cursor\n        this.releaseCursor();\n    }\n\n    // mutation\n    clear() {\n        this.head = null;\n        this.tail = null;\n    }\n    copy() {\n        const result = new List();\n\n        for (let data of this) {\n            result.appendData(data);\n        }\n\n        return result;\n    }\n    prepend(item) {\n        //      head\n        //    ^\n        // item\n        this.updateCursors(null, item, this.head, item);\n\n        // insert to the beginning of the list\n        if (this.head !== null) {\n            // new item <- first item\n            this.head.prev = item;\n            // new item -> first item\n            item.next = this.head;\n        } else {\n            // if list has no head, then it also has no tail\n            // in this case tail points to the new item\n            this.tail = item;\n        }\n\n        // head always points to new item\n        this.head = item;\n        return this;\n    }\n    prependData(data) {\n        return this.prepend(List.createItem(data));\n    }\n    append(item) {\n        return this.insert(item);\n    }\n    appendData(data) {\n        return this.insert(List.createItem(data));\n    }\n    insert(item, before = null) {\n        if (before !== null) {\n            // prev   before\n            //      ^\n            //     item\n            this.updateCursors(before.prev, item, before, item);\n\n            if (before.prev === null) {\n                // insert to the beginning of list\n                if (this.head !== before) {\n                    throw new Error('before doesn\\'t belong to list');\n                }\n                // since head points to before therefore list doesn't empty\n                // no need to check tail\n                this.head = item;\n                before.prev = item;\n                item.next = before;\n                this.updateCursors(null, item);\n            } else {\n                // insert between two items\n                before.prev.next = item;\n                item.prev = before.prev;\n                before.prev = item;\n                item.next = before;\n            }\n        } else {\n            // tail\n            //      ^\n            //      item\n            this.updateCursors(this.tail, item, null, item);\n\n            // insert to the ending of the list\n            if (this.tail !== null) {\n                // last item -> new item\n                this.tail.next = item;\n                // last item <- new item\n                item.prev = this.tail;\n            } else {\n                // if list has no tail, then it also has no head\n                // in this case head points to new item\n                this.head = item;\n            }\n\n            // tail always points to new item\n            this.tail = item;\n        }\n\n        return this;\n    }\n    insertData(data, before) {\n        return this.insert(List.createItem(data), before);\n    }\n    remove(item) {\n        //      item\n        //       ^\n        // prev     next\n        this.updateCursors(item, item.prev, item, item.next);\n\n        if (item.prev !== null) {\n            item.prev.next = item.next;\n        } else {\n            if (this.head !== item) {\n                throw new Error('item doesn\\'t belong to list');\n            }\n\n            this.head = item.next;\n        }\n\n        if (item.next !== null) {\n            item.next.prev = item.prev;\n        } else {\n            if (this.tail !== item) {\n                throw new Error('item doesn\\'t belong to list');\n            }\n\n            this.tail = item.prev;\n        }\n\n        item.prev = null;\n        item.next = null;\n\n        return item;\n    }\n    push(data) {\n        this.insert(List.createItem(data));\n    }\n    pop() {\n        return this.tail !== null ? this.remove(this.tail) : null;\n    }\n    unshift(data) {\n        this.prepend(List.createItem(data));\n    }\n    shift() {\n        return this.head !== null ? this.remove(this.head) : null;\n    }\n    prependList(list) {\n        return this.insertList(list, this.head);\n    }\n    appendList(list) {\n        return this.insertList(list);\n    }\n    insertList(list, before) {\n        // ignore empty lists\n        if (list.head === null) {\n            return this;\n        }\n\n        if (before !== undefined && before !== null) {\n            this.updateCursors(before.prev, list.tail, before, list.head);\n\n            // insert in the middle of dist list\n            if (before.prev !== null) {\n                // before.prev <-> list.head\n                before.prev.next = list.head;\n                list.head.prev = before.prev;\n            } else {\n                this.head = list.head;\n            }\n\n            before.prev = list.tail;\n            list.tail.next = before;\n        } else {\n            this.updateCursors(this.tail, list.tail, null, list.head);\n\n            // insert to end of the list\n            if (this.tail !== null) {\n                // if destination list has a tail, then it also has a head,\n                // but head doesn't change\n                // dest tail -> source head\n                this.tail.next = list.head;\n                // dest tail <- source head\n                list.head.prev = this.tail;\n            } else {\n                // if list has no a tail, then it also has no a head\n                // in this case points head to new item\n                this.head = list.head;\n            }\n\n            // tail always start point to new item\n            this.tail = list.tail;\n        }\n\n        list.head = null;\n        list.tail = null;\n        return this;\n    }\n    replace(oldItem, newItemOrList) {\n        if ('head' in newItemOrList) {\n            this.insertList(newItemOrList, oldItem);\n        } else {\n            this.insert(newItemOrList, oldItem);\n        }\n\n        this.remove(oldItem);\n    }\n}\n","export function createCustomError(name, message) {\n    // use Object.create(), because some VMs prevent setting line/column otherwise\n    // (iOS Safari 10 even throws an exception)\n    const error = Object.create(SyntaxError.prototype);\n    const errorStack = new Error();\n\n    return Object.assign(error, {\n        name,\n        message,\n        get stack() {\n            return (errorStack.stack || '').replace(/^(.+\\n){1,3}/, `${name}: ${message}\\n`);\n        }\n    });\n};\n","import { createCustomError } from '../utils/create-custom-error.js';\n\nconst MAX_LINE_LENGTH = 100;\nconst OFFSET_CORRECTION = 60;\nconst TAB_REPLACEMENT = '    ';\n\nfunction sourceFragment({ source, line, column, baseLine, baseColumn }, extraLines) {\n    function processLines(start, end) {\n        return lines\n            .slice(start, end)\n            .map((line, idx) =>\n                String(start + idx + 1).padStart(maxNumLength) + ' |' + line\n            ).join('\\n');\n    }\n\n    const prelines = '\\n'.repeat(Math.max(baseLine - 1, 0));\n    const precolumns = ' '.repeat(Math.max(baseColumn - 1, 0));\n    const lines = (prelines + precolumns + source).split(/\\r\\n?|\\n|\\f/);\n    const startLine = Math.max(1, line - extraLines) - 1;\n    const endLine = Math.min(line + extraLines, lines.length + 1);\n    const maxNumLength = Math.max(4, String(endLine).length) + 1;\n    let cutLeft = 0;\n\n    // column correction according to replaced tab before column\n    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\\t/g) || []).length;\n\n    if (column > MAX_LINE_LENGTH) {\n        cutLeft = column - OFFSET_CORRECTION + 3;\n        column = OFFSET_CORRECTION - 2;\n    }\n\n    for (let i = startLine; i <= endLine; i++) {\n        if (i >= 0 && i < lines.length) {\n            lines[i] = lines[i].replace(/\\t/g, TAB_REPLACEMENT);\n            lines[i] =\n                (cutLeft > 0 && lines[i].length > cutLeft ? '\\u2026' : '') +\n                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +\n                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\\u2026' : '');\n        }\n    }\n\n    return [\n        processLines(startLine, line),\n        new Array(column + maxNumLength + 2).join('-') + '^',\n        processLines(line, endLine)\n    ].filter(Boolean)\n        .join('\\n')\n        .replace(/^(\\s+\\d+\\s+\\|\\n)+/, '')\n        .replace(/\\n(\\s+\\d+\\s+\\|)+$/, '');\n}\n\nexport function SyntaxError(message, source, offset, line, column, baseLine = 1, baseColumn = 1) {\n    const error = Object.assign(createCustomError('SyntaxError', message), {\n        source,\n        offset,\n        line,\n        column,\n        sourceFragment(extraLines) {\n            return sourceFragment({ source, line, column, baseLine, baseColumn }, isNaN(extraLines) ? 0 : extraLines);\n        },\n        get formattedMessage() {\n            return (\n                `Parse error: ${message}\\n` +\n                sourceFragment({ source, line, column, baseLine, baseColumn }, 2)\n            );\n        }\n    });\n\n    return error;\n}\n","import { WhiteSpace, Comment } from '../tokenizer/index.js';\n\nexport function readSequence(recognizer) {\n    const children = this.createList();\n    let space = false;\n    const context = {\n        recognizer\n    };\n\n    while (!this.eof) {\n        switch (this.tokenType) {\n            case Comment:\n                this.next();\n                continue;\n\n            case WhiteSpace:\n                space = true;\n                this.next();\n                continue;\n        }\n\n        let child = recognizer.getNode.call(this, context);\n\n        if (child === undefined) {\n            break;\n        }\n\n        if (space) {\n            if (recognizer.onWhiteSpace) {\n                recognizer.onWhiteSpace.call(this, child, children, context);\n            }\n            space = false;\n        }\n\n        children.push(child);\n    }\n\n    if (space && recognizer.onWhiteSpace) {\n        recognizer.onWhiteSpace.call(this, null, children, context);\n    }\n\n    return children;\n};\n","import { List } from '../utils/List.js';\nimport { SyntaxError } from './SyntaxError.js';\nimport {\n    tokenize,\n    OffsetToLocation,\n    TokenStream,\n    tokenNames,\n\n    consumeNumber,\n    findWhiteSpaceStart,\n    cmpChar,\n    cmpStr,\n\n    WhiteSpace,\n    Comment,\n    Ident,\n    Function as FunctionToken,\n    Url,\n    Hash,\n    Percentage,\n    Number as NumberToken\n} from '../tokenizer/index.js';\nimport { readSequence } from './sequence.js';\n\nconst NOOP = () => {};\nconst EXCLAMATIONMARK = 0x0021;  // U+0021 EXCLAMATION MARK (!)\nconst NUMBERSIGN = 0x0023;       // U+0023 NUMBER SIGN (#)\nconst SEMICOLON = 0x003B;        // U+003B SEMICOLON (;)\nconst LEFTCURLYBRACKET = 0x007B; // U+007B LEFT CURLY BRACKET ({)\nconst NULL = 0;\n\nfunction createParseContext(name) {\n    return function() {\n        return this[name]();\n    };\n}\n\nfunction fetchParseValues(dict) {\n    const result = Object.create(null);\n\n    for (const name of Object.keys(dict)) {\n        const item = dict[name];\n        const fn = item.parse || item;\n\n        if (fn) {\n            result[name] = fn;\n        }\n    }\n\n    return result;\n}\n\nfunction processConfig(config) {\n    const parseConfig = {\n        context: Object.create(null),\n        features: Object.assign(Object.create(null), config.features),\n        scope: Object.assign(Object.create(null), config.scope),\n        atrule: fetchParseValues(config.atrule),\n        pseudo: fetchParseValues(config.pseudo),\n        node: fetchParseValues(config.node)\n    };\n\n    for (const [name, context] of Object.entries(config.parseContext)) {\n        switch (typeof context) {\n            case 'function':\n                parseConfig.context[name] = context;\n                break;\n\n            case 'string':\n                parseConfig.context[name] = createParseContext(context);\n                break;\n        }\n    }\n\n    return {\n        config: parseConfig,\n        ...parseConfig,\n        ...parseConfig.node\n    };\n}\n\nexport function createParser(config) {\n    let source = '';\n    let filename = '<unknown>';\n    let needPositions = false;\n    let onParseError = NOOP;\n    let onParseErrorThrow = false;\n\n    const locationMap = new OffsetToLocation();\n    const parser = Object.assign(new TokenStream(), processConfig(config || {}), {\n        parseAtrulePrelude: true,\n        parseRulePrelude: true,\n        parseValue: true,\n        parseCustomProperty: false,\n\n        readSequence,\n\n        consumeUntilBalanceEnd: () => 0,\n        consumeUntilLeftCurlyBracket(code) {\n            return code === LEFTCURLYBRACKET ? 1 : 0;\n        },\n        consumeUntilLeftCurlyBracketOrSemicolon(code) {\n            return code === LEFTCURLYBRACKET || code === SEMICOLON ? 1 : 0;\n        },\n        consumeUntilExclamationMarkOrSemicolon(code) {\n            return code === EXCLAMATIONMARK || code === SEMICOLON ? 1 : 0;\n        },\n        consumeUntilSemicolonIncluded(code) {\n            return code === SEMICOLON ? 2 : 0;\n        },\n\n        createList() {\n            return new List();\n        },\n        createSingleNodeList(node) {\n            return new List().appendData(node);\n        },\n        getFirstListNode(list) {\n            return list && list.first;\n        },\n        getLastListNode(list) {\n            return list && list.last;\n        },\n\n        parseWithFallback(consumer, fallback) {\n            const startIndex = this.tokenIndex;\n\n            try {\n                return consumer.call(this);\n            } catch (e) {\n                if (onParseErrorThrow) {\n                    throw e;\n                }\n\n                this.skip(startIndex - this.tokenIndex);\n                const fallbackNode = fallback.call(this);\n\n                onParseErrorThrow = true;\n                onParseError(e, fallbackNode);\n                onParseErrorThrow = false;\n\n                return fallbackNode;\n            }\n        },\n\n        lookupNonWSType(offset) {\n            let type;\n\n            do {\n                type = this.lookupType(offset++);\n                if (type !== WhiteSpace && type !== Comment) {\n                    return type;\n                }\n            } while (type !== NULL);\n\n            return NULL;\n        },\n\n        charCodeAt(offset) {\n            return offset >= 0 && offset < source.length ? source.charCodeAt(offset) : 0;\n        },\n        substring(offsetStart, offsetEnd) {\n            return source.substring(offsetStart, offsetEnd);\n        },\n        substrToCursor(start) {\n            return this.source.substring(start, this.tokenStart);\n        },\n\n        cmpChar(offset, charCode) {\n            return cmpChar(source, offset, charCode);\n        },\n        cmpStr(offsetStart, offsetEnd, str) {\n            return cmpStr(source, offsetStart, offsetEnd, str);\n        },\n\n        consume(tokenType) {\n            const start = this.tokenStart;\n\n            this.eat(tokenType);\n\n            return this.substrToCursor(start);\n        },\n        consumeFunctionName() {\n            const name = source.substring(this.tokenStart, this.tokenEnd - 1);\n\n            this.eat(FunctionToken);\n\n            return name;\n        },\n        consumeNumber(type) {\n            const number = source.substring(this.tokenStart, consumeNumber(source, this.tokenStart));\n\n            this.eat(type);\n\n            return number;\n        },\n\n        eat(tokenType) {\n            if (this.tokenType !== tokenType) {\n                const tokenName = tokenNames[tokenType].slice(0, -6).replace(/-/g, ' ').replace(/^./, m => m.toUpperCase());\n                let message = `${/[[\\](){}]/.test(tokenName) ? `\"${tokenName}\"` : tokenName} is expected`;\n                let offset = this.tokenStart;\n\n                // tweak message and offset\n                switch (tokenType) {\n                    case Ident:\n                        // when identifier is expected but there is a function or url\n                        if (this.tokenType === FunctionToken || this.tokenType === Url) {\n                            offset = this.tokenEnd - 1;\n                            message = 'Identifier is expected but function found';\n                        } else {\n                            message = 'Identifier is expected';\n                        }\n                        break;\n\n                    case Hash:\n                        if (this.isDelim(NUMBERSIGN)) {\n                            this.next();\n                            offset++;\n                            message = 'Name is expected';\n                        }\n                        break;\n\n                    case Percentage:\n                        if (this.tokenType === NumberToken) {\n                            offset = this.tokenEnd;\n                            message = 'Percent sign is expected';\n                        }\n                        break;\n                }\n\n                this.error(message, offset);\n            }\n\n            this.next();\n        },\n        eatIdent(name) {\n            if (this.tokenType !== Ident || this.lookupValue(0, name) === false) {\n                this.error(`Identifier \"${name}\" is expected`);\n            }\n\n            this.next();\n        },\n        eatDelim(code) {\n            if (!this.isDelim(code)) {\n                this.error(`Delim \"${String.fromCharCode(code)}\" is expected`);\n            }\n\n            this.next();\n        },\n\n        getLocation(start, end) {\n            if (needPositions) {\n                return locationMap.getLocationRange(\n                    start,\n                    end,\n                    filename\n                );\n            }\n\n            return null;\n        },\n        getLocationFromList(list) {\n            if (needPositions) {\n                const head = this.getFirstListNode(list);\n                const tail = this.getLastListNode(list);\n                return locationMap.getLocationRange(\n                    head !== null ? head.loc.start.offset - locationMap.startOffset : this.tokenStart,\n                    tail !== null ? tail.loc.end.offset - locationMap.startOffset : this.tokenStart,\n                    filename\n                );\n            }\n\n            return null;\n        },\n\n        error(message, offset) {\n            const location = typeof offset !== 'undefined' && offset < source.length\n                ? locationMap.getLocation(offset)\n                : this.eof\n                    ? locationMap.getLocation(findWhiteSpaceStart(source, source.length - 1))\n                    : locationMap.getLocation(this.tokenStart);\n\n            throw new SyntaxError(\n                message || 'Unexpected input',\n                source,\n                location.offset,\n                location.line,\n                location.column,\n                locationMap.startLine,\n                locationMap.startColumn\n            );\n        }\n    });\n\n    const parse = function(source_, options) {\n        source = source_;\n        options = options || {};\n\n        parser.setSource(source, tokenize);\n        locationMap.setSource(\n            source,\n            options.offset,\n            options.line,\n            options.column\n        );\n\n        filename = options.filename || '<unknown>';\n        needPositions = Boolean(options.positions);\n        onParseError = typeof options.onParseError === 'function' ? options.onParseError : NOOP;\n        onParseErrorThrow = false;\n\n        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;\n        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;\n        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;\n        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;\n\n        const { context = 'default', onComment } = options;\n\n        if (context in parser.context === false) {\n            throw new Error('Unknown context `' + context + '`');\n        }\n\n        if (typeof onComment === 'function') {\n            parser.forEachToken((type, start, end) => {\n                if (type === Comment) {\n                    const loc = parser.getLocation(start, end);\n                    const value = cmpStr(source, end - 2, end, '*/')\n                        ? source.slice(start + 2, end - 2)\n                        : source.slice(start + 2, end);\n\n                    onComment(value, loc);\n                }\n            });\n        }\n\n        const ast = parser.context[context].call(parser, options);\n\n        if (!parser.eof) {\n            parser.error();\n        }\n\n        return ast;\n    };\n\n    return Object.assign(parse, {\n        SyntaxError,\n        config: parser.config\n    });\n};\n","import {\n    Ident,\n    String as StringToken,\n    Number as NumberToken,\n    Function as FunctionToken,\n    Url,\n    Hash,\n    Dimension,\n    Percentage,\n    LeftParenthesis,\n    LeftSquareBracket,\n    Comma,\n    Delim\n} from '../../tokenizer/index.js';\n\nconst NUMBERSIGN = 0x0023;  // U+0023 NUMBER SIGN (#)\nconst ASTERISK = 0x002A;    // U+002A ASTERISK (*)\nconst PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)\nconst HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)\nconst SOLIDUS = 0x002F;     // U+002F SOLIDUS (/)\nconst U = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)\n\nexport default function defaultRecognizer(context) {\n    switch (this.tokenType) {\n        case Hash:\n            return this.Hash();\n\n        case Comma:\n            return this.Operator();\n\n        case LeftParenthesis:\n            return this.Parentheses(this.readSequence, context.recognizer);\n\n        case LeftSquareBracket:\n            return this.Brackets(this.readSequence, context.recognizer);\n\n        case StringToken:\n            return this.String();\n\n        case Dimension:\n            return this.Dimension();\n\n        case Percentage:\n            return this.Percentage();\n\n        case NumberToken:\n            return this.Number();\n\n        case FunctionToken:\n            return this.cmpStr(this.tokenStart, this.tokenEnd, 'url(')\n                ? this.Url()\n                : this.Function(this.readSequence, context.recognizer);\n\n        case Url:\n            return this.Url();\n\n        case Ident:\n            // check for unicode range, it should start with u+ or U+\n            if (this.cmpChar(this.tokenStart, U) &&\n                this.cmpChar(this.tokenStart + 1, PLUSSIGN)) {\n                return this.UnicodeRange();\n            } else {\n                return this.Identifier();\n            }\n\n        case Delim: {\n            const code = this.charCodeAt(this.tokenStart);\n\n            if (code === SOLIDUS ||\n                code === ASTERISK ||\n                code === PLUSSIGN ||\n                code === HYPHENMINUS) {\n                return this.Operator(); // TODO: replace with Delim\n            }\n\n            // TODO: produce a node with Delim node type\n\n            if (code === NUMBERSIGN) {\n                this.error('Hex or identifier is expected', this.tokenStart + 1);\n            }\n\n            break;\n        }\n    }\n};\n","import getNode from './default.js';\n\nexport default {\n    getNode\n};\n","import {\n    Delim,\n    Ident,\n    Dimension,\n    Percentage,\n    Number as NumberToken,\n    Hash,\n    Colon,\n    LeftSquareBracket\n} from '../../tokenizer/index.js';\n\nconst NUMBERSIGN = 0x0023;      // U+0023 NUMBER SIGN (#)\nconst AMPERSAND = 0x0026;       // U+0026 AMPERSAND (&)\nconst ASTERISK = 0x002A;        // U+002A ASTERISK (*)\nconst PLUSSIGN = 0x002B;        // U+002B PLUS SIGN (+)\nconst SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)\nconst FULLSTOP = 0x002E;        // U+002E FULL STOP (.)\nconst GREATERTHANSIGN = 0x003E; // U+003E GREATER-THAN SIGN (>)\nconst VERTICALLINE = 0x007C;    // U+007C VERTICAL LINE (|)\nconst TILDE = 0x007E;           // U+007E TILDE (~)\n\nfunction onWhiteSpace(next, children) {\n    if (children.last !== null && children.last.type !== 'Combinator' &&\n        next !== null && next.type !== 'Combinator') {\n        children.push({  // FIXME: this.Combinator() should be used instead\n            type: 'Combinator',\n            loc: null,\n            name: ' '\n        });\n    }\n}\n\nfunction getNode() {\n    switch (this.tokenType) {\n        case LeftSquareBracket:\n            return this.AttributeSelector();\n\n        case Hash:\n            return this.IdSelector();\n\n        case Colon:\n            if (this.lookupType(1) === Colon) {\n                return this.PseudoElementSelector();\n            } else {\n                return this.PseudoClassSelector();\n            }\n\n        case Ident:\n            return this.TypeSelector();\n\n        case NumberToken:\n        case Percentage:\n            return this.Percentage();\n\n        case Dimension:\n            // throws when .123ident\n            if (this.charCodeAt(this.tokenStart) === FULLSTOP) {\n                this.error('Identifier is expected', this.tokenStart + 1);\n            }\n            break;\n\n        case Delim: {\n            const code = this.charCodeAt(this.tokenStart);\n\n            switch (code) {\n                case PLUSSIGN:\n                case GREATERTHANSIGN:\n                case TILDE:\n                case SOLIDUS:  // /deep/\n                    return this.Combinator();\n\n                case FULLSTOP:\n                    return this.ClassSelector();\n\n                case ASTERISK:\n                case VERTICALLINE:\n                    return this.TypeSelector();\n\n                case NUMBERSIGN:\n                    return this.IdSelector();\n\n                case AMPERSAND:\n                    return this.NestingSelector();\n            }\n\n            break;\n        }\n    }\n};\n\nexport default {\n    onWhiteSpace,\n    getNode\n};\n","// legacy IE function\n// expression( <any-value> )\nexport default function() {\n    return this.createSingleNodeList(\n        this.Raw(null, false)\n    );\n}\n","import { Comma, WhiteSpace } from '../../tokenizer/index.js';\n\n// var( <ident> , <value>? )\nexport default function() {\n    const children = this.createList();\n\n    this.skipSC();\n\n    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer\n    children.push(this.Identifier());\n\n    this.skipSC();\n\n    if (this.tokenType === Comma) {\n        children.push(this.Operator());\n\n        const startIndex = this.tokenIndex;\n        const value = this.parseCustomProperty\n            ? this.Value(null)\n            : this.Raw(this.consumeUntilExclamationMarkOrSemicolon, false);\n\n        if (value.type === 'Value' && value.children.isEmpty) {\n            for (let offset = startIndex - this.tokenIndex; offset <= 0; offset++) {\n                if (this.lookupType(offset) === WhiteSpace) {\n                    value.children.appendData({\n                        type: 'WhiteSpace',\n                        loc: null,\n                        value: ' '\n                    });\n                    break;\n                }\n            }\n        }\n\n        children.push(value);\n    }\n\n    return children;\n};\n","import getNode from './default.js';\nimport expressionFn from '../function/expression.js';\nimport varFn from '../function/var.js';\n\nfunction isPlusMinusOperator(node) {\n    return (\n        node !== null &&\n        node.type === 'Operator' &&\n        (node.value[node.value.length - 1] === '-' || node.value[node.value.length - 1] === '+')\n    );\n}\n\nexport default {\n    getNode,\n    onWhiteSpace(next, children) {\n        if (isPlusMinusOperator(next)) {\n            next.value = ' ' + next.value;\n        }\n        if (isPlusMinusOperator(children.last)) {\n            children.last.value += ' ';\n        }\n    },\n    'expression': expressionFn,\n    'var': varFn\n};\n","import { Ident } from '../../tokenizer/index.js';\n\n// https://drafts.csswg.org/css-contain-3/#container-rule\n// The keywords `none`, `and`, `not`, and `or` are excluded from the <custom-ident> above.\nconst nonContainerNameKeywords = new Set(['none', 'and', 'not', 'or']);\n\nexport default {\n    parse: {\n        prelude() {\n            const children = this.createList();\n\n            if (this.tokenType === Ident) {\n                const name = this.substring(this.tokenStart, this.tokenEnd);\n\n                if (!nonContainerNameKeywords.has(name.toLowerCase())) {\n                    children.push(this.Identifier());\n                }\n            }\n\n            children.push(this.Condition('container'));\n\n            return children;\n        },\n        block(nested = false) {\n            return this.Block(nested);\n        }\n    }\n};\n","export default {\n    parse: {\n        prelude: null,\n        block() {\n            return this.Block(true);\n        }\n    }\n};\n","import {\n    String as StringToken,\n    Ident,\n    Url,\n    Function as FunctionToken,\n    LeftParenthesis,\n    RightParenthesis\n} from '../../tokenizer/index.js';\n\nfunction parseWithFallback(parse, fallback) {\n    return this.parseWithFallback(\n        () => {\n            try {\n                return parse.call(this);\n            } finally {\n                this.skipSC();\n                if (this.lookupNonWSType(0) !== RightParenthesis) {\n                    this.error();\n                }\n            }\n        },\n        fallback || (() => this.Raw(null, true))\n    );\n}\n\nconst parseFunctions = {\n    layer() {\n        this.skipSC();\n\n        const children = this.createList();\n        const node = parseWithFallback.call(this, this.Layer);\n\n        if (node.type !== 'Raw' || node.value !== '') {\n            children.push(node);\n        }\n\n        return children;\n    },\n    supports() {\n        this.skipSC();\n\n        const children = this.createList();\n        const node = parseWithFallback.call(\n            this,\n            this.Declaration,\n            () => parseWithFallback.call(this, () => this.Condition('supports'))\n        );\n\n        if (node.type !== 'Raw' || node.value !== '') {\n            children.push(node);\n        }\n\n        return children;\n    }\n};\n\nexport default {\n    parse: {\n        prelude() {\n            const children = this.createList();\n\n            switch (this.tokenType) {\n                case StringToken:\n                    children.push(this.String());\n                    break;\n\n                case Url:\n                case FunctionToken:\n                    children.push(this.Url());\n                    break;\n\n                default:\n                    this.error('String or url() is expected');\n            }\n\n            this.skipSC();\n\n            if (this.tokenType === Ident &&\n                this.cmpStr(this.tokenStart, this.tokenEnd, 'layer')) {\n                children.push(this.Identifier());\n            } else if (\n                this.tokenType === FunctionToken &&\n                this.cmpStr(this.tokenStart, this.tokenEnd, 'layer(')\n            ) {\n                children.push(this.Function(null, parseFunctions));\n            }\n\n            this.skipSC();\n\n            if (this.tokenType === FunctionToken &&\n                this.cmpStr(this.tokenStart, this.tokenEnd, 'supports(')) {\n                children.push(this.Function(null, parseFunctions));\n            }\n\n            if (this.lookupNonWSType(0) === Ident ||\n                this.lookupNonWSType(0) === LeftParenthesis) {\n                children.push(this.MediaQueryList());\n            }\n\n            return children;\n        },\n        block: null\n    }\n};\n","import container from './container.js';\nimport fontFace from './font-face.js';\nimport importAtrule from './import.js';\nimport layer from './layer.js';\nimport media from './media.js';\nimport nest from './nest.js';\nimport page from './page.js';\nimport scope from './scope.js';\nimport startingStyle from './starting-style.js';\nimport supports from './supports.js';\n\nexport default {\n    container,\n    'font-face': fontFace,\n    import: importAtrule,\n    layer,\n    media,\n    nest,\n    page,\n    scope,\n    'starting-style': startingStyle,\n    supports\n};\n","export default {\n    parse: {\n        prelude() {\n            return this.createSingleNodeList(\n                this.LayerList()\n            );\n        },\n        block() {\n            return this.Block(false);\n        }\n    }\n};\n","export default {\n    parse: {\n        prelude() {\n            return this.createSingleNodeList(\n                this.MediaQueryList()\n            );\n        },\n        block(nested = false) {\n            return this.Block(nested);\n        }\n    }\n};\n","export default {\n    parse: {\n        prelude() {\n            return this.createSingleNodeList(\n                this.SelectorList()\n            );\n        },\n        block() {\n            return this.Block(true);\n        }\n    }\n};\n","export default {\n    parse: {\n        prelude() {\n            return this.createSingleNodeList(\n                this.SelectorList()\n            );\n        },\n        block() {\n            return this.Block(true);\n        }\n    }\n};\n","export default {\n    parse: {\n        prelude() {\n            return this.createSingleNodeList(\n                this.Scope()\n            );\n        },\n        block(nested = false) {\n            return this.Block(nested);\n        }\n    }\n};\n","export default {\n    parse: {\n        prelude: null,\n        block(nested = false) {\n            return this.Block(nested);\n        }\n    }\n};\n","export default {\n    parse: {\n        prelude() {\n            return this.createSingleNodeList(\n                this.Condition('supports')\n            );\n        },\n        block(nested = false) {\n            return this.Block(nested);\n        }\n    }\n};\n","import { Comma, String as StringToken, Ident, RightParenthesis } from '../../tokenizer/index.js';\n\nexport function parseLanguageRangeList() {\n    const children = this.createList();\n\n    this.skipSC();\n\n    loop: while (!this.eof) {\n        switch (this.tokenType) {\n            case Ident:\n                children.push(this.Identifier());\n                break;\n\n            case StringToken:\n                children.push(this.String());\n                break;\n\n            case Comma:\n                children.push(this.Operator());\n                break;\n\n            case RightParenthesis:\n                break loop;\n\n            default:\n                this.error('Identifier, string or comma is expected');\n        }\n\n        this.skipSC();\n    }\n\n    return children;\n}\n","import { parseLanguageRangeList } from './lang.js';\n\nconst selectorList = {\n    parse() {\n        return this.createSingleNodeList(\n            this.SelectorList()\n        );\n    }\n};\n\nconst selector = {\n    parse() {\n        return this.createSingleNodeList(\n            this.Selector()\n        );\n    }\n};\n\nconst identList = {\n    parse() {\n        return this.createSingleNodeList(\n            this.Identifier()\n        );\n    }\n};\n\nconst langList = {\n    parse: parseLanguageRangeList\n};\n\nconst nth = {\n    parse() {\n        return this.createSingleNodeList(\n            this.Nth()\n        );\n    }\n};\n\nexport default {\n    'dir': identList,\n    'has': selectorList,\n    'lang': langList,\n    'matches': selectorList,\n    'is': selectorList,\n    '-moz-any': selectorList,\n    '-webkit-any': selectorList,\n    'where': selectorList,\n    'not': selectorList,\n    'nth-child': nth,\n    'nth-last-child': nth,\n    'nth-last-of-type': nth,\n    'nth-of-type': nth,\n    'slotted': selector,\n    'host': selector,\n    'host-context': selector\n};\n","import { createParser } from './create.js';\nimport config from '../syntax/config/parser.js';\n\nexport default createParser(config);\n","import * as scope from '../scope/index.js';\nimport atrule from '../atrule/index.js';\nimport pseudo from '../pseudo/index.js';\nimport * as node from '../node/index-parse.js';\n\nexport default {\n    parseContext: {\n        default: 'StyleSheet',\n        stylesheet: 'StyleSheet',\n        atrule: 'Atrule',\n        atrulePrelude(options) {\n            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);\n        },\n        mediaQueryList: 'MediaQueryList',\n        mediaQuery: 'MediaQuery',\n        condition(options) {\n            return this.Condition(options.kind);\n        },\n        rule: 'Rule',\n        selectorList: 'SelectorList',\n        selector: 'Selector',\n        block() {\n            return this.Block(true);\n        },\n        declarationList: 'DeclarationList',\n        declaration: 'Declaration',\n        value: 'Value'\n    },\n    features: {\n        supports: {\n            selector() {\n                return this.Selector();\n            }\n        },\n        container: {\n            style() {\n                return this.Declaration();\n            }\n        }\n    },\n    scope,\n    atrule,\n    pseudo,\n    node\n};\n","import { List } from './List.js';\n\nexport function clone(node) {\n    const result = {};\n\n    for (const key of Object.keys(node)) {\n        let value = node[key];\n\n        if (value) {\n            if (Array.isArray(value) || value instanceof List) {\n                value = value.map(clone);\n            } else if (value.constructor === Object) {\n                value = clone(value);\n            }\n        }\n\n        result[key] = value;\n    }\n\n    return result;\n}\n","/* @ts-self-types=\"./index.d.ts\" */\nlet urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nexport let customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size | 0\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let i = size | 0\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\n","import type {\n  CssNode,\n  Declaration,\n  FunctionNode,\n  Identifier,\n  List,\n  Selector as CssTreeSelector,\n  SelectorList,\n  SyntaxParseError,\n  Value,\n} from 'css-tree';\nimport generate from 'css-tree/generator';\nimport parse from 'css-tree/parser';\nimport { clone } from 'css-tree/utils';\nimport { nanoid } from 'nanoid/non-secure';\n\nimport type { Selector } from './dom.js';\n\nexport const INSTANCE_UUID = nanoid();\n\n/** Singleton to hold CSS parse errors in case polyfill fails.\n *\n * Not included in the store in parse.ts, as it has a different lifecycle.\n */\nexport const cssParseErrors = new Set() as Set<SyntaxParseError>;\n\n// https://github.com/import-js/eslint-plugin-import/issues/3019\n\nexport interface DeclarationWithValue extends Declaration {\n  value: Value;\n}\n\nexport function isAnchorFunction(node: CssNode | null): node is FunctionNode {\n  return Boolean(node && node.type === 'Function' && node.name === 'anchor');\n}\n/**\n * @param cssText\n * @param captureErrors `true` only on the initial parse of CSS before the\n * polyfill changes it\n */\nexport function getAST(cssText: string, captureErrors = false) {\n  return parse(cssText, {\n    parseAtrulePrelude: false,\n    parseCustomProperty: true,\n    onParseError: (err) => {\n      if (captureErrors) cssParseErrors.add(err);\n    },\n  });\n}\n\nexport function generateCSS(ast: CssNode) {\n  return generate(ast, {\n    // Default `safe` adds extra (potentially breaking) spaces for compatibility\n    // with old browsers.\n    mode: 'spec',\n  });\n}\n\nexport function isDeclaration(node: CssNode): node is DeclarationWithValue {\n  return node.type === 'Declaration';\n}\n\nexport function getDeclarationValue(node: DeclarationWithValue) {\n  return (node.value.children.first as Identifier).name;\n}\n\nexport interface StyleData {\n  el: HTMLElement;\n  css: string;\n  url?: URL;\n  changed?: boolean;\n  created?: boolean; // Whether the element is created by the polyfill\n}\n\nexport const POSITION_ANCHOR_PROPERTY = `--position-anchor-${INSTANCE_UUID}`;\n\nexport function splitCommaList(list: List<CssNode>) {\n  return list.toArray().reduce(\n    (acc: Identifier[][], child) => {\n      if (child.type === 'Operator' && child.value === ',') {\n        acc.push([]);\n        return acc;\n      }\n      if (child.type === 'Identifier') {\n        acc[acc.length - 1].push(child);\n      }\n\n      return acc;\n    },\n    [[]],\n  );\n}\n\nexport function getSelectors(rule: SelectorList | undefined) {\n  if (!rule) return [];\n\n  return (rule.children as List<CssTreeSelector>)\n    .map((selector) => {\n      let pseudoElementPart: string | undefined;\n\n      if (selector.children.last?.type === 'PseudoElementSelector') {\n        selector = clone(selector) as CssTreeSelector;\n        pseudoElementPart = generateCSS(selector.children.last!);\n        selector.children.pop();\n      }\n\n      const elementPart = generateCSS(selector);\n\n      return {\n        selector: elementPart + (pseudoElementPart ?? ''),\n        elementPart,\n        pseudoElementPart,\n      } satisfies Selector;\n    })\n    .toArray();\n}\n\nexport function reportParseErrorsOnFailure() {\n  if (cssParseErrors.size > 0) {\n    // eslint-disable-next-line no-console\n    console.group(\n      `The CSS anchor positioning polyfill was not applied due to ${\n        cssParseErrors.size === 1 ? 'a CSS parse error' : 'CSS parse errors'\n      }.`,\n    );\n    cssParseErrors.forEach((err) => {\n      // eslint-disable-next-line no-console\n      console.warn(err.formattedMessage);\n    });\n    // eslint-disable-next-line no-console\n    console.groupEnd();\n  }\n}\n\nexport function resetParseErrors() {\n  cssParseErrors.clear();\n}\n","import type { Block, CssNode } from 'css-tree';\nimport walk from 'css-tree/walker';\n\nimport { ACCEPTED_POSITION_TRY_PROPERTIES } from './syntax.js';\nimport {\n  generateCSS,\n  getAST,\n  INSTANCE_UUID,\n  isDeclaration,\n  type StyleData,\n} from './utils.js';\n\n/**\n * Map of CSS property to CSS custom property that the property's value is\n * shifted into. This is used to subject properties that are not yet natively\n * supported to the CSS cascade and inheritance rules. It is also used by the\n * fallback algorithm to find initial, non-computed values.\n */\nexport const SHIFTED_PROPERTIES: Record<string, string> = [\n  ...ACCEPTED_POSITION_TRY_PROPERTIES,\n  'anchor-scope',\n  'anchor-name',\n].reduce(\n  (acc, prop) => {\n    acc[prop] = `--${prop}-${INSTANCE_UUID}`;\n    return acc;\n  },\n  {} as Record<string, string>,\n);\n\n/**\n * Shift property declarations for properties that are not yet natively\n * supported into custom properties.\n */\nfunction shiftUnsupportedProperties(node: CssNode, block?: Block) {\n  if (isDeclaration(node) && SHIFTED_PROPERTIES[node.property] && block) {\n    block.children.appendData({\n      ...node,\n      property: SHIFTED_PROPERTIES[node.property],\n    });\n    return { updated: true };\n  }\n  return {};\n}\n\n/**\n * Update the given style data to enable cascading and inheritance of properties\n * that are not yet natively supported.\n */\nexport function cascadeCSS(styleData: StyleData[]) {\n  for (const styleObj of styleData) {\n    let changed = false;\n    const ast = getAST(styleObj.css, true);\n    walk(ast, {\n      visit: 'Declaration',\n      enter(node) {\n        const block = this.rule?.block;\n        const { updated } = shiftUnsupportedProperties(node, block);\n        if (updated) {\n          changed = true;\n        }\n      },\n    });\n\n    if (changed) {\n      // Update CSS\n      styleObj.css = generateCSS(ast);\n      styleObj.changed = true;\n    }\n  }\n  return styleData.some((styleObj) => styleObj.changed === true);\n}\n","import { platform, type VirtualElement } from '@floating-ui/dom';\nimport { nanoid } from 'nanoid/non-secure';\n\nimport { SHIFTED_PROPERTIES } from './cascade.js';\n\n/**\n * Representation of a CSS selector that allows getting the element part and\n * pseudo-element part.\n */\nexport interface Selector {\n  selector: string;\n  elementPart: string;\n  pseudoElementPart?: string;\n}\n\n/**\n * Used instead of an HTMLElement as a handle for pseudo-elements.\n */\nexport interface PseudoElement extends VirtualElement {\n  fakePseudoElement: HTMLElement;\n  computedStyle: CSSStyleDeclaration;\n  removeFakePseudoElement(): void;\n}\n\n/**\n * Possible values for `anchor-scope`\n * (in addition to any valid dashed identifier)\n */\nexport const enum AnchorScopeValue {\n  All = 'all',\n  None = 'none',\n}\n\n/**\n * Gets the computed value of a CSS property for an element or pseudo-element.\n *\n * Note: values for properties that are not natively supported are *always*\n * subject to CSS inheritance.\n */\nexport function getCSSPropertyValue(\n  el: HTMLElement | PseudoElement,\n  prop: string,\n) {\n  prop = SHIFTED_PROPERTIES[prop] ?? prop;\n  const computedStyle =\n    el instanceof HTMLElement ? getComputedStyle(el) : el.computedStyle;\n  return computedStyle.getPropertyValue(prop).trim();\n}\n\n/**\n * Checks whether a given element or pseudo-element has the given property\n * value.\n *\n * Note: values for properties that are not natively supported are *always*\n * subject to CSS inheritance.\n */\nexport function hasStyle(\n  element: HTMLElement | PseudoElement,\n  cssProperty: string,\n  value: string,\n) {\n  return getCSSPropertyValue(element, cssProperty) === value;\n}\n\n/**\n * Creates a DOM element to use in place of a pseudo-element.\n */\nfunction createFakePseudoElement(\n  element: HTMLElement,\n  { selector, pseudoElementPart }: Selector,\n) {\n  // Floating UI needs `Element.getBoundingClientRect` to calculate the position\n  // for the anchored element, since there isn't a way to get it for\n  // pseudo-elements; we create a temporary \"fake pseudo-element\" that we use as\n  // reference.\n  const computedStyle = getComputedStyle(element, pseudoElementPart);\n  const fakePseudoElement = document.createElement('div');\n  const sheet = document.createElement('style');\n\n  fakePseudoElement.id = `fake-pseudo-element-${nanoid()}`;\n\n  // Copy styles from pseudo-element to the \"fake pseudo-element\", `.cssText`\n  // does not work on Firefox.\n  for (const property of Array.from(computedStyle)) {\n    const value = computedStyle.getPropertyValue(property);\n    fakePseudoElement.style.setProperty(property, value);\n  }\n\n  // For the `content` property, since normal elements don't have it,\n  // we add the content to a pseudo-element of the \"fake pseudo-element\".\n  sheet.textContent += `#${fakePseudoElement.id}${pseudoElementPart} { content: ${computedStyle.content}; }`;\n  // Hide the pseudo-element while the \"fake pseudo-element\" is visible.\n  sheet.textContent += `${selector} { display: none !important; }`;\n\n  document.head.append(sheet);\n\n  const insertionPoint =\n    pseudoElementPart === '::before' ? 'afterbegin' : 'beforeend';\n  element.insertAdjacentElement(insertionPoint, fakePseudoElement);\n  return { fakePseudoElement, sheet, computedStyle };\n}\n\n/**\n * Finds the first scrollable parent of the given element\n * (or the element itself if the element is scrollable).\n */\nfunction findFirstScrollingElement(element: HTMLElement) {\n  let currentElement: HTMLElement | null = element;\n\n  while (currentElement) {\n    if (hasStyle(currentElement, 'overflow', 'scroll')) {\n      return currentElement;\n    }\n\n    currentElement = currentElement.parentElement;\n  }\n\n  return currentElement;\n}\n\n/**\n * Gets the scroll position of the first scrollable parent\n * (or the scroll position of the element itself, if it is scrollable).\n */\nfunction getContainerScrollPosition(element: HTMLElement) {\n  let containerScrollPosition: {\n    scrollTop: number;\n    scrollLeft: number;\n  } | null = findFirstScrollingElement(element);\n\n  // Avoid doubled scroll\n  if (containerScrollPosition === document.documentElement) {\n    containerScrollPosition = null;\n  }\n\n  return containerScrollPosition ?? { scrollTop: 0, scrollLeft: 0 };\n}\n\n/**\n * Like `document.querySelectorAll`, but if the selector has a pseudo-element it\n * will return a wrapper for the rest of the polyfill to use.\n */\nexport function getElementsBySelector(selector: Selector) {\n  const { elementPart, pseudoElementPart } = selector;\n  const result: (HTMLElement | PseudoElement)[] = [];\n  const isBefore = pseudoElementPart === '::before';\n  const isAfter = pseudoElementPart === '::after';\n\n  // Current we only support `::before` and `::after` pseudo-elements.\n  if (pseudoElementPart && !(isBefore || isAfter)) return result;\n\n  const elements = Array.from(\n    document.querySelectorAll<HTMLElement>(elementPart),\n  );\n\n  if (!pseudoElementPart) {\n    result.push(...elements);\n    return result;\n  }\n\n  for (const element of elements) {\n    const { fakePseudoElement, sheet, computedStyle } = createFakePseudoElement(\n      element,\n      selector,\n    );\n\n    const boundingClientRect = fakePseudoElement.getBoundingClientRect();\n    const { scrollY: startingScrollY, scrollX: startingScrollX } = globalThis;\n    const containerScrollPosition = getContainerScrollPosition(element);\n\n    result.push({\n      fakePseudoElement,\n      computedStyle,\n\n      removeFakePseudoElement() {\n        fakePseudoElement.remove();\n        sheet.remove();\n      },\n\n      // For https://floating-ui.com/docs/autoupdate#ancestorscroll to work on\n      // `VirtualElement`s.\n      contextElement: element,\n\n      // https://floating-ui.com/docs/virtual-elements\n      getBoundingClientRect() {\n        const { scrollY, scrollX } = globalThis;\n        const { scrollTop, scrollLeft } = containerScrollPosition;\n\n        return DOMRect.fromRect({\n          y:\n            boundingClientRect.y +\n            (startingScrollY - scrollY) +\n            (containerScrollPosition.scrollTop - scrollTop),\n          x:\n            boundingClientRect.x +\n            (startingScrollX - scrollX) +\n            (containerScrollPosition.scrollLeft - scrollLeft),\n\n          width: boundingClientRect.width,\n          height: boundingClientRect.height,\n        });\n      },\n    });\n  }\n\n  return result;\n}\n\n/**\n * Checks whether the given element has the given anchor name, based on the\n * element's computed style.\n *\n * Note: because our `--anchor-name` custom property inherits, this function\n * should only be called for elements which are known to have an explicitly set\n * value for `anchor-name`.\n */\nexport function hasAnchorName(\n  el: PseudoElement | HTMLElement,\n  anchorName: string | null,\n) {\n  const computedAnchorName = getCSSPropertyValue(el, 'anchor-name');\n  if (!anchorName) {\n    return !computedAnchorName;\n  }\n  return computedAnchorName\n    .split(',')\n    .map((name) => name.trim())\n    .includes(anchorName);\n}\n\n/**\n * Checks whether the given element serves as a scope for the given anchor.\n *\n * Note: because our `--anchor-scope` custom property inherits, this function\n * should only be called for elements which are known to have an explicitly set\n * value for `anchor-scope`.\n */\nexport function hasAnchorScope(\n  el: PseudoElement | HTMLElement,\n  anchorName: string,\n) {\n  const computedAnchorScope = getCSSPropertyValue(el, 'anchor-scope');\n  return (\n    computedAnchorScope === anchorName ||\n    computedAnchorScope === AnchorScopeValue.All\n  );\n}\n\nexport const getOffsetParent = async (el: HTMLElement) => {\n  let offsetParent = await platform.getOffsetParent?.(el);\n  if (!(await platform.isElement?.(offsetParent))) {\n    offsetParent =\n      (await platform.getDocumentElement?.(el)) ||\n      window.document.documentElement;\n  }\n  return offsetParent as HTMLElement;\n};\n","import { nanoid } from 'nanoid/non-secure';\n\nimport { type StyleData } from './utils.js';\n\nconst INVALID_MIME_TYPE_ERROR = 'InvalidMimeType';\n\nexport function isStyleLink(link: HTMLLinkElement): link is HTMLLinkElement {\n  return Boolean(\n    (link.type === 'text/css' || link.rel === 'stylesheet') && link.href,\n  );\n}\n\nfunction getStylesheetUrl(link: HTMLLinkElement): URL | undefined {\n  const srcUrl = new URL(link.href, document.baseURI);\n  if (isStyleLink(link) && srcUrl.origin === location.origin) {\n    return srcUrl;\n  }\n}\n\nasync function fetchLinkedStylesheets(\n  sources: Partial<StyleData>[],\n): Promise<StyleData[]> {\n  const results = await Promise.all(\n    sources.map(async (data) => {\n      if (!data.url) {\n        return data as StyleData;\n      }\n      // TODO: Add MutationObserver to watch for disabled links being enabled\n      // https://github.com/oddbird/css-anchor-positioning/issues/246\n      if ((data.el as HTMLLinkElement | undefined)?.disabled) {\n        // Do not fetch or parse disabled stylesheets\n        return null;\n      }\n      // fetch css and add to array\n      try {\n        const response = await fetch(data.url.toString());\n        const type = response.headers.get('content-type');\n        if (!type?.startsWith('text/css')) {\n          const error = new Error(\n            `Error loading ${data.url}: expected content-type \"text/css\", got \"${type}\".`,\n          );\n          error.name = INVALID_MIME_TYPE_ERROR;\n          throw error;\n        }\n        const css = await response.text();\n        return { ...data, css } as StyleData;\n      } catch (error) {\n        if (error instanceof Error && error.name === INVALID_MIME_TYPE_ERROR) {\n          // eslint-disable-next-line no-console\n          console.warn(error);\n          return null;\n        }\n        throw error;\n      }\n    }),\n  );\n  return results.filter((loaded) => loaded !== null);\n}\n\nconst ELEMENTS_WITH_INLINE_ANCHOR_STYLES_QUERY = '[style*=\"anchor\"]';\nconst ELEMENTS_WITH_INLINE_POSITION_AREA = '[style*=\"position-area\"]';\n// Searches for all elements with inline style attributes that include `anchor`.\n// For each element found, adds a new 'data-has-inline-styles' attribute with a\n// random UUID value, and then formats the styles in the same manner as CSS from\n// style tags.\nfunction fetchInlineStyles(elements?: HTMLElement[]) {\n  const elementsWithInlineAnchorStyles: HTMLElement[] = elements\n    ? elements.filter(\n        (el) =>\n          el instanceof HTMLElement &&\n          (el.matches(ELEMENTS_WITH_INLINE_ANCHOR_STYLES_QUERY) ||\n            el.matches(ELEMENTS_WITH_INLINE_POSITION_AREA)),\n      )\n    : Array.from(\n        document.querySelectorAll(\n          [\n            ELEMENTS_WITH_INLINE_ANCHOR_STYLES_QUERY,\n            ELEMENTS_WITH_INLINE_POSITION_AREA,\n          ].join(','),\n        ),\n      );\n  const inlineStyles: Partial<StyleData>[] = [];\n\n  elementsWithInlineAnchorStyles\n    .filter((el) => el instanceof HTMLElement)\n    .forEach((el) => {\n      const selector = nanoid(12);\n      const dataAttribute = 'data-has-inline-styles';\n      el.setAttribute(dataAttribute, selector);\n      const styles = el.getAttribute('style');\n      const css = `[${dataAttribute}=\"${selector}\"] { ${styles} }`;\n      inlineStyles.push({ el, css });\n    });\n\n  return inlineStyles;\n}\n\nexport async function fetchCSS(\n  elements?: HTMLElement[],\n  excludeInlineStyles?: boolean,\n): Promise<StyleData[]> {\n  const targetElements: HTMLElement[] =\n    elements ?? Array.from(document.querySelectorAll('link, style'));\n  const sources: Partial<StyleData>[] = [];\n\n  targetElements\n    .filter((el) => el instanceof HTMLElement)\n    .forEach((el) => {\n      if (el.tagName.toLowerCase() === 'link') {\n        const url = getStylesheetUrl(el as HTMLLinkElement);\n        if (url) {\n          sources.push({ el, url });\n        }\n      }\n      if (el.tagName.toLowerCase() === 'style') {\n        sources.push({ el, css: el.innerHTML });\n      }\n    });\n\n  const elementsForInlines = excludeInlineStyles ? (elements ?? []) : undefined;\n\n  const inlines = fetchInlineStyles(elementsForInlines);\n\n  return await fetchLinkedStylesheets([...sources, ...inlines]);\n}\n","export const urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\n","/* @ts-self-types=\"./index.d.ts\" */\nimport { urlAlphabet as scopedUrlAlphabet } from './url-alphabet/index.js'\nexport { urlAlphabet } from './url-alphabet/index.js'\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << Math.log2(alphabet.length - 1)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step | 0\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length >= size) return id\n      }\n    }\n  }\n}\nexport let customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size | 0, random)\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array((size |= 0)))\n  while (size--) {\n    id += scopedUrlAlphabet[bytes[size] & 63]\n  }\n  return id\n}\n","// How this works:\n\n// As we walk the AST, we parse each `position-area` declaration, and determine\n// how it would be applied. We store a selectorUUID for each declaration, and\n// add a custom property to the selector's block called `--pa-cascade-property`.\n// When we apply the polyfill, we check the value of `--pa-cascade-property` on\n// the target to determine which declaration should win and apply those rules.\n\n// Because each declaration may apply to multiple targets, and the generated\n// containing block for each target may be different, we create a targetUUID for\n// each element targeted by a selector. This is the UUID that is used to\n// generate the inset and alignment values in polyfill.ts that are applied to\n// the root element.\n\n// The rules are created in a new stylesheet that matches the selectorUUID that\n// won the cascade and the targetUUID. This stylesheet maps the properties set\n// on the root element to `--pa-value-*:`.\n\n// Each target is wrapped with a `polyfill-position-area` element. It sets its\n// inset values from `--pa-value-*` values. The `justify-self` and `align-self`\n// properties are mapped on the element itself.\n\nimport { type Block, type CssNode, type Identifier } from 'css-tree';\nimport { type List } from 'css-tree/utils';\nimport { nanoid } from 'nanoid';\n\nimport { getOffsetParent, type PseudoElement } from './dom.js';\nimport { type DeclarationWithValue } from './utils.js';\n\n// Set this value on a target as a sibling to a position area declaration. Then\n// check it to determine which position area declaration should win, if there\n// are multiple.\nexport const POSITION_AREA_CASCADE_PROPERTY = '--pa-cascade-property';\n\n// Set this as an attribute on a wrapper with the uuid of the winning\n// `POSITION_AREA_CASCADE_PROPERTY` as the value.\nexport const POSITION_AREA_WRAPPER_ATTRIBUTE = 'data-anchor-position-wrapper';\n\nconst WRAPPER_TARGET_ATTRIBUTE_PRELUDE = 'data-pa-wrapper-for-';\nconst WRAPPER_ELEMENT = 'POLYFILL-POSITION-AREA';\n\ntype PositionAreaGridValue = 0 | 1 | 2 | 3;\n\nenum WritingMode {\n  Logical = 'Logical',\n  LogicalSelf = 'LogicalSelf',\n  Physical = 'Physical',\n  PhysicalSelf = 'PhysicalSelf',\n  Irrelevant = 'Irrelevant',\n}\n\nexport const POSITION_AREA_PROPS = [\n  'left',\n  'center',\n  'right',\n  'span-left',\n  'span-right',\n  'x-start',\n  'x-end',\n  'span-x-start',\n  'span-x-end',\n  'x-self-start',\n  'x-self-end',\n  'span-x-self-start',\n  'span-x-self-end',\n  'span-all',\n  'top',\n  'bottom',\n  'span-top',\n  'span-bottom',\n  'y-start',\n  'y-end',\n  'span-y-start',\n  'span-y-end',\n  'y-self-start',\n  'y-self-end',\n  'span-y-self-start',\n  'span-y-self-end',\n  'block-start',\n  'block-end',\n  'span-block-start',\n  'span-block-end',\n  'inline-start',\n  'inline-end',\n  'span-inline-start',\n  'span-inline-end',\n  'self-block-start',\n  'self-block-end',\n  'span-self-block-start',\n  'span-self-block-end',\n  'self-inline-start',\n  'self-inline-end',\n  'span-self-inline-start',\n  'span-self-inline-end',\n  'start',\n  'end',\n  'span-start',\n  'span-end',\n  'self-start',\n  'self-end',\n  'span-self-start',\n  'span-self-end',\n] as const;\n\nexport type PositionAreaProperty = (typeof POSITION_AREA_PROPS)[number];\n\nexport function isPositionAreaProp(\n  property: string | PositionAreaProperty,\n): property is PositionAreaProperty {\n  return POSITION_AREA_PROPS.includes(property as PositionAreaProperty);\n}\nconst POSITION_AREA_SPANS: Record<\n  PositionAreaProperty,\n  [PositionAreaGridValue, PositionAreaGridValue, WritingMode]\n> = {\n  left: [0, 1, WritingMode.Irrelevant],\n  center: [1, 2, WritingMode.Irrelevant],\n  right: [2, 3, WritingMode.Irrelevant],\n  'span-left': [0, 2, WritingMode.Irrelevant],\n  'span-right': [1, 3, WritingMode.Irrelevant],\n  'x-start': [0, 1, WritingMode.Physical],\n  'x-end': [2, 3, WritingMode.Physical],\n  'span-x-start': [0, 2, WritingMode.Physical],\n  'span-x-end': [1, 3, WritingMode.Physical],\n  'x-self-start': [0, 1, WritingMode.PhysicalSelf],\n  'x-self-end': [2, 3, WritingMode.PhysicalSelf],\n  'span-x-self-start': [0, 2, WritingMode.PhysicalSelf],\n  'span-x-self-end': [1, 3, WritingMode.PhysicalSelf],\n  'span-all': [0, 3, WritingMode.Irrelevant],\n  top: [0, 1, WritingMode.Irrelevant],\n  bottom: [2, 3, WritingMode.Irrelevant],\n  'span-top': [0, 2, WritingMode.Irrelevant],\n  'span-bottom': [1, 3, WritingMode.Irrelevant],\n  'y-start': [0, 1, WritingMode.Physical],\n  'y-end': [2, 3, WritingMode.Physical],\n  'span-y-start': [0, 2, WritingMode.Physical],\n  'span-y-end': [1, 3, WritingMode.Physical],\n  'y-self-start': [0, 1, WritingMode.PhysicalSelf],\n  'y-self-end': [2, 3, WritingMode.PhysicalSelf],\n  'span-y-self-start': [0, 2, WritingMode.PhysicalSelf],\n  'span-y-self-end': [1, 3, WritingMode.PhysicalSelf],\n  'block-start': [0, 1, WritingMode.Logical],\n  'block-end': [2, 3, WritingMode.Logical],\n  'span-block-start': [0, 2, WritingMode.Logical],\n  'span-block-end': [1, 3, WritingMode.Logical],\n  'inline-start': [0, 1, WritingMode.Logical],\n  'inline-end': [2, 3, WritingMode.Logical],\n  'span-inline-start': [0, 2, WritingMode.Logical],\n  'span-inline-end': [1, 3, WritingMode.Logical],\n  'self-block-start': [0, 1, WritingMode.LogicalSelf],\n  'self-block-end': [2, 3, WritingMode.LogicalSelf],\n  'span-self-block-start': [0, 2, WritingMode.LogicalSelf],\n  'span-self-block-end': [1, 3, WritingMode.LogicalSelf],\n  'self-inline-start': [0, 1, WritingMode.LogicalSelf],\n  'self-inline-end': [2, 3, WritingMode.LogicalSelf],\n  'span-self-inline-start': [0, 2, WritingMode.LogicalSelf],\n  'span-self-inline-end': [1, 3, WritingMode.LogicalSelf],\n  start: [0, 1, WritingMode.Logical],\n  end: [2, 3, WritingMode.Logical],\n  'span-start': [0, 2, WritingMode.Logical],\n  'span-end': [1, 3, WritingMode.Logical],\n  'self-start': [0, 1, WritingMode.LogicalSelf],\n  'self-end': [2, 3, WritingMode.LogicalSelf],\n  'span-self-start': [0, 2, WritingMode.LogicalSelf],\n  'span-self-end': [1, 3, WritingMode.LogicalSelf],\n};\nconst POSITION_AREA_X = [\n  'left',\n  'center',\n  'right',\n  'span-left',\n  'span-right',\n  'x-start',\n  'x-end',\n  'span-x-start',\n  'span-x-end',\n  'x-self-start',\n  'x-self-end',\n  'span-x-self-start',\n  'span-x-self-end',\n  'span-all',\n] as PositionAreaProperty[];\n\nconst POSITION_AREA_Y = [\n  'top',\n  'center',\n  'bottom',\n  'span-top',\n  'span-bottom',\n  'y-start',\n  'y-end',\n  'span-y-start',\n  'span-y-end',\n  'y-self-start',\n  'y-self-end',\n  'span-y-self-start',\n  'span-y-self-end',\n  'span-all',\n] as PositionAreaProperty[];\n\nconst POSITION_AREA_BLOCK = [\n  'block-start',\n  'center',\n  'block-end',\n  'span-block-start',\n  'span-block-end',\n  'span-all',\n] as PositionAreaProperty[];\n\nconst POSITION_AREA_INLINE = [\n  'inline-start',\n  'center',\n  'inline-end',\n  'span-inline-start',\n  'span-inline-end',\n  'span-all',\n] as PositionAreaProperty[];\n\nconst POSITION_AREA_SELF_BLOCK = [\n  'self-block-start',\n  'center',\n  'self-block-end',\n  'span-self-block-start',\n  'span-self-block-end',\n  'span-all',\n] as PositionAreaProperty[];\n\nconst POSITION_AREA_SELF_INLINE = [\n  'self-inline-start',\n  'center',\n  'self-inline-end',\n  'span-self-inline-start',\n  'span-self-inline-end',\n  'span-all',\n] as PositionAreaProperty[];\n\nconst POSITION_AREA_SHORTHAND = [\n  'start',\n  'center',\n  'end',\n  'span-start',\n  'span-end',\n  'span-all',\n] as PositionAreaProperty[];\n\nconst POSITION_AREA_SELF_SHORTHAND = [\n  'self-start',\n  'center',\n  'self-end',\n  'span-self-start',\n  'span-self-end',\n  'span-all',\n] as PositionAreaProperty[];\n\nexport type PositionAreaX = (typeof POSITION_AREA_X)[number];\nexport type PositionAreaY = (typeof POSITION_AREA_Y)[number];\nexport type PositionAreaBlock = (typeof POSITION_AREA_BLOCK)[number];\nexport type PositionAreaInline = (typeof POSITION_AREA_INLINE)[number];\nexport type PositionAreaSelfBlock = (typeof POSITION_AREA_SELF_BLOCK)[number];\nexport type PositionAreaSelfInline = (typeof POSITION_AREA_SELF_INLINE)[number];\nexport type PositionAreaShorthand = (typeof POSITION_AREA_SHORTHAND)[number];\nexport type PositionAreaSelfShorthand =\n  (typeof POSITION_AREA_SELF_SHORTHAND)[number];\n\nconst BLOCK_KEYWORDS = ['block', 'top', 'bottom', 'y'];\nconst INLINE_KEYWORDS = ['inline', 'left', 'right', 'x'];\n\nexport function axisForPositionAreaValue(\n  value: string,\n): 'block' | 'inline' | 'ambiguous' {\n  const parts = value.split('-');\n  for (const part of parts) {\n    if (BLOCK_KEYWORDS.includes(part)) return 'block';\n    if (INLINE_KEYWORDS.includes(part)) return 'inline';\n  }\n  return 'ambiguous';\n}\n\nfunction isValidPositionAreaPair(\n  value: [string, string],\n  options: [string[], string[]],\n): boolean {\n  return (\n    (options[0].includes(value[0]) && options[1].includes(value[1])) ||\n    (options[0].includes(value[1]) && options[1].includes(value[0]))\n  );\n}\n\nconst validPairs: [string[], string[]][] = [\n  [POSITION_AREA_X, POSITION_AREA_Y],\n  [POSITION_AREA_BLOCK, POSITION_AREA_INLINE],\n  [POSITION_AREA_SELF_BLOCK, POSITION_AREA_SELF_INLINE],\n  [POSITION_AREA_SHORTHAND, POSITION_AREA_SHORTHAND],\n  [POSITION_AREA_SELF_SHORTHAND, POSITION_AREA_SELF_SHORTHAND],\n];\nfunction isValidPositionAreaValue(value: [string, string]): boolean {\n  for (const pair of validPairs) {\n    if (isValidPositionAreaPair(value, pair)) return true;\n  }\n  return false;\n}\n\nexport type InsetValue = 0 | 'top' | 'bottom' | 'left' | 'right';\n\nconst getDirectionalStyles = (el: HTMLElement) => {\n  const styles = getComputedStyle(el);\n  return {\n    writingMode: styles.writingMode,\n    direction: styles.direction,\n  };\n};\n\nconst getWritingMode = async (el: HTMLElement, type: WritingMode) => {\n  const offsetParent = await getOffsetParent(el);\n  switch (type) {\n    case WritingMode.Logical:\n    case WritingMode.Physical:\n      return getDirectionalStyles(offsetParent);\n    case WritingMode.LogicalSelf:\n    case WritingMode.PhysicalSelf:\n      return getDirectionalStyles(el);\n    default:\n      return null;\n  }\n};\n\nconst flipValues = (\n  values: [PositionAreaGridValue, PositionAreaGridValue],\n): [PositionAreaGridValue, PositionAreaGridValue] => {\n  return values.reverse().map((value) => 3 - value) as [\n    PositionAreaGridValue,\n    PositionAreaGridValue,\n  ];\n};\n\n// Validation ensures that there is only one non-Irrelevant writing mode\nconst getRelevantWritingMode = (block: WritingMode, inline: WritingMode) => {\n  return block === WritingMode.Irrelevant ? inline : block;\n};\n\nconst getWritingModeModifiedGrid = async (\n  {\n    block,\n    inline,\n  }: {\n    block: [PositionAreaGridValue, PositionAreaGridValue, WritingMode];\n    inline: [PositionAreaGridValue, PositionAreaGridValue, WritingMode];\n  },\n  targetElement: HTMLElement,\n) => {\n  const relevantWritingMode = getRelevantWritingMode(block[2], inline[2]);\n\n  const writingMode = await getWritingMode(targetElement, relevantWritingMode);\n\n  const grid = {\n    block: [block[0], block[1]],\n    inline: [inline[0], inline[1]],\n  } as AxisInfo<[PositionAreaGridValue, PositionAreaGridValue]>;\n\n  if (writingMode) {\n    if (writingMode.direction === 'rtl') {\n      grid.inline = flipValues(grid.inline);\n    }\n    if (writingMode.writingMode.startsWith('vertical')) {\n      const temp = grid.block;\n      grid.block = grid.inline;\n      grid.inline = temp;\n    }\n    if (writingMode.writingMode.startsWith('sideways')) {\n      const temp = grid.block;\n      grid.block = grid.inline;\n      grid.inline = temp;\n      if (writingMode.writingMode.endsWith('lr')) {\n        grid.block = flipValues(grid.block);\n      }\n    }\n    if (writingMode.writingMode.endsWith('rl')) {\n      grid.inline = flipValues(grid.inline);\n    }\n  }\n\n  return grid;\n};\n\n// This function approximates setting the containing block.\nconst getInsets = ({\n  block,\n  inline,\n}: {\n  block: [PositionAreaGridValue, PositionAreaGridValue];\n  inline: [PositionAreaGridValue, PositionAreaGridValue];\n}) => {\n  // Or should these be abstracted to CB_LEFT, CB_RIGHT, etc?\n  const blockValues: InsetValue[] = [0, 'top', 'bottom', 0];\n  const inlineValues: InsetValue[] = [0, 'left', 'right', 0];\n\n  return {\n    block: [blockValues[block[0]], blockValues[block[1]]] as [\n      InsetValue,\n      InsetValue,\n    ],\n    inline: [inlineValues[inline[0]], inlineValues[inline[1]]] as [\n      InsetValue,\n      InsetValue,\n    ],\n  };\n};\n\nfunction getAxisAlignment([start, end]: [\n  PositionAreaGridValue,\n  PositionAreaGridValue,\n]): 'start' | 'end' | 'center' {\n  if (start === 0 && end === 3) return 'center';\n  if (start === 0) return 'end';\n  if (end === 3) return 'start';\n  return 'center';\n}\n\ninterface AxisInfo<T> {\n  block: T;\n  inline: T;\n}\n\nexport interface PositionAreaDeclaration {\n  values: AxisInfo<string>;\n  grid: AxisInfo<[PositionAreaGridValue, PositionAreaGridValue, WritingMode]>;\n  selectorUUID: string;\n}\n\nexport interface PositionAreaData {\n  values: AxisInfo<string>;\n  grid: AxisInfo<[PositionAreaGridValue, PositionAreaGridValue]>;\n  insets: AxisInfo<[InsetValue, InsetValue]>;\n  alignments: AxisInfo<'start' | 'end' | 'center'>;\n  changed: boolean;\n  selectorUUID: string;\n}\n\n// Once we have a target, we can determine values based on the writing mode.\nexport interface PositionAreaTargetData {\n  values: AxisInfo<string>;\n  grid: AxisInfo<[PositionAreaGridValue, PositionAreaGridValue, WritingMode]>;\n  insets: AxisInfo<[InsetValue, InsetValue]>;\n  alignments: AxisInfo<'start' | 'end' | 'center'>;\n  selectorUUID: string;\n  targetUUID: string;\n  anchorEl: HTMLElement | PseudoElement | null;\n  wrapperEl: HTMLElement;\n  targetEl: HTMLElement;\n}\n\nfunction isPositionAreaDeclaration(\n  node: CssNode,\n): node is DeclarationWithValue {\n  return node.type === 'Declaration' && node.property === 'position-area';\n}\n\nfunction parsePositionAreaValue(node: DeclarationWithValue) {\n  const value = (node.value.children as List<Identifier>)\n    .toArray()\n    .map(({ name }) => name);\n  if (value.length === 1) {\n    if (axisForPositionAreaValue(value[0]) === 'ambiguous') {\n      value.push(value[0]);\n    } else {\n      value.push('span-all');\n    }\n  }\n  return value as [PositionAreaProperty, PositionAreaProperty];\n}\n\nexport function getPositionAreaDeclaration(\n  node: CssNode,\n): PositionAreaDeclaration | undefined {\n  if (!isPositionAreaDeclaration(node)) return undefined;\n\n  const value = parsePositionAreaValue(node);\n  // If it's not a valid value, we can ignore it.\n  if (!isValidPositionAreaValue(value)) return undefined;\n\n  const positionAreas = {} as AxisInfo<PositionAreaProperty>;\n  switch (axisForPositionAreaValue(value[0])) {\n    case 'block':\n      positionAreas.block = value[0];\n      positionAreas.inline = value[1];\n      break;\n    case 'inline':\n      positionAreas.inline = value[0];\n      positionAreas.block = value[1];\n      break;\n    case 'ambiguous':\n      if (axisForPositionAreaValue(value[1]) == 'block') {\n        positionAreas.block = value[1];\n        positionAreas.inline = value[0];\n      } else {\n        positionAreas.inline = value[1];\n        positionAreas.block = value[0];\n      }\n      break;\n  }\n  const grid = {\n    block: POSITION_AREA_SPANS[positionAreas.block],\n    inline: POSITION_AREA_SPANS[positionAreas.inline],\n  };\n\n  const selectorUUID = `--pa-declaration-${nanoid(12)}`;\n\n  return {\n    values: positionAreas,\n    grid,\n    selectorUUID,\n  };\n}\n\nexport function addPositionAreaDeclarationBlockStyles(\n  declaration: PositionAreaDeclaration,\n  block: Block,\n) {\n  [\n    // Insets are applied to a wrapping element\n    'justify-self',\n    'align-self',\n  ].forEach((prop) => {\n    block.children.appendData({\n      type: 'Declaration',\n      property: prop,\n      value: { type: 'Raw', value: `var(--pa-value-${prop})` },\n      important: false,\n    });\n  });\n  block.children.appendData({\n    type: 'Declaration',\n    property: POSITION_AREA_CASCADE_PROPERTY,\n    value: { type: 'Raw', value: declaration.selectorUUID },\n    important: false,\n  });\n}\n\nexport function wrapperForPositionedElement(\n  targetEl: HTMLElement,\n  targetUUID: string,\n): HTMLElement {\n  let wrapperEl: HTMLElement;\n  if (targetEl.parentElement?.tagName === WRAPPER_ELEMENT) {\n    wrapperEl = targetEl.parentElement as HTMLElement;\n  } else {\n    wrapperEl = document.createElement(WRAPPER_ELEMENT);\n    wrapperEl.style.display = 'grid';\n    wrapperEl.style.position = 'absolute';\n\n    // The wrapper should not receive pointer events, but the target's initial\n    // `pointer-events` value should be preserved.\n    const originalPointerEvents = getComputedStyle(targetEl).pointerEvents;\n    wrapperEl.style.pointerEvents = 'none';\n    targetEl.style.pointerEvents = originalPointerEvents;\n\n    ['top', 'left', 'right', 'bottom'].forEach((prop) => {\n      wrapperEl.style.setProperty(prop, `var(--pa-value-${prop})`);\n    });\n    targetEl.parentElement?.insertBefore(wrapperEl, targetEl);\n    wrapperEl.appendChild(targetEl);\n  }\n  // Wrapper can be be reused by multiple declarations, so set all as boolean\n  // attributes instead of values.\n  wrapperEl.setAttribute(\n    `${WRAPPER_TARGET_ATTRIBUTE_PRELUDE}${targetUUID}`,\n    '',\n  );\n\n  return wrapperEl;\n}\n\nexport async function dataForPositionAreaTarget(\n  targetEl: HTMLElement,\n  positionAreaData: PositionAreaDeclaration,\n  anchorEl: HTMLElement | PseudoElement | null,\n): Promise<PositionAreaTargetData> {\n  const targetUUID = `--pa-target-${nanoid(12)}`;\n  const writingModeModifiedGrid = await getWritingModeModifiedGrid(\n    positionAreaData.grid,\n    targetEl,\n  );\n  const insets = getInsets(writingModeModifiedGrid);\n\n  const relevantWritingMode = getRelevantWritingMode(\n    positionAreaData.grid.block[2],\n    positionAreaData.grid.inline[2],\n  );\n  const alignmentGrid = [\n    WritingMode.LogicalSelf,\n    WritingMode.PhysicalSelf,\n  ].includes(relevantWritingMode)\n    ? writingModeModifiedGrid\n    : positionAreaData.grid;\n  const alignments = {\n    block: getAxisAlignment([alignmentGrid.block[0], alignmentGrid.block[1]]),\n    inline: getAxisAlignment([\n      alignmentGrid.inline[0],\n      alignmentGrid.inline[1],\n    ]),\n  };\n\n  return {\n    insets,\n    alignments,\n    targetUUID,\n    targetEl,\n    anchorEl,\n    wrapperEl: wrapperForPositionedElement(targetEl, targetUUID),\n    values: positionAreaData.values,\n    grid: positionAreaData.grid,\n    selectorUUID: positionAreaData.selectorUUID,\n  };\n}\n\nexport function activeWrapperStyles(targetUUID: string, selectorUUID: string) {\n  return `\n    [${POSITION_AREA_WRAPPER_ATTRIBUTE}=\"${selectorUUID}\"][${WRAPPER_TARGET_ATTRIBUTE_PRELUDE}${targetUUID}] {\n      --pa-value-top: var(${targetUUID}-top);\n      --pa-value-left: var(${targetUUID}-left);\n      --pa-value-right: var(${targetUUID}-right);\n      --pa-value-bottom: var(${targetUUID}-bottom);\n      --pa-value-justify-self: var(${targetUUID}-justify-self);\n      --pa-value-align-self: var(${targetUUID}-align-self);\n    }\n  `.replaceAll('\\n', '');\n}\n","import type {\n  Atrule,\n  Block,\n  CssNode,\n  Declaration,\n  Identifier,\n  Raw,\n  Rule,\n  SelectorList,\n  Value,\n} from 'css-tree';\nimport { clone, List } from 'css-tree/utils';\nimport walk from 'css-tree/walker';\nimport { nanoid } from 'nanoid/non-secure';\n\nimport { getCSSPropertyValue } from './dom.js';\nimport {\n  type AnchorPosition,\n  type AnchorPositions,\n  isIdentifier,\n  type TryBlock,\n} from './parse.js';\nimport {\n  isPositionAreaProp,\n  type PositionAreaProperty,\n} from './position-area.js';\nimport {\n  ACCEPTED_POSITION_TRY_PROPERTIES,\n  type AcceptedPositionTryProperty,\n  type AnchorSideKeyword,\n  isAnchorSide,\n  isInsetProp,\n  isMarginProp,\n  isSelfAlignmentProp,\n  isSizingProp,\n} from './syntax.js';\nimport {\n  type DeclarationWithValue,\n  generateCSS,\n  getAST,\n  getSelectors,\n  INSTANCE_UUID,\n  isAnchorFunction,\n  splitCommaList,\n  type StyleData,\n} from './utils.js';\n\n// https://github.com/import-js/eslint-plugin-import/issues/3019\ninterface AtRuleRaw extends Atrule {\n  prelude: Raw | null;\n}\n\n// `key` is the `@position-try` block uuid\n// `value` is the target element selector\ntype FallbackTargets = Record<string, string[]>;\n\ntype Fallbacks = Record<\n  // `key` is a reference to a specific `position-try-fallbacks` value, which\n  // may be a dashed ident name of a `@position-try` rule, or the selector\n  // combined with `try-tactics` and `@position-try` rules.\n  string,\n  // `value` is a block of `@position-try` declarations\n  TryBlock\n>;\n\ntype PositionAreaPropertyChunks =\n  | 'left'\n  | 'center'\n  | 'right'\n  | 'span'\n  | 'x'\n  | 'start'\n  | 'end'\n  | 'self'\n  | 'all'\n  | 'top'\n  | 'bottom'\n  | 'y'\n  | 'block'\n  | 'inline';\n\nconst POSITION_TRY_ORDERS = [\n  'normal',\n  'most-width',\n  'most-height',\n  'most-block-size',\n  'most-inline-size',\n] as const;\n\nexport type PositionTryOrder = (typeof POSITION_TRY_ORDERS)[number];\n\nconst POSITION_TRY_TACTICS = [\n  'flip-block',\n  'flip-inline',\n  'flip-start',\n] as const;\n\nexport type PositionTryOptionsTryTactics =\n  (typeof POSITION_TRY_TACTICS)[number];\n\ninterface PositionTryDefTactic {\n  type: 'try-tactic';\n  tactics: PositionTryOptionsTryTactics[];\n}\ninterface PositionTryDefPositionArea {\n  type: 'position-area';\n  positionArea: PositionAreaProperty;\n}\ninterface PositionTryDefAtRule {\n  type: 'at-rule';\n  atRule: Identifier['name'];\n}\ninterface PositionTryDefAtRuleWithTactic {\n  type: 'at-rule-with-try-tactic';\n  tactics: PositionTryOptionsTryTactics[];\n  atRule: Identifier['name'];\n}\n\ntype PositionTryObject =\n  | PositionTryDefTactic\n  | PositionTryDefPositionArea\n  | PositionTryDefAtRule\n  | PositionTryDefAtRuleWithTactic;\n\nfunction isDeclaration(node: CssNode): node is DeclarationWithValue {\n  return node.type === 'Declaration';\n}\n\nfunction isPositionTryFallbacksDeclaration(\n  node: CssNode,\n): node is DeclarationWithValue {\n  return (\n    node.type === 'Declaration' && node.property === 'position-try-fallbacks'\n  );\n}\n\nfunction isPositionTryOrderDeclaration(\n  node: CssNode,\n): node is DeclarationWithValue {\n  return node.type === 'Declaration' && node.property === 'position-try-order';\n}\n\nfunction isPositionTryDeclaration(node: CssNode): node is DeclarationWithValue {\n  return node.type === 'Declaration' && node.property === 'position-try';\n}\n\nfunction isPositionTryAtRule(node: CssNode): node is AtRuleRaw {\n  return node.type === 'Atrule' && node.name === 'position-try';\n}\n\nfunction isPositionTryTactic(\n  name: string,\n): name is PositionTryOptionsTryTactics {\n  return POSITION_TRY_TACTICS.includes(name as PositionTryOptionsTryTactics);\n}\n\nfunction isPositionTryOrder(name: string): name is PositionTryOrder {\n  return POSITION_TRY_ORDERS.includes(name as PositionTryOrder);\n}\n\nexport function applyTryTacticsToSelector(\n  selector: string,\n  tactics: PositionTryOptionsTryTactics[],\n) {\n  // todo: This currently only uses the styles from the first match. Each\n  // element may have different styles and need a separate fallback definition.\n  const el: HTMLElement | null = document.querySelector(selector);\n  if (el) {\n    let rules = getExistingInsetRules(el);\n    tactics.forEach((tactic) => {\n      rules = applyTryTacticToBlock(rules, tactic);\n    });\n    return rules;\n  }\n}\nexport function applyTryTacticsToAtRule(\n  block: TryBlock,\n  tactics: PositionTryOptionsTryTactics[],\n) {\n  let rules = block.declarations;\n  tactics.forEach((tactic) => {\n    rules = applyTryTacticToBlock(rules, tactic);\n  });\n  return rules;\n}\n\ntype InsetRules = Partial<Record<AcceptedPositionTryProperty, string>>;\n\nfunction getExistingInsetRules(el: HTMLElement) {\n  const rules: InsetRules = {};\n  ACCEPTED_POSITION_TRY_PROPERTIES.forEach((prop) => {\n    const propVal = getCSSPropertyValue(el, `--${prop}-${INSTANCE_UUID}`);\n    if (propVal) {\n      rules[prop] = propVal;\n    }\n  });\n  return rules;\n}\n\nconst tryTacticsPropertyMapping: Record<\n  PositionTryOptionsTryTactics,\n  Partial<Record<AcceptedPositionTryProperty, AcceptedPositionTryProperty>>\n> = {\n  'flip-block': {\n    top: 'bottom',\n    bottom: 'top',\n    'inset-block-start': 'inset-block-end',\n    'inset-block-end': 'inset-block-start',\n    'margin-top': 'margin-bottom',\n    'margin-bottom': 'margin-top',\n  },\n  'flip-inline': {\n    left: 'right',\n    right: 'left',\n    'inset-inline-start': 'inset-inline-end',\n    'inset-inline-end': 'inset-inline-start',\n    'margin-left': 'margin-right',\n    'margin-right': 'margin-left',\n  },\n  'flip-start': {\n    left: 'top',\n    right: 'bottom',\n    top: 'left',\n    bottom: 'right',\n    'inset-block-start': 'inset-block-end',\n    'inset-block-end': 'inset-block-start',\n    'inset-inline-start': 'inset-inline-end',\n    'inset-inline-end': 'inset-inline-start',\n    'inset-block': 'inset-inline',\n    'inset-inline': 'inset-block',\n  },\n};\n\nconst anchorSideMapping: Record<\n  PositionTryOptionsTryTactics,\n  Partial<Record<AnchorSideKeyword, AnchorSideKeyword>>\n> = {\n  'flip-block': {\n    top: 'bottom',\n    bottom: 'top',\n    start: 'end',\n    end: 'start',\n    'self-end': 'self-start',\n    'self-start': 'self-end',\n  },\n  'flip-inline': {\n    left: 'right',\n    right: 'left',\n    start: 'end',\n    end: 'start',\n    'self-end': 'self-start',\n    'self-start': 'self-end',\n  },\n  'flip-start': {\n    top: 'left',\n    left: 'top',\n    right: 'bottom',\n    bottom: 'right',\n  },\n};\n\nconst PositionAreaPropertyMapping: Record<\n  PositionTryOptionsTryTactics,\n  Partial<Record<PositionAreaPropertyChunks, PositionAreaPropertyChunks>>\n> = {\n  'flip-block': {\n    top: 'bottom',\n    bottom: 'top',\n    start: 'end',\n    end: 'start',\n  },\n  'flip-inline': {\n    left: 'right',\n    right: 'left',\n    start: 'end',\n    end: 'start',\n  },\n  'flip-start': {\n    // TODO: Requires fuller logic\n  },\n};\n\nfunction mapProperty(\n  property: AcceptedPositionTryProperty,\n  tactic: PositionTryOptionsTryTactics,\n) {\n  const mapping = tryTacticsPropertyMapping[tactic];\n  return mapping[property] || property;\n}\n\nfunction mapAnchorSide(\n  side: AnchorSideKeyword,\n  tactic: PositionTryOptionsTryTactics,\n) {\n  const mapping = anchorSideMapping[tactic];\n  return mapping[side] || side;\n}\n\nfunction mapPositionArea(\n  prop: PositionAreaProperty,\n  tactic: PositionTryOptionsTryTactics,\n) {\n  if (tactic === 'flip-start') {\n    // TODO: Handle flip-start\n    return prop;\n  } else {\n    const mapping = PositionAreaPropertyMapping[tactic];\n    return prop\n      .split('-')\n      .map((value) => mapping[value as PositionAreaPropertyChunks] || value)\n      .join('-');\n  }\n}\n\nfunction mapMargin(\n  key: string,\n  valueAst: Value,\n  tactic: PositionTryOptionsTryTactics,\n) {\n  // TODO: Handle flip-start\n  if (key === 'margin') {\n    const [first, second, third, fourth] = valueAst.children.toArray();\n    if (tactic === 'flip-block') {\n      if (fourth) {\n        valueAst.children.fromArray([third, second, first, fourth]);\n      } else if (third) {\n        valueAst.children.fromArray([third, second, first]);\n      } // No change needed for 1 or 2 values\n    } else if (tactic === 'flip-inline') {\n      if (fourth) {\n        valueAst.children.fromArray([first, fourth, third, second]);\n      } // No change needed for 1, 2 or 3 values\n    }\n  } else if (key === 'margin-block') {\n    const [first, second] = valueAst.children.toArray();\n    if (tactic === 'flip-block') {\n      if (second) {\n        valueAst.children.fromArray([second, first]);\n      }\n    }\n  } else if (key === 'margin-inline') {\n    const [first, second] = valueAst.children.toArray();\n    if (tactic === 'flip-inline') {\n      if (second) {\n        valueAst.children.fromArray([second, first]);\n      }\n    }\n  }\n}\n\n// Parses a value into an AST.\nconst getValueAST = (property: string, val: string) => {\n  const ast = getAST(`#id{${property}: ${val};}`) as Block;\n  const astDeclaration = (ast.children.first as Rule)?.block.children\n    .first as Declaration;\n  return astDeclaration.value as Value;\n};\n\nexport function applyTryTacticToBlock(\n  rules: InsetRules,\n  tactic: PositionTryOptionsTryTactics,\n) {\n  const declarations: TryBlock['declarations'] = {};\n  Object.entries(rules).forEach(([_key, value]) => {\n    const key = _key as AcceptedPositionTryProperty;\n    const valueAst = getValueAST(key, value);\n\n    const newKey = mapProperty(key, tactic);\n\n    // If we're changing the property, revert the original if it hasn't been set.\n    if (newKey !== key) {\n      declarations[key] ??= 'revert';\n    }\n\n    // todo: This does not support percentage anchor-side values, nor anchor\n    // functions that are passed through custom properties.\n    walk(valueAst, {\n      visit: 'Function',\n      enter(node) {\n        if (isAnchorFunction(node)) {\n          node.children.forEach((item) => {\n            if (isIdentifier(item) && isAnchorSide(item.name)) {\n              item.name = mapAnchorSide(item.name, tactic);\n            }\n          });\n        }\n      },\n    });\n\n    if (key === 'position-area') {\n      valueAst.children.forEach((id) => {\n        if (isIdentifier(id) && isPositionAreaProp(id.name)) {\n          id.name = mapPositionArea(id.name, tactic);\n        }\n      });\n    }\n    if (key.startsWith('margin')) {\n      mapMargin(key, valueAst, tactic);\n    }\n\n    declarations[newKey] = generateCSS(valueAst);\n  });\n  return declarations;\n}\n\nfunction parsePositionTryFallbacks(list: List<CssNode>) {\n  const positionOptions = splitCommaList(list);\n  const tryObjects: PositionTryObject[] = [];\n  positionOptions.forEach((option) => {\n    const identifiers: {\n      atRules: PositionTryDefAtRuleWithTactic['atRule'][];\n      tactics: PositionTryOptionsTryTactics[];\n      positionAreas: PositionAreaProperty[];\n    } = {\n      atRules: [],\n      tactics: [],\n      positionAreas: [],\n    };\n    option.forEach((opt) => {\n      if (isPositionTryTactic(opt.name)) identifiers.tactics.push(opt.name);\n      else if (opt.name.startsWith('--')) identifiers.atRules.push(opt.name);\n      else if (isPositionAreaProp(opt.name))\n        identifiers.positionAreas.push(opt.name);\n    });\n    // Position area can not be combined or have multiple\n    if (identifiers.positionAreas.length) {\n      tryObjects.push({\n        positionArea: identifiers.positionAreas[0],\n        type: 'position-area',\n      });\n      // multiple tactics can modify a single at rule\n    } else if (identifiers.atRules.length && identifiers.tactics.length) {\n      tryObjects.push({\n        tactics: identifiers.tactics,\n        atRule: identifiers.atRules[0],\n        type: 'at-rule-with-try-tactic',\n      });\n      // A single at rule\n    } else if (identifiers.atRules.length) {\n      tryObjects.push({\n        atRule: identifiers.atRules[0],\n        type: 'at-rule',\n      });\n      // One or multiple combined try tactics\n    } else if (identifiers.tactics.length) {\n      tryObjects.push({\n        tactics: identifiers.tactics,\n        type: 'try-tactic',\n      });\n    }\n  });\n  return tryObjects;\n}\n\nfunction getPositionTryFallbacksDeclaration(node: Declaration) {\n  if (isPositionTryFallbacksDeclaration(node) && node.value.children.first) {\n    return parsePositionTryFallbacks(node.value.children);\n  }\n  return [];\n}\n\nexport function getPositionTryDeclaration(node: Declaration): {\n  order?: PositionTryOrder;\n  options?: PositionTryObject[];\n} {\n  if (isPositionTryDeclaration(node) && node.value.children.first) {\n    const declarationNode = clone(node) as DeclarationWithValue;\n    let order: PositionTryOrder | undefined;\n    // get potential order\n    const firstName = (declarationNode.value.children.first as Identifier).name;\n    if (firstName && isPositionTryOrder(firstName)) {\n      order = firstName;\n      declarationNode.value.children.shift();\n    }\n    const options = parsePositionTryFallbacks(declarationNode.value.children);\n\n    return { order, options };\n  }\n  return {};\n}\n\nfunction getPositionTryOrderDeclaration(node: Declaration) {\n  if (isPositionTryOrderDeclaration(node) && node.value.children.first) {\n    return {\n      order: (node.value.children.first as Identifier).name as PositionTryOrder,\n    };\n  }\n  return {};\n}\n\nexport function getPositionFallbackValues(node: Declaration): {\n  order?: PositionTryOrder;\n  options?: PositionTryObject[];\n} {\n  const { order, options } = getPositionTryDeclaration(node);\n  if (order || options) {\n    return { order, options };\n  }\n  const { order: orderDeclaration } = getPositionTryOrderDeclaration(node);\n  const optionsNames = getPositionTryFallbacksDeclaration(node);\n  if (orderDeclaration || optionsNames) {\n    return { order: orderDeclaration, options: optionsNames };\n  }\n  return {};\n}\n\n// https://drafts.csswg.org/css-anchor-position-1/#accepted-position-try-properties\nexport function isAcceptedPositionTryProperty(declaration: Declaration) {\n  return (\n    isInsetProp(declaration.property) ||\n    isMarginProp(declaration.property) ||\n    isSizingProp(declaration.property) ||\n    isSelfAlignmentProp(declaration.property) ||\n    ['position-anchor', 'position-area'].includes(declaration.property)\n  );\n}\n\nexport function getPositionTryRules(node: Atrule) {\n  if (\n    isPositionTryAtRule(node) &&\n    node.prelude?.value &&\n    node.block?.children\n  ) {\n    const name = node.prelude.value;\n    const declarations = node.block.children.filter(\n      (d): d is DeclarationWithValue =>\n        isDeclaration(d) && isAcceptedPositionTryProperty(d),\n    );\n    const tryBlock: TryBlock = {\n      uuid: `${name}-try-${nanoid(12)}`,\n      declarations: Object.fromEntries(\n        declarations.map((d) => [d.property, generateCSS(d.value)]),\n      ),\n    };\n\n    return { name, tryBlock };\n  }\n  return {};\n}\n\nexport function parsePositionFallbacks(styleData: StyleData[]) {\n  const fallbacks: Fallbacks = {};\n  const fallbackTargets: FallbackTargets = {};\n  const validPositions: AnchorPositions = {};\n\n  // First, find all uses of `@position-try`\n  for (const styleObj of styleData) {\n    const ast = getAST(styleObj.css);\n    walk(ast, {\n      visit: 'Atrule',\n      enter(node) {\n        // Parse `@position-try` rules\n        const { name, tryBlock } = getPositionTryRules(node);\n        if (name && tryBlock) {\n          // This will override earlier `@position-try` lists with the same\n          // name: (e.g. multiple `@position-try --my-fallback {...}` uses with\n          // the same `--my-fallback` name)\n          fallbacks[name] = tryBlock;\n        }\n      },\n    });\n  }\n\n  // Then, find all `position-try` and related declarations,\n  // and add in block contents (scoped to unique data-attrs)\n  for (const styleObj of styleData) {\n    let changed = false;\n    const fallbacksAdded = new Set();\n    const ast = getAST(styleObj.css);\n    walk(ast, {\n      visit: 'Declaration',\n      enter(node) {\n        const rule = this.rule?.prelude as SelectorList | undefined;\n        const selectors = getSelectors(rule);\n        if (!selectors.length) return;\n\n        // Parse `position-try`, `position-try-order`, and\n        // `position-try-fallbacks` declarations\n        const { order, options } = getPositionFallbackValues(node);\n        const anchorPosition: AnchorPosition = {};\n        if (order) {\n          anchorPosition.order = order;\n        }\n        selectors.forEach(({ selector }) => {\n          options?.forEach((tryObject) => {\n            let name;\n            // Apply try fallback\n            if (tryObject.type === 'at-rule') {\n              name = tryObject.atRule;\n            } else if (tryObject.type === 'try-tactic') {\n              // get existing styles and adjust based on the specified tactic\n              name = `${selector}-${tryObject.tactics.join('-')}`;\n              const tacticAppliedRules = applyTryTacticsToSelector(\n                selector,\n                tryObject.tactics,\n              );\n              if (tacticAppliedRules) {\n                // add new item to fallbacks store\n                fallbacks[name] = {\n                  uuid: `${selector}-${tryObject.tactics.join('-')}-try-${nanoid(12)}`,\n                  declarations: tacticAppliedRules,\n                };\n              }\n            } else if (tryObject.type === 'at-rule-with-try-tactic') {\n              // get `@position-try` block styles and adjust based on the tactic\n              name = `${selector}-${tryObject.atRule}-${tryObject.tactics.join('-')}`;\n              const declarations = fallbacks[tryObject.atRule];\n              const tacticAppliedRules = applyTryTacticsToAtRule(\n                declarations,\n                tryObject.tactics,\n              );\n              if (tacticAppliedRules) {\n                // add new item to fallbacks store\n                fallbacks[name] = {\n                  uuid: `${selector}-${tryObject.atRule}-${tryObject.tactics.join('-')}-try-${nanoid(12)}`,\n                  declarations: tacticAppliedRules,\n                };\n              }\n            }\n\n            if (name && fallbacks[name]) {\n              const dataAttr = `[data-anchor-polyfill=\"${fallbacks[name].uuid}\"]`;\n              // Store mapping of data-attr to target selectors\n              fallbackTargets[dataAttr] ??= [];\n              fallbackTargets[dataAttr].push(selector);\n\n              if (!fallbacksAdded.has(name)) {\n                anchorPosition.fallbacks ??= [];\n                anchorPosition.fallbacks.push(fallbacks[name]);\n                fallbacksAdded.add(name);\n\n                // Add `@position-try` block, scoped to a unique data-attr\n                this.stylesheet?.children.prependData({\n                  type: 'Rule',\n                  prelude: {\n                    type: 'Raw',\n                    value: dataAttr,\n                  },\n                  block: {\n                    type: 'Block',\n                    children: new List<CssNode>().fromArray(\n                      Object.entries(fallbacks[name].declarations).map(\n                        ([prop, val]) => ({\n                          type: 'Declaration',\n                          important: true,\n                          property: prop,\n                          value: {\n                            type: 'Raw',\n                            value: val,\n                          },\n                        }),\n                      ),\n                    ),\n                  },\n                });\n                changed = true;\n              }\n            }\n          });\n          if (Object.keys(anchorPosition).length > 0) {\n            if (validPositions[selector]) {\n              if (anchorPosition.order) {\n                validPositions[selector].order = anchorPosition.order;\n              }\n              if (anchorPosition.fallbacks) {\n                validPositions[selector].fallbacks ??= [];\n                validPositions[selector].fallbacks.push(\n                  ...anchorPosition.fallbacks,\n                );\n              }\n              //  = {order: anchorPosition.order, fallbacks: [...[validPositions[selector].fallbacks], ...[anchorPosition.fallbacks]]};\n            } else {\n              validPositions[selector] = anchorPosition;\n            }\n          }\n        });\n      },\n    });\n    if (changed) {\n      // Update CSS\n      styleObj.css = generateCSS(ast);\n      styleObj.changed = true;\n    }\n  }\n  return { fallbackTargets, validPositions };\n}\n","import { platform } from '@floating-ui/dom';\n\nimport {\n  getCSSPropertyValue,\n  getElementsBySelector,\n  hasAnchorName,\n  hasAnchorScope,\n  hasStyle,\n  type Selector,\n} from './dom.js';\n\n// Given a target element's containing block (CB) and an anchor element,\n// determines if the anchor element is a descendant of the target CB.\n// An additional check is added to see if the target CB is the anchor,\n// because `.contains()` will return true: \"a node is contained inside itself.\"\n// https://developer.mozilla.org/en-US/docs/Web/API/Node/contains\nfunction isContainingBlockDescendant(\n  containingBlock: Element | Window,\n  anchor: Element,\n): boolean {\n  if (!containingBlock || containingBlock === anchor) {\n    return false;\n  }\n\n  if (isWindow(containingBlock)) {\n    return containingBlock.document.contains(anchor);\n  } else {\n    return containingBlock.contains(anchor);\n  }\n}\n\nfunction isWindow(el: Element | Window | undefined): el is Window {\n  return Boolean(el && el === (el as Window).window);\n}\n\nfunction isFixedPositioned(el: HTMLElement) {\n  return hasStyle(el, 'position', 'fixed');\n}\n\nfunction isAbsolutelyPositioned(el?: HTMLElement | null) {\n  return Boolean(\n    el && (isFixedPositioned(el) || hasStyle(el, 'position', 'absolute')),\n  );\n}\n\nfunction precedes(self: HTMLElement, other: HTMLElement) {\n  return self.compareDocumentPosition(other) & Node.DOCUMENT_POSITION_FOLLOWING;\n}\n\n/** https://drafts.csswg.org/css-display-4/#formatting-context */\nasync function getFormattingContext(element: HTMLElement) {\n  return await platform.getOffsetParent(element);\n}\n\n/** https://drafts.csswg.org/css-display-4/#containing-block */\nasync function getContainingBlock(element: HTMLElement) {\n  if (\n    !['absolute', 'fixed'].includes(getCSSPropertyValue(element, 'position'))\n  ) {\n    return await getFormattingContext(element);\n  }\n\n  let currentParent = element.parentElement;\n\n  while (currentParent) {\n    if (\n      !hasStyle(currentParent, 'position', 'static') &&\n      hasStyle(currentParent, 'display', 'block')\n    ) {\n      return currentParent;\n    }\n\n    currentParent = currentParent.parentElement;\n  }\n\n  return window;\n}\n\n/**\n * Validates that el is a acceptable anchor element for an absolutely positioned\n * element query el\n * https://drafts.csswg.org/css-anchor-position-1/#acceptable-anchor-element\n */\nexport async function isAcceptableAnchorElement(\n  el: HTMLElement,\n  anchorName: string | null,\n  queryEl: HTMLElement,\n  scopeSelector: string | null,\n) {\n  const elContainingBlock = await getContainingBlock(el);\n  const queryElContainingBlock = await getContainingBlock(queryEl);\n\n  // Either el is a descendant of query el’s containing block\n  // or query el’s containing block is the initial containing block.\n  if (\n    !(\n      isContainingBlockDescendant(queryElContainingBlock, el) ||\n      isWindow(queryElContainingBlock)\n    )\n  ) {\n    return false;\n  }\n\n  // If el has the same containing block as query el,\n  // then either el is not absolutely positioned,\n  // or el precedes query el in the tree order.\n  if (\n    elContainingBlock === queryElContainingBlock &&\n    !(!isAbsolutelyPositioned(el) || precedes(el, queryEl))\n  ) {\n    return false;\n  }\n\n  // If el has a different containing block from query el,\n  // then the last containing block in el’s containing block chain\n  // before reaching query el’s containing block\n  // is either not absolutely positioned or precedes query el in the tree order.\n  if (elContainingBlock !== queryElContainingBlock) {\n    let currentCB: Element | Window;\n    const anchorCBchain: (typeof currentCB)[] = [];\n\n    currentCB = elContainingBlock;\n    while (\n      currentCB &&\n      currentCB !== queryElContainingBlock &&\n      currentCB !== window\n    ) {\n      anchorCBchain.push(currentCB);\n      currentCB = await getContainingBlock(currentCB as HTMLElement);\n    }\n    const lastInChain = anchorCBchain[anchorCBchain.length - 1];\n\n    if (\n      lastInChain instanceof HTMLElement &&\n      !(!isAbsolutelyPositioned(lastInChain) || precedes(lastInChain, queryEl))\n    ) {\n      return false;\n    }\n  }\n\n  // el is not in the skipped contents of another element.\n  {\n    let currentParent = el.parentElement;\n\n    while (currentParent) {\n      if (hasStyle(currentParent, 'content-visibility', 'hidden')) {\n        return false;\n      }\n\n      currentParent = currentParent.parentElement;\n    }\n  }\n\n  // el is in scope for query el, per the effects of anchor-scope on query el or\n  // its ancestors.\n  if (\n    anchorName &&\n    scopeSelector &&\n    getScope(el, anchorName, scopeSelector) !==\n      getScope(queryEl, anchorName, scopeSelector)\n  ) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction getScope(\n  element: HTMLElement,\n  anchorName: string,\n  scopeSelector: string,\n) {\n  // Unlike the real `anchor-scope`, our `--anchor-scope` custom property\n  // inherits. We first check that the element matches the scope selector, so we\n  // can be guaranteed that the computed value we read was set explicitly, not\n  // inherited. Then we verify that the specified anchor scope is actually the\n  // one applied by the CSS cascade.\n  while (\n    !(element.matches(scopeSelector) && hasAnchorScope(element, anchorName))\n  ) {\n    if (!element.parentElement) {\n      return null;\n    }\n    element = element.parentElement;\n  }\n  return element;\n}\n\n/**\n * Given a target element and CSS selector(s) for potential anchor element(s),\n * returns the first element that passes validation,\n * or `null` if no valid anchor element is found\n * https://drafts.csswg.org/css-anchor-position-1/#target\n */\nexport async function validatedForPositioning(\n  targetEl: HTMLElement | null,\n  anchorName: string | null,\n  anchorSelectors: Selector[],\n  scopeSelectors: Selector[],\n) {\n  if (\n    !(\n      targetEl instanceof HTMLElement &&\n      anchorSelectors.length &&\n      isAbsolutelyPositioned(targetEl)\n    )\n  ) {\n    return null;\n  }\n\n  const anchorElements = anchorSelectors\n    // Any element that matches a selector that sets the specified `anchor-name`\n    // could be a potential match.\n    .flatMap(getElementsBySelector)\n    // Narrow down the potential match elements to just the ones whose computed\n    // `anchor-name` matches the specified one. This accounts for the\n    // `anchor-name` value that was actually applied by the CSS cascade.\n    .filter((el) => hasAnchorName(el, anchorName));\n\n  // TODO: handle anchor-scope for pseudo-elements.\n  const scopeSelector = scopeSelectors.map((s) => s.selector).join(',') || null;\n\n  for (let index = anchorElements.length - 1; index >= 0; index--) {\n    const anchor = anchorElements[index];\n    const isPseudoElement = 'fakePseudoElement' in anchor;\n\n    if (\n      await isAcceptableAnchorElement(\n        isPseudoElement ? anchor.fakePseudoElement : anchor,\n        anchorName,\n        targetEl,\n        scopeSelector,\n      )\n    ) {\n      if (isPseudoElement) anchor.removeFakePseudoElement();\n\n      return anchor;\n    }\n  }\n\n  return null;\n}\n","import type {\n  CssNode,\n  Declaration,\n  FunctionNode,\n  Identifier,\n  List,\n  Percentage,\n  SelectorList,\n} from 'css-tree';\nimport walk from 'css-tree/walker';\nimport { nanoid } from 'nanoid/non-secure';\n\nimport {\n  AnchorScopeValue,\n  getCSSPropertyValue,\n  type PseudoElement,\n  type Selector,\n} from './dom.js';\nimport { parsePositionFallbacks, type PositionTryOrder } from './fallback.js';\nimport {\n  activeWrapperStyles,\n  addPositionAreaDeclarationBlockStyles,\n  dataForPositionAreaTarget,\n  getPositionAreaDeclaration,\n  type PositionAreaDeclaration,\n  type PositionAreaTargetData,\n} from './position-area.js';\nimport {\n  type AcceptedAnchorSizeProperty,\n  type AcceptedPositionTryProperty,\n  type AnchorSide,\n  type AnchorSize,\n  type InsetProperty,\n  isAcceptedAnchorSizeProp,\n  isAnchorSide,\n  isAnchorSize,\n  isInsetProp,\n  isSizingProp,\n  type SizingProperty,\n} from './syntax.js';\nimport {\n  type DeclarationWithValue,\n  generateCSS,\n  getAST,\n  getSelectors,\n  isAnchorFunction,\n  type StyleData,\n} from './utils.js';\nimport { validatedForPositioning } from './validate.js';\n\n// `key` is the `anchor-name` value\n// `value` is an array of all selectors associated with that `anchor-name`\ntype AnchorSelectors = Record<string, Selector[]>;\n\nexport interface AnchorFunction {\n  targetEl?: HTMLElement | null;\n  anchorEl?: HTMLElement | PseudoElement | null;\n  anchorName?: string;\n  anchorSide?: AnchorSide;\n  anchorSize?: AnchorSize;\n  fallbackValue: string;\n  customPropName?: string;\n  uuid: string;\n}\n\n// - `key` is the property being declared\n// - `value` is the anchor-positioning data for that property\n// The valid properties for `anchor()` is a subset of the properties that are\n// valid for `anchor-size()`, so functional validation should be used as well.\nexport type AnchorFunctionDeclaration = Partial<\n  Record<\n    AcceptedAnchorSizeProperty | 'position-area',\n    (AnchorFunction | PositionAreaTargetData)[]\n  >\n>;\n\n// `key` is the target element selector\n// `value` is an object with all anchor-function declarations on that element\ntype AnchorFunctionDeclarations = Record<string, AnchorFunctionDeclaration>;\n\n// `key` is the target element selector\n// `value` is the position-area data for that property\ntype PositionAreaDeclarations = Record<string, PositionAreaDeclaration[]>;\n\nexport interface AnchorPosition {\n  declarations?: AnchorFunctionDeclaration;\n  fallbacks?: TryBlock[];\n  order?: PositionTryOrder;\n}\n\n// `key` is the target element selector\n// `value` is an object with all anchor-positioning data for that element\nexport type AnchorPositions = Record<string, AnchorPosition>;\n\nexport interface TryBlock {\n  uuid: string;\n  // `key` is the property being declared\n  // `value` is the property value\n  declarations: Partial<Record<AcceptedPositionTryProperty, string>>;\n}\n\nfunction isAnchorNameDeclaration(node: CssNode): node is DeclarationWithValue {\n  return node.type === 'Declaration' && node.property === 'anchor-name';\n}\n\nfunction isAnchorScopeDeclaration(node: CssNode): node is DeclarationWithValue {\n  return node.type === 'Declaration' && node.property === 'anchor-scope';\n}\n\nfunction isAnchorSizeFunction(node: CssNode | null): node is FunctionNode {\n  return Boolean(\n    node && node.type === 'Function' && node.name === 'anchor-size',\n  );\n}\n\nfunction isVarFunction(node: CssNode | null): node is FunctionNode {\n  return Boolean(node && node.type === 'Function' && node.name === 'var');\n}\n\nexport function isIdentifier(node: CssNode): node is Identifier {\n  return Boolean(node.type === 'Identifier' && node.name);\n}\n\nfunction isPercentage(node: CssNode): node is Percentage {\n  return Boolean(node.type === 'Percentage' && node.value);\n}\n\nfunction parseAnchorFn(\n  node: FunctionNode,\n  replaceCss?: boolean,\n): AnchorFunction {\n  let anchorName: string | undefined,\n    anchorSide: AnchorSide | undefined,\n    anchorSize: AnchorSize | undefined,\n    fallbackValue = '',\n    foundComma = false,\n    customPropName: string | undefined;\n\n  const args: CssNode[] = [];\n  node.children.toArray().forEach((child) => {\n    if (foundComma) {\n      fallbackValue = `${fallbackValue}${generateCSS(child)}`;\n      return;\n    }\n    if (child.type === 'Operator' && child.value === ',') {\n      foundComma = true;\n      return;\n    }\n    args.push(child);\n  });\n\n  let [name, sideOrSize]: (CssNode | undefined)[] = args;\n  if (!sideOrSize) {\n    // If we only have one argument assume it is the (required) anchor-side/size\n    sideOrSize = name;\n    name = undefined;\n  }\n  if (name) {\n    if (isIdentifier(name) && name.name.startsWith('--')) {\n      // Store anchor name\n      anchorName = name.name;\n    } else if (isVarFunction(name) && name.children.first) {\n      // Store CSS custom prop for anchor name\n      customPropName = (name.children.first as Identifier).name;\n    }\n  }\n  if (sideOrSize) {\n    if (isAnchorFunction(node)) {\n      if (isIdentifier(sideOrSize) && isAnchorSide(sideOrSize.name)) {\n        anchorSide = sideOrSize.name;\n      } else if (isPercentage(sideOrSize)) {\n        const number = Number(sideOrSize.value);\n        anchorSide = Number.isNaN(number) ? undefined : number;\n      }\n    } else if (\n      isAnchorSizeFunction(node) &&\n      isIdentifier(sideOrSize) &&\n      isAnchorSize(sideOrSize.name)\n    ) {\n      anchorSize = sideOrSize.name;\n    }\n  }\n\n  const uuid = `--anchor-${nanoid(12)}`;\n  if (replaceCss) {\n    // Replace anchor function with unique CSS custom property.\n    // This allows us to update the value of the new custom property\n    // every time the position changes.\n    Object.assign(node, {\n      type: 'Raw',\n      value: `var(${uuid})`,\n      children: null,\n    });\n    Reflect.deleteProperty(node, 'name');\n  }\n\n  return {\n    anchorName,\n    anchorSide,\n    anchorSize,\n    fallbackValue: fallbackValue || '0px',\n    customPropName,\n    uuid,\n  };\n}\n\nfunction getAnchorNames(node: DeclarationWithValue) {\n  return (node.value.children as List<Identifier>).map(({ name }) => name);\n}\n\nlet anchorNames: AnchorSelectors = {};\nlet anchorScopes: AnchorSelectors = {};\n// Mapping of custom property names, to anchor function data objects referenced\n// in their values\nlet customPropAssignments: Record<string, AnchorFunction[]> = {};\n// Mapping of custom property names, to the original values that have been\n// replaced in the CSS\nlet customPropOriginals: Record<string, string> = {};\n// Top-level key (`uuid`) is the original uuid to find in the updated CSS\n// - `key` (`propUuid`) is the new property-specific uuid to append to the\n//   original custom property name\n// - `value` is the new property-specific custom property value to use\nlet customPropReplacements: Record<string, Record<string, string>> = {};\n\n// Objects are declared at top-level to keep code cleaner,\n// but we reset them on every `parseCSS()` call\n// to prevent data leaking from one call to another.\nfunction resetStores() {\n  anchorNames = {};\n  anchorScopes = {};\n  customPropAssignments = {};\n  customPropOriginals = {};\n  customPropReplacements = {};\n}\n\nfunction getAnchorFunctionData(node: CssNode, declaration: Declaration | null) {\n  if ((isAnchorFunction(node) || isAnchorSizeFunction(node)) && declaration) {\n    if (declaration.property.startsWith('--')) {\n      const original = generateCSS(declaration.value);\n      const data = parseAnchorFn(node, true);\n      // Store the original anchor function so that we can restore it later\n      customPropOriginals[data.uuid] = original;\n      customPropAssignments[declaration.property] = [\n        ...(customPropAssignments[declaration.property] ?? []),\n        data,\n      ];\n      return { changed: true };\n    }\n    if (\n      (isAnchorFunction(node) && isInsetProp(declaration.property)) ||\n      (isAnchorSizeFunction(node) &&\n        isAcceptedAnchorSizeProp(declaration.property))\n    ) {\n      const data = parseAnchorFn(node, true);\n      return { prop: declaration.property, data, changed: true };\n    }\n  }\n  return {};\n}\n\nasync function getAnchorEl(\n  targetEl: HTMLElement | null,\n  anchorObj?: AnchorFunction,\n) {\n  let anchorName = anchorObj?.anchorName;\n  const customPropName = anchorObj?.customPropName;\n  if (targetEl && !anchorName) {\n    const positionAnchorProperty = getCSSPropertyValue(\n      targetEl,\n      'position-anchor',\n    );\n\n    if (positionAnchorProperty) {\n      anchorName = positionAnchorProperty;\n    } else if (customPropName) {\n      anchorName = getCSSPropertyValue(targetEl, customPropName);\n    }\n  }\n  const anchorSelectors = anchorName ? anchorNames[anchorName] || [] : [];\n  const allScopeSelectors = anchorName\n    ? anchorScopes[AnchorScopeValue.All] || []\n    : [];\n  const anchorNameScopeSelectors = anchorName\n    ? anchorScopes[anchorName] || []\n    : [];\n  return await validatedForPositioning(\n    targetEl,\n    anchorName || null,\n    anchorSelectors,\n    [...allScopeSelectors, ...anchorNameScopeSelectors],\n  );\n}\n\nexport async function parseCSS(styleData: StyleData[]) {\n  const anchorFunctions: AnchorFunctionDeclarations = {};\n  const positionAreas: PositionAreaDeclarations = {};\n  resetStores();\n\n  // Parse `position-try` and related declarations/rules\n  const { fallbackTargets, validPositions } = parsePositionFallbacks(styleData);\n\n  for (const styleObj of styleData) {\n    let changed = false;\n    const ast = getAST(styleObj.css);\n    walk(ast, function (node) {\n      const rule = this.rule?.prelude as SelectorList | undefined;\n      const selectors = getSelectors(rule);\n\n      // Parse `anchor-name` declaration\n      if (isAnchorNameDeclaration(node) && selectors.length) {\n        for (const name of getAnchorNames(node)) {\n          anchorNames[name] ??= [];\n          anchorNames[name].push(...selectors);\n        }\n      }\n\n      // Parse `anchor-scope` declarations\n      if (isAnchorScopeDeclaration(node) && selectors.length) {\n        for (const name of getAnchorNames(node)) {\n          anchorScopes[name] ??= [];\n          anchorScopes[name].push(...selectors);\n        }\n      }\n\n      // Parse `anchor()` function\n      const {\n        prop,\n        data,\n        changed: updated,\n      } = getAnchorFunctionData(node, this.declaration);\n      if (prop && data && selectors.length) {\n        // This will override earlier declarations\n        // with the same exact rule selector\n        // *and* the same exact declaration property:\n        // (e.g. multiple `top: anchor(...)` declarations\n        // for the same `.foo {...}` selector)\n        for (const { selector } of selectors) {\n          anchorFunctions[selector] = {\n            ...anchorFunctions[selector],\n            [prop]: [...(anchorFunctions[selector]?.[prop] ?? []), data],\n          };\n        }\n      }\n\n      let positionAreaDeclaration: PositionAreaDeclaration | undefined;\n      if (this.block) {\n        positionAreaDeclaration = getPositionAreaDeclaration(node);\n        if (positionAreaDeclaration) {\n          addPositionAreaDeclarationBlockStyles(\n            positionAreaDeclaration,\n            this.block,\n          );\n          for (const { selector } of selectors) {\n            positionAreas[selector] = [\n              ...(positionAreas[selector] ?? []),\n              positionAreaDeclaration,\n            ];\n          }\n        }\n      }\n      if (updated || positionAreaDeclaration) {\n        changed = true;\n      }\n    });\n    if (changed) {\n      // Update CSS\n      styleObj.css = generateCSS(ast);\n      styleObj.changed = true;\n    }\n  }\n\n  // List of CSS custom properties that include anchor fns\n  const customPropsToCheck = new Set(Object.keys(customPropAssignments));\n  // Mapping of a custom property name, to the name(s) and uuid(s) of other\n  // custom properties \"up\" the chain that contain (eventually) a reference to\n  // an anchor function\n  const customPropsMapping: Record<\n    // custom property name\n    string,\n    // other custom property name(s) and uuid(s) referenced by this custom prop\n    { names: string[]; uuids: string[] }\n  > = {};\n\n  // Find (recursively) anchor data assigned to another custom property, and\n  // that custom property is referenced by (i.e. passed through) the given\n  // custom property\n  const getReferencedFns = (prop: string) => {\n    const referencedFns: AnchorFunction[] = [];\n    const ancestorProps = new Set(customPropsMapping[prop]?.names ?? []);\n    while (ancestorProps.size > 0) {\n      for (const prop of ancestorProps) {\n        referencedFns.push(...(customPropAssignments[prop] ?? []));\n        ancestorProps.delete(prop);\n        if (customPropsMapping[prop]?.names?.length) {\n          // Continue checking recursively \"up\" the chain of custom properties\n          customPropsMapping[prop].names.forEach((n) => ancestorProps.add(n));\n        }\n      }\n    }\n    return referencedFns;\n  };\n\n  // First find where CSS custom properties are used in other custom properties\n  while (customPropsToCheck.size > 0) {\n    const toCheckAgain: string[] = [];\n    for (const styleObj of styleData) {\n      let changed = false;\n      const ast = getAST(styleObj.css);\n      walk(ast, {\n        visit: 'Function',\n        enter(node) {\n          const rule = this.rule?.prelude as SelectorList | undefined;\n          const declaration = this.declaration;\n          const prop = declaration?.property;\n          if (\n            rule?.children.isEmpty === false &&\n            isVarFunction(node) &&\n            declaration &&\n            prop &&\n            node.children.first &&\n            customPropsToCheck.has((node.children.first as Identifier).name) &&\n            // For now, we only want assignments to other CSS custom properties\n            prop.startsWith('--')\n          ) {\n            const child = node.children.first as Identifier;\n            // Find anchor data assigned to this custom property\n            const anchorFns = customPropAssignments[child.name] ?? [];\n            // Find anchor data assigned to another custom property referenced\n            // by this custom property (recursively)\n            const referencedFns = getReferencedFns(child.name);\n\n            // Return if there are no anchor fns related to this custom property\n            if (!(anchorFns.length || referencedFns.length)) {\n              return;\n            }\n\n            // An anchor fn was assigned to a custom property, which is\n            // now being re-assigned to another custom property...\n            const uuid = `${child.name}-anchor-${nanoid(12)}`;\n            // Store the original declaration so that we can restore it later\n            const original = generateCSS(declaration.value);\n            customPropOriginals[uuid] = original;\n            // Store a mapping of the new property to the original property\n            // name, as well as the unique uuid(s) temporarily used to replace\n            // the original property value.\n            if (!customPropsMapping[prop]) {\n              customPropsMapping[prop] = { names: [], uuids: [] };\n            }\n            const mapping = customPropsMapping[prop];\n            if (!mapping.names.includes(child.name)) {\n              mapping.names.push(child.name);\n            }\n            mapping.uuids.push(uuid);\n            // Note that we need to do another pass of the CSS looking for\n            // usage of the new property name:\n            toCheckAgain.push(prop);\n            // Temporarily replace the original property with a new unique key\n            child.name = uuid;\n            changed = true;\n          }\n        },\n      });\n      if (changed) {\n        // Update CSS\n        styleObj.css = generateCSS(ast);\n        styleObj.changed = true;\n      }\n    }\n    customPropsToCheck.clear();\n    toCheckAgain.forEach((s) => customPropsToCheck.add(s));\n  }\n\n  // Then find where CSS custom properties are used in inset/sizing properties:\n  for (const styleObj of styleData) {\n    let changed = false;\n    const ast = getAST(styleObj.css);\n    walk(ast, {\n      visit: 'Function',\n      enter(node) {\n        const rule = this.rule?.prelude as SelectorList | undefined;\n        const declaration = this.declaration;\n        const prop = declaration?.property;\n\n        if (\n          rule?.children.isEmpty === false &&\n          isVarFunction(node) &&\n          declaration &&\n          prop &&\n          node.children.first &&\n          // Now we only want assignments to inset/sizing properties\n          (isInsetProp(prop) || isSizingProp(prop))\n        ) {\n          const child = node.children.first as Identifier;\n          // Find anchor data assigned to this custom property\n          const anchorFns = customPropAssignments[child.name] ?? [];\n          // Find anchor data assigned to another custom property referenced\n          // by this custom property (recursively)\n          const referencedFns = getReferencedFns(child.name);\n\n          // Return if there are no anchor fns related to this custom property\n          if (!(anchorFns.length || referencedFns.length)) {\n            return;\n          }\n\n          /*\n            An anchor (or anchor-size) fn was assigned to an inset (or sizing)\n            property.\n\n            It's possible that there are multiple uses of the same CSS\n            custom property name, with different anchor function calls\n            assigned to them. Instead of trying to figure out which one has\n            cascaded to the given location, we iterate over all anchor\n            functions that were assigned to the given CSS custom property\n            name. For each one, we add a new custom prop with the value\n            for that target and inset/sizing property, and let CSS determine\n            which one cascades down to where it's used.\n\n            For example, this:\n\n              .one {\n                --center: anchor(--anchor-name 50%);\n              }\n\n              .two {\n                --center: anchor(--anchor-name 100%);\n              }\n\n              #target {\n                top: var(--center);\n              }\n\n            Becomes this:\n\n              .one {\n                --center-top-EnmDEkZ5mBLp: var(--anchor-aPyy7qLK9f38-top);\n                --center: anchor(--anchor-name 50%);\n              }\n\n              .two {\n                --center-top-EnmDEkZ5mBLp: var(--anchor-SgrF5vARDf6H-top);\n                --center: anchor(--anchor-name 100%);\n              }\n\n              #target {\n                top: var(--center-top-EnmDEkZ5mBLp);\n              }\n          */\n          const propUuid = `${prop}-${nanoid(12)}`;\n\n          // If this is a custom property which was assigned a value from\n          // another custom property (and not a direct reference to an anchor\n          // fn), we want to replace the reference to its \"parent\" property with\n          // a direct reference to the resolved value of the parent property for\n          // this given inset/sizing property (e.g. top or width). We do this\n          // recursively back up the chain of references...\n          if (referencedFns.length) {\n            const ancestorProps = new Set([child.name]);\n            while (ancestorProps.size > 0) {\n              for (const propToCheck of ancestorProps) {\n                const mapping = customPropsMapping[propToCheck];\n                if (mapping?.names?.length && mapping?.uuids?.length) {\n                  for (const name of mapping.names) {\n                    for (const uuid of mapping.uuids) {\n                      // Top-level key (`uuid`) is the original uuid to find in\n                      // the updated CSS\n                      customPropReplacements[uuid] = {\n                        ...customPropReplacements[uuid],\n                        // - `key` (`propUuid`) is the property-specific\n                        //   uuid to append to the new custom property name\n                        // - `value` is the new property-specific custom\n                        //   property value to use\n                        [propUuid]: `${name}-${propUuid}`,\n                      };\n                    }\n                  }\n                }\n                ancestorProps.delete(propToCheck);\n                // Check (recursively) for custom properties up the chain...\n                if (mapping?.names?.length) {\n                  mapping.names.forEach((n) => ancestorProps.add(n));\n                }\n              }\n            }\n          }\n\n          // When `anchor()` is used multiple times in different inset/sizing\n          // properties, the value will be different each time. So we append\n          // the property to the uuid, and update the CSS property to point\n          // to the new uuid...\n          const selectors = getSelectors(rule);\n\n          for (const anchorFnData of [...anchorFns, ...referencedFns]) {\n            const data = { ...anchorFnData };\n            const uuidWithProp = `--anchor-${nanoid(12)}-${prop}`;\n            const uuid = data.uuid;\n            data.uuid = uuidWithProp;\n\n            for (const { selector } of selectors) {\n              anchorFunctions[selector] = {\n                ...anchorFunctions[selector],\n                [prop]: [...(anchorFunctions[selector]?.[prop] ?? []), data],\n              };\n            }\n            // Store new name with declaration prop appended,\n            // so that we can go back and update the original custom\n            // property value...\n            // Top-level key (`uuid`) is the original uuid to find in\n            // the updated CSS:\n            customPropReplacements[uuid] = {\n              ...customPropReplacements[uuid],\n              // - `key` (`propUuid`) is the property-specific\n              //   uuid to append to the new custom property name\n              // - `value` is the new property-specific custom\n              //   property value to use\n              [propUuid]: uuidWithProp,\n            };\n          }\n          // Update CSS property to new name with declaration prop added\n          child.name = `${child.name}-${propUuid}`;\n          changed = true;\n        }\n      },\n    });\n    if (changed) {\n      // Update CSS\n      styleObj.css = generateCSS(ast);\n      styleObj.changed = true;\n    }\n  }\n\n  // Add new CSS custom properties, and restore original values of\n  // previously-replaced custom properties\n  if (Object.keys(customPropReplacements).length > 0) {\n    for (const styleObj of styleData) {\n      let changed = false;\n      const ast = getAST(styleObj.css);\n      walk(ast, {\n        visit: 'Function',\n        enter(node) {\n          if (\n            isVarFunction(node) &&\n            (node.children.first as Identifier)?.name?.startsWith('--') &&\n            this.declaration?.property?.startsWith('--') &&\n            this.block\n          ) {\n            const child = node.children.first as Identifier;\n            const positions = customPropReplacements[child.name];\n            if (positions) {\n              for (const [propUuid, value] of Object.entries(positions)) {\n                // Add new property-specific declarations\n                this.block.children.appendData({\n                  type: 'Declaration',\n                  important: false,\n                  property: `${this.declaration.property}-${propUuid}`,\n                  value: {\n                    type: 'Raw',\n                    value: generateCSS(this.declaration.value).replace(\n                      `var(${child.name})`,\n                      `var(${value})`,\n                    ),\n                  },\n                });\n                changed = true;\n              }\n            }\n            if (customPropOriginals[child.name]) {\n              // Restore original (now unused) CSS custom property value\n              this.declaration.value = {\n                type: 'Raw',\n                value: customPropOriginals[child.name],\n              };\n              changed = true;\n            }\n          }\n        },\n      });\n      if (changed) {\n        // Update CSS\n        styleObj.css = generateCSS(ast);\n        styleObj.changed = true;\n      }\n    }\n  }\n\n  // Store inline style custom property mappings for each target element\n  const inlineStyles = new Map<HTMLElement, Record<string, string>>();\n  // Store any `anchor()` fns\n  for (const [targetSel, anchorFns] of Object.entries(anchorFunctions)) {\n    let targets: NodeListOf<HTMLElement>;\n    if (\n      targetSel.startsWith('[data-anchor-polyfill=') &&\n      fallbackTargets[targetSel]?.length\n    ) {\n      // If we're dealing with a `@position-try` block,\n      // then the targets are places where that `position-fallback` is used.\n      targets = document.querySelectorAll(fallbackTargets[targetSel].join(','));\n    } else {\n      targets = document.querySelectorAll(targetSel);\n    }\n    for (const [targetProperty, anchorObjects] of Object.entries(anchorFns) as [\n      InsetProperty | SizingProperty,\n      AnchorFunction[],\n    ][]) {\n      for (const anchorObj of anchorObjects) {\n        for (const targetEl of targets) {\n          // For every target element, find a valid anchor element\n          const anchorEl = await getAnchorEl(targetEl, anchorObj);\n          const uuid = `--anchor-${nanoid(12)}`;\n          // Store new mapping, in case inline styles have changed and will\n          // be overwritten -- in which case new mappings will be re-added\n          inlineStyles.set(targetEl, {\n            ...(inlineStyles.get(targetEl) ?? {}),\n            [anchorObj.uuid]: uuid,\n          });\n          // Point original uuid to new uuid\n          targetEl.setAttribute(\n            'style',\n            `${anchorObj.uuid}: var(${uuid}); ${\n              targetEl.getAttribute('style') ?? ''\n            }`,\n          );\n          // Populate new data for each anchor/target combo\n          validPositions[targetSel] = {\n            ...validPositions[targetSel],\n            declarations: {\n              ...validPositions[targetSel]?.declarations,\n              [targetProperty]: [\n                ...(validPositions[targetSel]?.declarations?.[\n                  targetProperty as InsetProperty\n                ] ?? []),\n                { ...anchorObj, anchorEl, targetEl, uuid },\n              ],\n            },\n          };\n        }\n      }\n    }\n  }\n\n  // Create a new stylesheet for the position-area mapping styles\n  const positionAreaMappingStyleElement: StyleData = {\n    el: document.createElement('link'),\n    changed: false,\n    created: true,\n    css: '',\n  };\n  styleData.push(positionAreaMappingStyleElement);\n\n  // We loop through each selector that has been used to apply a position-area\n  // declaration, and find all elements that match the selector. The same\n  // selector may be used twice, for instance:\n  //\n  // .foo { position-area: start }\n  // .foo { position-area: end }\n\n  for (const [targetSel, positions] of Object.entries(positionAreas)) {\n    const targets: NodeListOf<HTMLElement> =\n      document.querySelectorAll(targetSel);\n    for (const targetEl of targets) {\n      // For every target element, find a valid anchor element.\n      const anchorEl = await getAnchorEl(targetEl);\n      // For every position-area declaration with this selector, create a new\n      // UUID, and make sure the target has a wrapper.\n      for (const positionData of positions) {\n        const targetData = await dataForPositionAreaTarget(\n          targetEl,\n          positionData,\n          anchorEl,\n        );\n        positionAreaMappingStyleElement.css += activeWrapperStyles(\n          targetData.targetUUID,\n          positionData.selectorUUID,\n        );\n        positionAreaMappingStyleElement.changed = true;\n        // Populate new data for each anchor/target combo\n        validPositions[targetSel] = {\n          ...validPositions[targetSel],\n          declarations: {\n            ...validPositions[targetSel]?.declarations,\n            'position-area': [\n              ...(validPositions[targetSel]?.declarations?.['position-area'] ??\n                []),\n              targetData,\n            ],\n          },\n        };\n      }\n    }\n  }\n\n  return { rules: validPositions, inlineStyles, anchorScopes };\n}\n","import { type StyleData } from './utils.js';\n\n// This is a list of non-global attributes that apply to link elements but do\n// not apply to style elements. These should be removed when converting from a\n// link element to a style element. These mostly define loading behavior, which\n// is not relevant to style elements or our use case.\nconst excludeAttributes = [\n  'as',\n  'blocking',\n  'crossorigin',\n  // 'disabled' is not relevant for style elements, but this exclusion is\n  // theoretical, as a <link rel=stylesheet disabled> will not be loaded, and\n  // will not reach this part of the polyfill. See #246.\n  'disabled',\n  'fetchpriority',\n  'href',\n  'hreflang',\n  'integrity',\n  'referrerpolicy',\n  'rel',\n  'type',\n];\n\nexport function transformCSS(\n  styleData: StyleData[],\n  inlineStyles?: Map<HTMLElement, Record<string, string>>,\n  cleanup = false,\n) {\n  const updatedStyleData: StyleData[] = [];\n  for (const { el, css, changed, created = false } of styleData) {\n    const updatedObject: StyleData = { el, css, changed: false };\n    if (changed) {\n      if (el.tagName.toLowerCase() === 'style') {\n        // Handle inline stylesheets\n        el.innerHTML = css;\n      } else if (el instanceof HTMLLinkElement) {\n        // Replace link elements with style elements.\n        // We use inline style elements rather than link elements with blob\n        // URLs, as relative URLs for things like images and fonts are not\n        // supported in blob URLs. See\n        // https://github.com/oddbird/css-anchor-positioning/pull/324 for more\n        // discussion.\n        const styleEl = document.createElement('style');\n        styleEl.textContent = css;\n        for (const name of el.getAttributeNames()) {\n          if (!name.startsWith('on') && !excludeAttributes.includes(name)) {\n            const attr = el.getAttribute(name);\n            if (attr !== null) {\n              styleEl.setAttribute(name, attr);\n            }\n          }\n        }\n        // Persist the href attribute to help with potential debugging.\n        if (el.hasAttribute('href')) {\n          styleEl.setAttribute('data-original-href', el.getAttribute('href')!);\n        }\n        if (!created) {\n          // This is an existing stylesheet, so we replace it.\n          el.insertAdjacentElement('beforebegin', styleEl);\n          el.remove();\n        } else {\n          styleEl.setAttribute('data-generated-by-polyfill', 'true');\n          // This is a new stylesheet, so we append it.\n          document.head.insertAdjacentElement('beforeend', styleEl);\n        }\n        updatedObject.el = styleEl;\n      } else if (el.hasAttribute('data-has-inline-styles')) {\n        // Handle inline styles\n        const attr = el.getAttribute('data-has-inline-styles');\n        if (attr) {\n          const pre = `[data-has-inline-styles=\"${attr}\"]{`;\n          const post = `}`;\n          let styles = css.slice(pre.length, 0 - post.length);\n          // Check for custom anchor-element mapping, so it is not overwritten\n          // when inline styles are updated\n          const mappings = inlineStyles?.get(el);\n          if (mappings) {\n            for (const [key, val] of Object.entries(mappings)) {\n              styles = `${key}: var(${val}); ${styles}`;\n            }\n          }\n          el.setAttribute('style', styles);\n        }\n      }\n    }\n    // Remove no-longer-needed data-attribute\n    if (cleanup && el.hasAttribute('data-has-inline-styles')) {\n      el.removeAttribute('data-has-inline-styles');\n    }\n    updatedStyleData.push(updatedObject);\n  }\n  return updatedStyleData;\n}\n","import {\n  autoUpdate,\n  detectOverflow,\n  type MiddlewareState,\n  platform,\n  type Rect,\n  type VirtualElement,\n} from '@floating-ui/dom';\n\nimport { cascadeCSS } from './cascade.js';\nimport { getCSSPropertyValue, getOffsetParent } from './dom.js';\nimport { fetchCSS } from './fetch.js';\nimport {\n  type AnchorFunction,\n  type AnchorFunctionDeclaration,\n  type AnchorPositions,\n  parseCSS,\n  type TryBlock,\n} from './parse.js';\nimport {\n  type InsetValue,\n  POSITION_AREA_CASCADE_PROPERTY,\n  POSITION_AREA_WRAPPER_ATTRIBUTE,\n  type PositionAreaTargetData,\n} from './position-area.js';\nimport {\n  type AnchorSide,\n  type AnchorSize,\n  type InsetProperty,\n  isAcceptedAnchorSizeProp,\n  isInsetProp,\n  type SizingProperty,\n} from './syntax.js';\nimport { transformCSS } from './transform.js';\nimport { reportParseErrorsOnFailure, resetParseErrors } from './utils.js';\n\nconst platformWithCache = { ...platform, _c: new Map() };\n\nexport const resolveLogicalSideKeyword = (side: AnchorSide, rtl: boolean) => {\n  let percentage: number | undefined;\n  switch (side) {\n    case 'start':\n    case 'self-start':\n      percentage = 0;\n      break;\n    case 'end':\n    case 'self-end':\n      percentage = 100;\n      break;\n    default:\n      if (typeof side === 'number' && !Number.isNaN(side)) {\n        percentage = side;\n      }\n  }\n  if (percentage !== undefined) {\n    return rtl ? 100 - percentage : percentage;\n  }\n  return undefined;\n};\n\nexport const resolveLogicalSizeKeyword = (\n  size: AnchorSize,\n  vertical: boolean,\n) => {\n  let resolved: 'width' | 'height' | undefined;\n  switch (size) {\n    case 'block':\n    case 'self-block':\n      resolved = vertical ? 'width' : 'height';\n      break;\n    case 'inline':\n    case 'self-inline':\n      resolved = vertical ? 'height' : 'width';\n      break;\n  }\n  return resolved;\n};\n\n// This should also check the writing-mode\n// See:\n// https://github.com/oddbird/css-anchor-positioning/pull/22#discussion_r966348526\n// https://trello.com/c/KnqCnHx3\nexport const getAxis = (position?: string) => {\n  switch (position) {\n    case 'top':\n    case 'bottom':\n      return 'y';\n    case 'left':\n    case 'right':\n      return 'x';\n  }\n  return null;\n};\n\nexport const getAxisProperty = (axis: 'x' | 'y' | null) => {\n  switch (axis) {\n    case 'x':\n      return 'width';\n    case 'y':\n      return 'height';\n  }\n  return null;\n};\n\nconst isInline = (el: HTMLElement) =>\n  getCSSPropertyValue(el, 'display') === 'inline';\n\nconst getBorders = (el: HTMLElement, axis: 'x' | 'y') => {\n  const props =\n    axis === 'x'\n      ? ['border-left-width', 'border-right-width']\n      : ['border-top-width', 'border-bottom-width'];\n  return (\n    props.reduce(\n      (total, prop) => total + parseInt(getCSSPropertyValue(el, prop), 10),\n      0,\n    ) || 0\n  );\n};\n\nconst getMargin = (el: HTMLElement, dir: 'top' | 'right' | 'bottom' | 'left') =>\n  parseInt(getCSSPropertyValue(el, `margin-${dir}`), 10) || 0;\n\nconst getMargins = (el: HTMLElement) => {\n  return {\n    top: getMargin(el, 'top'),\n    right: getMargin(el, 'right'),\n    bottom: getMargin(el, 'bottom'),\n    left: getMargin(el, 'left'),\n  };\n};\n\nexport interface GetPixelValueOpts {\n  targetEl?: HTMLElement;\n  targetProperty: InsetProperty | SizingProperty | 'position-area';\n  anchorRect?: Rect;\n  anchorSide?: AnchorSide;\n  anchorSize?: AnchorSize;\n  fallback?: string | null;\n}\n\nexport const getPixelValue = async ({\n  targetEl,\n  targetProperty,\n  anchorRect,\n  anchorSide,\n  anchorSize,\n  fallback = null,\n}: GetPixelValueOpts) => {\n  if (!((anchorSize || anchorSide !== undefined) && targetEl && anchorRect)) {\n    return fallback;\n  }\n  if (anchorSize) {\n    if (!isAcceptedAnchorSizeProp(targetProperty)) {\n      return fallback;\n    }\n    // Calculate value for `anchor-size()` fn...\n    let size: AnchorSize | undefined;\n    switch (anchorSize) {\n      case 'width':\n      case 'height':\n        size = anchorSize;\n        break;\n      default: {\n        let vertical = false;\n        // Logical keywords require checking the writing-mode\n        // of the target element (or its containing block):\n        // `block` and `inline` should use the writing-mode of the element's\n        // containing block, not the element itself:\n        // https://trello.com/c/KnqCnHx3\n        const writingMode = getCSSPropertyValue(targetEl, 'writing-mode');\n        vertical =\n          writingMode.startsWith('vertical-') ||\n          writingMode.startsWith('sideways-');\n        size = resolveLogicalSizeKeyword(anchorSize, vertical);\n      }\n    }\n    if (size) {\n      return `${anchorRect[size]}px`;\n    }\n    return fallback;\n  }\n\n  if (anchorSide !== undefined) {\n    // Calculate value for `anchor()` fn...\n    let percentage: number | undefined;\n    let offsetParent;\n    const axis = getAxis(targetProperty);\n\n    // anchor() can only be assigned to inset properties,\n    // and if a physical keyword ('left', 'right', 'top', 'bottom') is used,\n    // the axis of the keyword must match the axis of the inset property:\n    // https://drafts.csswg.org/css-anchor-1/#queries\n    if (\n      !(\n        isInsetProp(targetProperty) &&\n        axis &&\n        (!isInsetProp(anchorSide) || axis === getAxis(anchorSide))\n      )\n    ) {\n      return fallback;\n    }\n    // Since the polyfill does not yet support anchor functions on `inset-*`\n    // properties, they are omitted here.\n    const startwardProperties = ['top', 'left'];\n\n    switch (anchorSide) {\n      case 'left':\n      case 'top':\n        percentage = 0;\n        break;\n      case 'right':\n      case 'bottom':\n        percentage = 100;\n        break;\n      case 'center':\n        percentage = 50;\n        break;\n      case 'inside':\n        percentage = startwardProperties.includes(targetProperty) ? 0 : 100;\n        break;\n      case 'outside':\n        percentage = startwardProperties.includes(targetProperty) ? 100 : 0;\n        break;\n      default:\n        // Logical keywords require checking the writing direction\n        // of the target element (or its containing block)\n        if (targetEl) {\n          // `start` and `end` should use the writing-mode of the element's\n          // containing block, not the element itself:\n          // https://trello.com/c/KnqCnHx3\n          const rtl = (await platform.isRTL?.(targetEl)) || false;\n          percentage = resolveLogicalSideKeyword(anchorSide, rtl);\n        }\n    }\n\n    const hasPercentage =\n      typeof percentage === 'number' && !Number.isNaN(percentage);\n\n    const dir = getAxisProperty(axis);\n    if (hasPercentage && dir) {\n      if (targetProperty === 'bottom' || targetProperty === 'right') {\n        offsetParent = await getOffsetParent(targetEl);\n      }\n      let value =\n        anchorRect[axis] + anchorRect[dir] * ((percentage as number) / 100);\n      switch (targetProperty) {\n        case 'bottom': {\n          if (!offsetParent) {\n            break;\n          }\n          let offsetHeight = offsetParent.clientHeight;\n          // This is a hack for inline elements with `clientHeight: 0`,\n          // but it doesn't take scrollbar size into account\n          if (offsetHeight === 0 && isInline(offsetParent)) {\n            const border = getBorders(offsetParent, axis);\n            offsetHeight = offsetParent.offsetHeight - border;\n          }\n          value = offsetHeight - value;\n          break;\n        }\n        case 'right': {\n          if (!offsetParent) {\n            break;\n          }\n          let offsetWidth = offsetParent.clientWidth;\n          // This is a hack for inline elements with `clientWidth: 0`,\n          // but it doesn't take scrollbar size into account\n          if (offsetWidth === 0 && isInline(offsetParent)) {\n            const border = getBorders(offsetParent, axis);\n            offsetWidth = offsetParent.offsetWidth - border;\n          }\n          value = offsetWidth - value;\n          break;\n        }\n      }\n      return `${value}px`;\n    }\n  }\n\n  return fallback;\n};\n\n// Use `isPositionAreaDeclaration` instead for type narrowing AST nodes.\nconst isPositionAreaTarget = (\n  value: AnchorFunction | PositionAreaTargetData,\n): value is PositionAreaTargetData => {\n  return 'wrapperEl' in value;\n};\n\nconst isAnchorFunction = (\n  value: AnchorFunction | PositionAreaTargetData,\n): value is AnchorFunction => {\n  return 'uuid' in value;\n};\n\nasync function applyAnchorPositions(\n  declarations: AnchorFunctionDeclaration,\n  useAnimationFrame = false,\n) {\n  const root = document.documentElement;\n\n  for (const [property, anchorValues] of Object.entries(declarations) as [\n    InsetProperty | SizingProperty | 'position-area',\n    (AnchorFunction | PositionAreaTargetData)[],\n  ][]) {\n    for (const anchorValue of anchorValues) {\n      const anchor = anchorValue.anchorEl;\n      const target = anchorValue.targetEl;\n      if (anchor && target) {\n        if (isPositionAreaTarget(anchorValue)) {\n          const wrapper = anchorValue.wrapperEl!;\n          const getPositionAreaPixelValue = async (\n            inset: InsetValue,\n            targetProperty: GetPixelValueOpts['targetProperty'],\n            anchorRect: GetPixelValueOpts['anchorRect'],\n          ) => {\n            if (inset === 0) return '0px';\n            return await getPixelValue({\n              targetEl: wrapper,\n              targetProperty: targetProperty,\n              anchorRect: anchorRect,\n              anchorSide: inset,\n            });\n          };\n\n          autoUpdate(\n            anchor,\n            wrapper,\n            async () => {\n              // Check which `position-area` declaration would win based on the\n              // cascade, and apply an attribute on the wrapper. This activates\n              // the generated CSS styles that map the inset and alignment\n              // values to their respective properties.\n              const appliedId = getCSSPropertyValue(\n                target,\n                POSITION_AREA_CASCADE_PROPERTY,\n              );\n              wrapper.setAttribute(POSITION_AREA_WRAPPER_ATTRIBUTE, appliedId);\n\n              const rects = await platform.getElementRects({\n                reference: anchor,\n                floating: wrapper,\n                strategy: 'absolute',\n              });\n              const insets = anchorValue.insets;\n\n              const topInset = await getPositionAreaPixelValue(\n                insets.block[0],\n                'top',\n                rects.reference,\n              );\n              const bottomInset = await getPositionAreaPixelValue(\n                insets.block[1],\n                'bottom',\n                rects.reference,\n              );\n              const leftInset = await getPositionAreaPixelValue(\n                insets.inline[0],\n                'left',\n                rects.reference,\n              );\n              const rightInset = await getPositionAreaPixelValue(\n                insets.inline[1],\n                'right',\n                rects.reference,\n              );\n\n              root.style.setProperty(\n                `${anchorValue.targetUUID}-top`,\n                topInset || null,\n              );\n              root.style.setProperty(\n                `${anchorValue.targetUUID}-left`,\n                leftInset || null,\n              );\n              root.style.setProperty(\n                `${anchorValue.targetUUID}-right`,\n                rightInset || null,\n              );\n              root.style.setProperty(\n                `${anchorValue.targetUUID}-bottom`,\n                bottomInset || null,\n              );\n              root.style.setProperty(\n                `${anchorValue.targetUUID}-justify-self`,\n                anchorValue.alignments.inline,\n              );\n              root.style.setProperty(\n                `${anchorValue.targetUUID}-align-self`,\n                anchorValue.alignments.block,\n              );\n            },\n            { animationFrame: useAnimationFrame },\n          );\n        } else {\n          autoUpdate(\n            anchor,\n            target,\n            async () => {\n              const rects = await platform.getElementRects({\n                reference: anchor,\n                floating: target,\n                strategy: 'absolute',\n              });\n              const resolved = await getPixelValue({\n                targetEl: target,\n                targetProperty: property,\n                anchorRect: rects.reference,\n                anchorSide: anchorValue.anchorSide,\n                anchorSize: anchorValue.anchorSize,\n                fallback: anchorValue.fallbackValue,\n              });\n              root.style.setProperty(anchorValue.uuid, resolved);\n            },\n            { animationFrame: useAnimationFrame },\n          );\n        }\n      } else if (isAnchorFunction(anchorValue)) {\n        // Use fallback value\n        const resolved = await getPixelValue({\n          targetProperty: property,\n          anchorSide: anchorValue.anchorSide,\n          anchorSize: anchorValue.anchorSize,\n          fallback: anchorValue.fallbackValue,\n        });\n        root.style.setProperty(anchorValue.uuid, resolved);\n      }\n    }\n  }\n}\n\nasync function checkOverflow(target: HTMLElement, offsetParent: HTMLElement) {\n  const rects = await platform.getElementRects({\n    reference: target,\n    floating: target,\n    strategy: 'absolute',\n  });\n  const overflow = await detectOverflow(\n    {\n      x: target.offsetLeft,\n      y: target.offsetTop,\n      platform: platformWithCache,\n      rects,\n      elements: {\n        floating: target,\n        reference: offsetParent,\n      },\n      strategy: 'absolute',\n    } as unknown as MiddlewareState,\n    {\n      padding: getMargins(target),\n    },\n  );\n  return overflow;\n}\n\nasync function applyPositionFallbacks(\n  targetSel: string,\n  fallbacks: TryBlock[],\n  useAnimationFrame = false,\n) {\n  if (!fallbacks.length) {\n    return;\n  }\n\n  const targets: NodeListOf<HTMLElement> = document.querySelectorAll(targetSel);\n\n  for (const target of targets) {\n    let checking = false;\n    const offsetParent = await getOffsetParent(target);\n\n    autoUpdate(\n      // We're just checking whether the target element overflows, so we don't\n      // care about the position of the anchor element in this case. Passing in\n      // an empty object instead of a reference element avoids unnecessarily\n      // watching for irrelevant changes.\n      {} as VirtualElement,\n      target,\n      async () => {\n        // If this auto-update was triggered while the polyfill is already\n        // looping through the possible `position-try-fallbacks` blocks, do not\n        // check again.\n        if (checking) {\n          return;\n        }\n        checking = true;\n        target.removeAttribute('data-anchor-polyfill');\n        const defaultOverflow = await checkOverflow(target, offsetParent);\n        // If none of the sides overflow, don't try fallbacks\n        if (Object.values(defaultOverflow).every((side) => side <= 0)) {\n          target.removeAttribute('data-anchor-polyfill-last-successful');\n          checking = false;\n          return;\n        }\n        // Apply the styles from each fallback block (in order), stopping when\n        // we reach one that does not cause the target's margin-box to overflow\n        // its offsetParent (containing block).\n        for (const [index, { uuid }] of fallbacks.entries()) {\n          target.setAttribute('data-anchor-polyfill', uuid);\n\n          const overflow = await checkOverflow(target, offsetParent);\n\n          // If none of the sides overflow, use this fallback and stop loop.\n          if (Object.values(overflow).every((side) => side <= 0)) {\n            target.setAttribute('data-anchor-polyfill-last-successful', uuid);\n            checking = false;\n            break;\n          }\n          // If it's the last fallback, and none have matched, revert to the\n          // last successful fallback.\n          if (index === fallbacks.length - 1) {\n            const lastSuccessful = target.getAttribute(\n              'data-anchor-polyfill-last-successful',\n            );\n            if (lastSuccessful) {\n              target.setAttribute('data-anchor-polyfill', lastSuccessful);\n            } else {\n              target.removeAttribute('data-anchor-polyfill');\n            }\n            checking = false;\n            break;\n          }\n        }\n      },\n      { animationFrame: useAnimationFrame, layoutShift: false },\n    );\n  }\n}\n\nasync function position(rules: AnchorPositions, useAnimationFrame = false) {\n  for (const pos of Object.values(rules)) {\n    // Handle `anchor()` and `anchor-size()` functions and `position-area`\n    // properties..\n    await applyAnchorPositions(pos.declarations ?? {}, useAnimationFrame);\n  }\n\n  for (const [targetSel, position] of Object.entries(rules)) {\n    // Handle `@position-try` blocks...\n    await applyPositionFallbacks(\n      targetSel,\n      position.fallbacks ?? [],\n      useAnimationFrame,\n    );\n  }\n}\n\nexport interface AnchorPositioningPolyfillOptions {\n  // Whether to use `requestAnimationFrame()` when updating target elements’\n  // positions\n  useAnimationFrame?: boolean;\n\n  // An array of explicitly targeted elements to polyfill\n  elements?: HTMLElement[];\n\n  // Whether to exclude elements with eligible inline styles. When not defined\n  // or set to `false`, the polyfill will be applied to all elements that have\n  // eligible inline styles, regardless of whether the `elements` option is\n  // defined. When set to `true`, elements with eligible inline styles listed\n  // in the `elements` option will still be polyfilled, but no other elements\n  // in the document will be implicitly polyfilled.\n  excludeInlineStyles?: boolean;\n}\n\nfunction normalizePolyfillOptions(\n  useAnimationFrameOrOption: boolean | AnchorPositioningPolyfillOptions = {},\n) {\n  const options =\n    typeof useAnimationFrameOrOption === 'boolean'\n      ? { useAnimationFrame: useAnimationFrameOrOption }\n      : useAnimationFrameOrOption;\n  const useAnimationFrame =\n    options.useAnimationFrame === undefined\n      ? Boolean(window.UPDATE_ANCHOR_ON_ANIMATION_FRAME)\n      : options.useAnimationFrame;\n\n  if (!Array.isArray(options.elements)) {\n    options.elements = undefined;\n  }\n\n  return Object.assign(options, { useAnimationFrame });\n}\n\n// Support a boolean option for backwards compatibility.\nexport async function polyfill(\n  useAnimationFrameOrOption?: boolean | AnchorPositioningPolyfillOptions,\n) {\n  const options = normalizePolyfillOptions(\n    useAnimationFrameOrOption ?? window.ANCHOR_POSITIONING_POLYFILL_OPTIONS,\n  );\n\n  // fetch CSS from stylesheet and inline style\n  let styleData = await fetchCSS(options.elements, options.excludeInlineStyles);\n\n  let rules: AnchorPositions = {};\n  let inlineStyles: Map<HTMLElement, Record<string, string>> | undefined;\n\n  // Reset the CSS parse errors in case the polyfill is run multiple times, and\n  // at the beginning in case a previous run failed.\n  resetParseErrors();\n\n  // If the polyfill fails during the steps in the try catch, it is likely due\n  // to invalid CSS, so report the CSS parse errors. Subsequent errors are less\n  // likely to be caused by parse errors.\n  try {\n    // pre parse CSS styles that we need to cascade\n    const cascadeCausedChanges = cascadeCSS(styleData);\n    if (cascadeCausedChanges) {\n      styleData = transformCSS(styleData);\n    }\n    // parse CSS\n    const parsedCSS = await parseCSS(styleData);\n    rules = parsedCSS.rules;\n    inlineStyles = parsedCSS.inlineStyles;\n  } catch (error) {\n    reportParseErrorsOnFailure();\n    throw error;\n  }\n\n  if (Object.values(rules).length) {\n    // update source code\n    transformCSS(styleData, inlineStyles, true);\n\n    // calculate position values\n    await position(rules, options.useAnimationFrame);\n  }\n\n  return rules;\n}\n","import { polyfill } from './polyfill.js';\n\n// apply polyfill\nif (document.readyState !== 'complete') {\n  window.addEventListener('load', () => {\n    polyfill();\n  });\n} else {\n  polyfill();\n}\n"],"names":["min","max","round","floor","createCoords","v","evaluate","value","param","expandPaddingObject","padding","__spreadValues","getPaddingObject","rectToClientRect","rect","x","y","width","height","detectOverflow","state","options","__async","_await$platform$isEle","platform","rects","elements","strategy","boundary","rootBoundary","elementContext","altBoundary","paddingObject","element","clippingClientRect","offsetParent","offsetScale","elementClientRect","hasWindow","getNodeName","node","isNode","getWindow","_node$ownerDocument","getDocumentElement","_ref","isElement","isHTMLElement","isShadowRoot","isOverflowElement","overflow","overflowX","overflowY","display","getComputedStyle","isTableElement","isTopLayer","selector","e","isContainingBlock","elementOrCss","webkit","isWebKit","css","getContainingBlock","currentNode","getParentNode","isLastTraversableNode","getNodeScroll","result","getNearestOverflowAncestor","parentNode","getOverflowAncestors","list","traverseIframes","_node$ownerDocument2","scrollableAncestor","isBody","win","frameElement","getFrameElement","getCssDimensions","hasOffset","offsetWidth","offsetHeight","shouldFallback","unwrapElement","getScale","domElement","$","noOffsets","getVisualOffsets","shouldAddVisualOffsets","isFixed","floatingOffsetParent","getBoundingClientRect","includeScale","isFixedStrategy","clientRect","scale","visualOffsets","offsetWin","currentWin","currentIFrame","iframeScale","iframeRect","left","top","getWindowScrollBarX","leftScroll","getHTMLOffset","documentElement","scroll","ignoreScrollbarX","htmlRect","convertOffsetParentRelativeRectToViewportRelativeRect","topLayer","offsets","isOffsetParentAnElement","offsetRect","htmlOffset","getClientRects","getDocumentRect","html","body","getViewportRect","visualViewport","visualViewportBased","getInnerBoundingClientRect","getClientRectFromClippingAncestor","clippingAncestor","hasFixedPositionAncestor","stopNode","getClippingElementAncestors","cache","cachedResult","el","currentContainingBlockComputedStyle","elementIsFixed","computedStyle","currentNodeIsContaining","ancestor","getClippingRect","clippingAncestors","firstClippingAncestor","clippingRect","accRect","getDimensions","getRectRelativeToOffsetParent","setLeftRTLScrollbarOffset","isStaticPositioned","getTrueOffsetParent","polyfill","rawOffsetParent","getOffsetParent","svgOffsetParent","getElementRects","data","getOffsetParentFn","getDimensionsFn","floatingDimensions","isRTL","rectsAreEqual","a","b","observeMove","onMove","io","timeoutId","root","cleanup","_io","refresh","skip","threshold","elementRectForRootMargin","insetTop","insetRight","insetBottom","insetLeft","isFirstUpdate","handleObserve","entries","ratio","__spreadProps","_e","autoUpdate","reference","floating","update","ancestorScroll","ancestorResize","elementResize","layoutShift","animationFrame","referenceEl","ancestors","cleanupIo","reobserveFrame","resizeObserver","firstEntry","_resizeObserver","frameId","prevRefRect","frameLoop","nextRefRect","_resizeObserver2","detectOverflow$1","hasOwnProperty","noop","ensureFunction","invokeForType","fn","type","item","getWalkersFromStructure","name","nodeType","structure","walkers","key","fieldTypes","walker","fieldType","getTypesFromConfig","config","types","createTypeIterator","reverse","fields","contextName","useContext","context","walk","walkReducer","prevContextValue","field","ref","createFastTraveralMap","StyleSheet","Atrule","Rule","Block","DeclarationList","createWalker","iteratorsNatural","iteratorsReverse","breakWalk","skipNode","fastTraversalIteratorsNatural","fastTraversalIteratorsReverse","walkNode","enterRet","enter","iterators","leave","ret","ast","found","EOF","Ident","Function","AtKeyword","Hash","String","BadString","Url","BadUrl","Delim","Number","Percentage","Dimension","WhiteSpace","CDO","CDC","Colon","Semicolon","Comma","LeftSquareBracket","RightSquareBracket","LeftParenthesis","RightParenthesis","LeftCurlyBracket","RightCurlyBracket","Comment","isDigit","code","isHexDigit","isUppercaseLetter","isLowercaseLetter","isLetter","isNonAscii","isNameStart","isName","isNonPrintable","isNewline","isWhiteSpace","isValidEscape","first","second","isIdentifierStart","third","isNumberStart","isBOM","CATEGORY","EofCategory","WhiteSpaceCategory","DigitCategory","NameStartCategory","NonPrintableCategory","i","charCodeCategory","getCharCode","source","offset","getNewlineLength","cmpChar","testStr","referenceCode","cmpStr","start","end","referenceStr","testCode","findWhiteSpaceStart","findWhiteSpaceEnd","findDecimalNumberEnd","consumeEscaped","maxOffset","consumeName","consumeNumber","sign","consumeBadUrlRemnants","decodeEscaped","escaped","tokenNames","MIN_SIZE","adoptBuffer","buffer","size","N","F","R","computeLinesAndColumns","host","sourceLength","startOffset","lines","columns","line","column","OffsetToLocation","startLine","startColumn","filename","OFFSET_MASK","TYPE_SHIFT","balancePair","FunctionToken","isBlockOpenerToken","tokenType","TokenStream","tokenize","offsetAndType","balance","tokenCount","firstCharOffset","balanceCloseType","balanceStart","index","prevBalanceStart","balanceEnd","idx","tokenIndex","pos","next","startToken","stopConsume","cursor","loop","tokens","onToken","consumeNumericToken","TYPE.Dimension","TYPE.Percentage","TYPE.Number","consumeIdentLikeToken","nameStartOffset","TYPE.Function","consumeUrlToken","TYPE.Ident","consumeStringToken","endingCodePoint","TYPE.String","TYPE.BadString","nextCode","TYPE.Url","TYPE.BadUrl","TYPE.WhiteSpace","TYPE.Hash","TYPE.Delim","TYPE.LeftParenthesis","TYPE.RightParenthesis","TYPE.Comma","TYPE.CDC","TYPE.Comment","TYPE.Colon","TYPE.Semicolon","TYPE.CDO","TYPE.AtKeyword","TYPE.LeftSquareBracket","TYPE.RightSquareBracket","TYPE.LeftCurlyBracket","TYPE.RightCurlyBracket","PLUSSIGN","HYPHENMINUS","DISALLOW_SIGN","ALLOW_SIGN","checkInteger","disallowSign","checkTokenIsInteger","expectCharCode","msg","consumeB","parse","generate","consumeRaw","isDeclarationBlockAtrule","walkContext","isDeclaration","nameLowerCase","prelude","block","children","DOLLARSIGN","ASTERISK","EQUALSSIGN","CIRCUMFLEXACCENT","VERTICALLINE","TILDE","getAttributeName","expectIdent","getOperator","matcher","flags","StringToken","AMPERSAND","consumeRule","consumeRawDeclaration","consumeDeclaration","isStyleBlock","consumer","scan","prev","readSequence","recognizer","FULLSTOP","SOLIDUS","GREATERTHANSIGN","likelyFeatureToken","featureOrRange","kind","parentheses","term","res","child","isCustomProperty","str","EXCLAMATIONMARK","NUMBERSIGN","consumeValueRaw","consumeCustomPropertyRaw","consumeValue","startValueToken","property","readProperty","customProperty","parseValue","important","valueStart","getImportant","getFeatureParser","parser","functionName","valueParser","LESSTHANSIGN","readTerm","readComparison","expectColon","leftComparison","middle","rightComparison","right","xxx","tokenStart","modifier","mediaType","condition","ident","identLowerCase","nth","NumberToken","consumeTerm","getOffsetExcludeWS","consumeUntil","excludeWhiteSpace","endOffset","consumePrelude","limit","REVERSE_SOLIDUS","QUOTATION_MARK","APOSTROPHE","decode","len","firstChar","decoded","escapeStart","escapeEnd","encode","apostrophe","quote","quoteCode","encoded","wsBeforeHexIsNeeded","declaration","eatIdentifierOrAsterisk","QUESTIONMARK","eatHexSequence","allowDash","eatQuestionMarkSequence","count","startsWith","scanUnicodeRange","hexLength","SPACE","LEFTPARENTHESIS","RIGHTPARENTHESIS","url.decode","string.decode","url.encode","INSET_PROPS","isInsetProp","MARGIN_PROPERTIES","isMarginProp","SIZING_PROPS","isSizingProp","SELF_ALIGNMENT_PROPS","isSelfAlignmentProp","ACCEPTED_POSITION_TRY_PROPERTIES","ACCEPTED_ANCHOR_SIZE_PROPERTIES","isAcceptedAnchorSizeProp","ANCHOR_SIDES","isAnchorSide","ANCHOR_SIZES","isAnchorSize","trackNodes","generateSourceMap","handlers","map","generated","original","activatedGenerated","activatedMapping","sourceMappingActive","origHandlersNode","nodeLine","nodeColumn","origHandlersEmit","auto","origHandlersResult","charCode","specPairs","safePairs","createMap","pairs","isWhiteSpaceRequired","prevCode","nextCharCode","spec","safe","REVERSESOLIDUS","processChildren","delimeter","processChunk","chunk","createGenerator","publicApi","tokenBefore.safe","tokenBefore","releasedCursors","List","prevOld","prevNew","nextOld","nextNew","array","thisArg","initialValue","acc","before","oldItem","newItemOrList","createCustomError","message","error","errorStack","MAX_LINE_LENGTH","OFFSET_CORRECTION","TAB_REPLACEMENT","sourceFragment","baseLine","baseColumn","extraLines","processLines","maxNumLength","prelines","precolumns","endLine","cutLeft","SyntaxError","space","NOOP","SEMICOLON","LEFTCURLYBRACKET","NULL","createParseContext","fetchParseValues","dict","processConfig","parseConfig","createParser","needPositions","onParseError","onParseErrorThrow","locationMap","fallback","startIndex","fallbackNode","offsetStart","offsetEnd","number","tokenName","m","head","tail","location","source_","onComment","loc","U","defaultRecognizer","atrulePrelude","getNode","onWhiteSpace","selector$1","expressionFn","varFn","isPlusMinusOperator","nonContainerNameKeywords","container","nested","fontFace","parseWithFallback","parseFunctions","atrule","parseLanguageRangeList","selectorList","identList","langList","scope","clone","urlAlphabet","nanoid","id","INSTANCE_UUID","cssParseErrors","isAnchorFunction","getAST","cssText","captureErrors","err","generateCSS","splitCommaList","getSelectors","rule","pseudoElementPart","_a","elementPart","reportParseErrorsOnFailure","resetParseErrors","SHIFTED_PROPERTIES","prop","shiftUnsupportedProperties","cascadeCSS","styleData","styleObj","changed","updated","AnchorScopeValue","getCSSPropertyValue","hasStyle","cssProperty","createFakePseudoElement","fakePseudoElement","sheet","insertionPoint","findFirstScrollingElement","currentElement","getContainerScrollPosition","containerScrollPosition","getElementsBySelector","boundingClientRect","startingScrollY","startingScrollX","scrollY","scrollX","scrollTop","scrollLeft","hasAnchorName","anchorName","computedAnchorName","hasAnchorScope","computedAnchorScope","_b","_c","INVALID_MIME_TYPE_ERROR","isStyleLink","link","getStylesheetUrl","srcUrl","fetchLinkedStylesheets","sources","response","loaded","ELEMENTS_WITH_INLINE_ANCHOR_STYLES_QUERY","ELEMENTS_WITH_INLINE_POSITION_AREA","fetchInlineStyles","elementsWithInlineAnchorStyles","inlineStyles","dataAttribute","styles","fetchCSS","excludeInlineStyles","targetElements","url","elementsForInlines","inlines","bytes","scopedUrlAlphabet","POSITION_AREA_CASCADE_PROPERTY","POSITION_AREA_WRAPPER_ATTRIBUTE","WRAPPER_TARGET_ATTRIBUTE_PRELUDE","WRAPPER_ELEMENT","POSITION_AREA_PROPS","isPositionAreaProp","POSITION_AREA_SPANS","POSITION_AREA_X","POSITION_AREA_Y","POSITION_AREA_BLOCK","POSITION_AREA_INLINE","POSITION_AREA_SELF_BLOCK","POSITION_AREA_SELF_INLINE","POSITION_AREA_SHORTHAND","POSITION_AREA_SELF_SHORTHAND","BLOCK_KEYWORDS","INLINE_KEYWORDS","axisForPositionAreaValue","parts","part","isValidPositionAreaPair","validPairs","isValidPositionAreaValue","pair","getDirectionalStyles","getWritingMode","flipValues","values","getRelevantWritingMode","inline","getWritingModeModifiedGrid","_0","_1","targetElement","relevantWritingMode","writingMode","grid","temp","getInsets","blockValues","inlineValues","getAxisAlignment","isPositionAreaDeclaration","parsePositionAreaValue","getPositionAreaDeclaration","positionAreas","selectorUUID","addPositionAreaDeclarationBlockStyles","wrapperForPositionedElement","targetEl","targetUUID","wrapperEl","originalPointerEvents","dataForPositionAreaTarget","positionAreaData","anchorEl","writingModeModifiedGrid","insets","alignmentGrid","alignments","activeWrapperStyles","POSITION_TRY_ORDERS","POSITION_TRY_TACTICS","isPositionTryFallbacksDeclaration","isPositionTryOrderDeclaration","isPositionTryDeclaration","isPositionTryAtRule","isPositionTryTactic","isPositionTryOrder","applyTryTacticsToSelector","tactics","rules","getExistingInsetRules","tactic","applyTryTacticToBlock","applyTryTacticsToAtRule","propVal","tryTacticsPropertyMapping","anchorSideMapping","PositionAreaPropertyMapping","mapProperty","mapAnchorSide","side","mapPositionArea","mapping","mapMargin","valueAst","fourth","getValueAST","val","declarations","_key","newKey","isIdentifier","parsePositionTryFallbacks","positionOptions","tryObjects","option","identifiers","opt","getPositionTryFallbacksDeclaration","getPositionTryDeclaration","declarationNode","order","firstName","getPositionTryOrderDeclaration","getPositionFallbackValues","orderDeclaration","optionsNames","isAcceptedPositionTryProperty","getPositionTryRules","d","tryBlock","parsePositionFallbacks","fallbacks","fallbackTargets","validPositions","fallbacksAdded","selectors","anchorPosition","tryObject","tacticAppliedRules","dataAttr","isContainingBlockDescendant","containingBlock","anchor","isWindow","isFixedPositioned","isAbsolutelyPositioned","precedes","self","other","getFormattingContext","currentParent","isAcceptableAnchorElement","queryEl","scopeSelector","elContainingBlock","queryElContainingBlock","currentCB","anchorCBchain","lastInChain","getScope","validatedForPositioning","anchorSelectors","scopeSelectors","anchorElements","s","isPseudoElement","isAnchorNameDeclaration","isAnchorScopeDeclaration","isAnchorSizeFunction","isVarFunction","isPercentage","parseAnchorFn","replaceCss","anchorSide","anchorSize","fallbackValue","foundComma","customPropName","args","sideOrSize","uuid","getAnchorNames","anchorNames","anchorScopes","customPropAssignments","customPropOriginals","customPropReplacements","resetStores","getAnchorFunctionData","getAnchorEl","anchorObj","positionAnchorProperty","allScopeSelectors","anchorNameScopeSelectors","parseCSS","anchorFunctions","_d","positionAreaDeclaration","_f","customPropsToCheck","customPropsMapping","getReferencedFns","referencedFns","ancestorProps","n","toCheckAgain","anchorFns","propUuid","propToCheck","anchorFnData","uuidWithProp","_g","positions","targetSel","targets","targetProperty","anchorObjects","positionAreaMappingStyleElement","positionData","targetData","_h","_k","_j","_i","excludeAttributes","transformCSS","updatedStyleData","created","updatedObject","styleEl","attr","pre","mappings","platformWithCache","resolveLogicalSideKeyword","rtl","percentage","resolveLogicalSizeKeyword","vertical","resolved","getAxis","position","getAxisProperty","axis","isInline","getBorders","total","getMargin","dir","getMargins","getPixelValue","anchorRect","startwardProperties","hasPercentage","border","isPositionAreaTarget","applyAnchorPositions","useAnimationFrame","anchorValues","anchorValue","target","wrapper","getPositionAreaPixelValue","inset","appliedId","topInset","bottomInset","leftInset","rightInset","checkOverflow","applyPositionFallbacks","checking","defaultOverflow","lastSuccessful","normalizePolyfillOptions","useAnimationFrameOrOption","parsedCSS"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,105,106]}