{
  "version": 3,
  "sources": ["../src/events.ts", "../src/popover-helpers.ts", "../src/popover.ts", "../src/index.ts"],
  "sourcesContent": ["export interface ToggleInit extends EventInit {\n  oldState: string;\n  newState: string;\n}\n\nexport class ToggleEvent extends Event {\n  public oldState: string;\n  public newState: string;\n  constructor(\n    type: string,\n    { oldState = '', newState = '', ...init }: Partial<ToggleInit> = {},\n  ) {\n    super(type, init);\n    this.oldState = String(oldState || '');\n    this.newState = String(newState || '');\n  }\n}\n\nconst popoverToggleTaskQueue = new WeakMap<HTMLElement, unknown>();\nexport function queuePopoverToggleEventTask(\n  element: HTMLElement,\n  oldState: string,\n  newState: string,\n) {\n  popoverToggleTaskQueue.set(\n    element,\n    setTimeout(() => {\n      if (!popoverToggleTaskQueue.has(element)) return;\n      element.dispatchEvent(\n        new ToggleEvent('toggle', {\n          cancelable: false,\n          oldState,\n          newState,\n        }),\n      );\n    }, 0),\n  );\n}\n", "import { queuePopoverToggleEventTask, ToggleEvent } from './events.js';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst ShadowRoot = globalThis.ShadowRoot || function () {};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst HTMLDialogElement = globalThis.HTMLDialogElement || function () {};\n\nconst topLayerElements = new WeakMap<Document, Set<HTMLElement>>();\nconst autoPopoverList = new WeakMap<Document, Set<HTMLElement>>();\nconst hintPopoverList = new WeakMap<Document, Set<HTMLElement>>();\nexport const visibilityState = new WeakMap<HTMLElement, 'hidden' | 'showing'>();\n\nfunction getPopoverVisibilityState(popover: HTMLElement): 'hidden' | 'showing' {\n  return visibilityState.get(popover) || 'hidden';\n}\n\nconst popoverInvoker = new WeakMap<\n  HTMLElement,\n  HTMLButtonElement | HTMLInputElement\n>();\n\nfunction lastSetElement(set: Set<HTMLElement>) {\n  return [...set].pop() as HTMLElement;\n}\n\n// https://html.spec.whatwg.org/#popover-target-attribute-activation-behavior\nexport function popoverTargetAttributeActivationBehavior(\n  element: HTMLButtonElement | HTMLInputElement,\n) {\n  const popover = element.popoverTargetElement;\n  if (!(popover instanceof HTMLElement)) {\n    return;\n  }\n  const visibility = getPopoverVisibilityState(popover);\n  if (element.popoverTargetAction === 'show' && visibility === 'showing') {\n    return;\n  }\n  if (element.popoverTargetAction === 'hide' && visibility === 'hidden') return;\n  if (visibility === 'showing') {\n    hidePopover(popover, true, true);\n  } else if (checkPopoverValidity(popover, false)) {\n    popoverInvoker.set(popover, element);\n    showPopover(popover);\n  }\n}\n\n// https://html.spec.whatwg.org/#check-popover-validity\nfunction checkPopoverValidity(\n  element: HTMLElement,\n  expectedToBeShowing: boolean,\n) {\n  if (\n    element.popover !== 'auto' &&\n    element.popover !== 'manual' &&\n    element.popover !== 'hint'\n  ) {\n    return false;\n  }\n  if (!element.isConnected) return false;\n  if (expectedToBeShowing && getPopoverVisibilityState(element) !== 'showing') {\n    return false;\n  }\n  if (!expectedToBeShowing && getPopoverVisibilityState(element) !== 'hidden') {\n    return false;\n  }\n  if (element instanceof HTMLDialogElement && element.hasAttribute('open')) {\n    return false;\n  }\n  if (document.fullscreenElement === element) return false;\n  return true;\n}\n\n// https://html.spec.whatwg.org/#get-the-popover-stack-position\nfunction getStackPosition(popover?: HTMLElement) {\n  if (!popover) return 0;\n  const autoPopovers = autoPopoverList.get(document) || new Set();\n  const hintPopovers = hintPopoverList.get(document) || new Set();\n  if (hintPopovers.has(popover)) {\n    return [...hintPopovers].indexOf(popover) + autoPopovers.size + 1;\n  }\n  if (autoPopovers.has(popover)) {\n    return [...autoPopovers].indexOf(popover) + 1;\n  }\n  return 0;\n}\n\n// https://html.spec.whatwg.org/#topmost-clicked-popover\nfunction topMostClickedPopover(target: HTMLElement) {\n  const clickedPopover = nearestInclusiveOpenPopover(target);\n  const invokerPopover = nearestInclusiveTargetPopoverForInvoker(target);\n  if (getStackPosition(clickedPopover) > getStackPosition(invokerPopover)) {\n    return clickedPopover;\n  }\n  return invokerPopover;\n}\n\n// https://html.spec.whatwg.org/#topmost-auto-popover\nfunction topmostAutoOrHintPopover(document: Document): HTMLElement | null {\n  let topmostPopover: HTMLElement;\n  const hintPopovers = hintPopoverList.get(document) || new Set();\n  const autoPopovers = autoPopoverList.get(document) || new Set();\n  const usedStack =\n    hintPopovers.size > 0\n      ? hintPopovers\n      : autoPopovers.size > 0\n        ? autoPopovers\n        : null;\n\n  if (usedStack) {\n    topmostPopover = lastSetElement(usedStack);\n    // This deviates from the spec to verify that the popover is still connected\n    if (!topmostPopover.isConnected) {\n      usedStack.delete(topmostPopover);\n      return topmostAutoOrHintPopover(document);\n    }\n    return topmostPopover;\n  }\n  return null;\n}\n\nfunction topMostPopoverInList(list: Set<HTMLElement>): HTMLElement | null {\n  for (const popover of list || []) {\n    if (!popover.isConnected) {\n      list!.delete(popover);\n    } else {\n      return popover;\n    }\n  }\n  return null;\n}\n\nexport function getRootNode(node: Node): Node {\n  if (typeof node.getRootNode === 'function') {\n    return node.getRootNode();\n  }\n  if (node.parentNode) return getRootNode(node.parentNode);\n  return node;\n}\n\n// https://html.spec.whatwg.org/#nearest-inclusive-open-popover\nfunction nearestInclusiveOpenPopover(\n  node: Node | null,\n): HTMLElement | undefined {\n  while (node) {\n    if (\n      node instanceof HTMLElement &&\n      node.popover === 'auto' &&\n      visibilityState.get(node) === 'showing'\n    ) {\n      return node;\n    }\n    node =\n      (node instanceof Element && node.assignedSlot) ||\n      node.parentElement ||\n      getRootNode(node);\n    if (node instanceof ShadowRoot) node = node.host;\n    if (node instanceof Document) return;\n  }\n}\n\n// https://html.spec.whatwg.org/#popover-light-dismiss:nearest-inclusive-target-popover-for-invoker\nfunction nearestInclusiveTargetPopoverForInvoker(\n  node: Node | null,\n): HTMLElement | undefined {\n  while (node) {\n    const nodePopover = (node as HTMLButtonElement).popoverTargetElement;\n    if (nodePopover instanceof HTMLElement) return nodePopover;\n    node = node.parentElement || getRootNode(node);\n    if (node instanceof ShadowRoot) node = node.host;\n    if (node instanceof Document) return;\n  }\n}\n\n// https://html.spec.whatwg.org/#topmost-popover-ancestor\nfunction topMostPopoverAncestor(\n  newPopover: HTMLElement,\n  list: Set<HTMLElement>,\n): HTMLElement | null {\n  const popoverPositions = new Map();\n  let i = 0;\n  for (const popover of list || []) {\n    popoverPositions.set(popover, i);\n    i += 1;\n  }\n  popoverPositions.set(newPopover, i);\n  i += 1;\n  let topMostPopoverAncestor: HTMLElement | null = null;\n  function checkAncestor(candidate: Node | null) {\n    if (!candidate) return;\n    let okNesting = false;\n    let candidateAncestor: HTMLElement | null = null;\n    let candidatePosition = null;\n    while (!okNesting) {\n      candidateAncestor = nearestInclusiveOpenPopover(candidate) || null;\n      if (candidateAncestor === null) return;\n      if (!popoverPositions.has(candidateAncestor)) return;\n      if (\n        newPopover.popover === 'hint' ||\n        candidateAncestor.popover === 'auto'\n      ) {\n        okNesting = true;\n      }\n      if (!okNesting) {\n        candidate = candidateAncestor.parentElement;\n      }\n    }\n    candidatePosition = popoverPositions.get(candidateAncestor);\n    if (\n      topMostPopoverAncestor === null ||\n      popoverPositions.get(topMostPopoverAncestor) < candidatePosition\n    ) {\n      topMostPopoverAncestor = candidateAncestor!;\n    }\n  }\n  checkAncestor(newPopover.parentElement || getRootNode(newPopover));\n  return topMostPopoverAncestor;\n}\n\nfunction isFocusable(focusTarget: HTMLElement) {\n  if (focusTarget.hidden || focusTarget instanceof ShadowRoot) return false;\n  if (\n    focusTarget instanceof HTMLButtonElement ||\n    focusTarget instanceof HTMLInputElement ||\n    focusTarget instanceof HTMLSelectElement ||\n    focusTarget instanceof HTMLTextAreaElement ||\n    focusTarget instanceof HTMLOptGroupElement ||\n    focusTarget instanceof HTMLOptionElement ||\n    focusTarget instanceof HTMLFieldSetElement\n  ) {\n    if (focusTarget.disabled) return false;\n  }\n  if (\n    focusTarget instanceof HTMLInputElement &&\n    focusTarget.type === 'hidden'\n  ) {\n    return false;\n  }\n  if (focusTarget instanceof HTMLAnchorElement && focusTarget.href === '') {\n    return false;\n  }\n  return (\n    typeof focusTarget.tabIndex === 'number' && focusTarget.tabIndex !== -1\n  );\n}\n\n// This method is not spec compliant, as it also looks in slotted content\n// for autofocus elements.\n// See: https://github.com/oddbird/popover-polyfill/issues/149\n// Spec: https://html.spec.whatwg.org/#focus-delegate\nfunction focusDelegate(focusTarget: HTMLElement) {\n  if (\n    focusTarget.shadowRoot &&\n    focusTarget.shadowRoot.delegatesFocus !== true\n  ) {\n    return null;\n  }\n  let whereToLook: DocumentFragment | HTMLElement = focusTarget;\n  if (whereToLook.shadowRoot) {\n    whereToLook = whereToLook.shadowRoot;\n  }\n  let autoFocusDelegate = whereToLook.querySelector('[autofocus]');\n  if (autoFocusDelegate) {\n    return autoFocusDelegate;\n  } else {\n    const slots = whereToLook.querySelectorAll('slot');\n    for (const slot of slots) {\n      const assignedElements = slot.assignedElements({ flatten: true });\n      for (const el of assignedElements) {\n        if (el.hasAttribute('autofocus')) {\n          return el;\n        } else {\n          autoFocusDelegate = el.querySelector('[autofocus]');\n          if (autoFocusDelegate) {\n            return autoFocusDelegate;\n          }\n        }\n      }\n    }\n  }\n  const walker = focusTarget.ownerDocument.createTreeWalker(\n    whereToLook,\n    NodeFilter.SHOW_ELEMENT,\n  );\n  let descendant: Node | null = walker.currentNode;\n  while (descendant) {\n    // this is not spec compliant\n    if (isFocusable(descendant as HTMLElement)) {\n      return descendant;\n    }\n    descendant = walker.nextNode();\n  }\n}\n\n// https://html.spec.whatwg.org/#popover-focusing-steps\nfunction popoverFocusingSteps(subject: HTMLElement) {\n  (focusDelegate(subject) as HTMLElement)?.focus();\n}\n\nconst previouslyFocusedElements = new WeakMap<HTMLElement, HTMLElement>();\n\n// https://html.spec.whatwg.org/#show-popover\nexport function showPopover(element: HTMLElement) {\n  if (!checkPopoverValidity(element, false)) {\n    return;\n  }\n  const document = element.ownerDocument;\n  if (\n    !element.dispatchEvent(\n      new ToggleEvent('beforetoggle', {\n        cancelable: true,\n        oldState: 'closed',\n        newState: 'open',\n      }),\n    )\n  ) {\n    return;\n  }\n  if (!checkPopoverValidity(element, false)) {\n    return;\n  }\n  let shouldRestoreFocus = false;\n  const originalType = element.popover;\n  let stackToAppendTo = null;\n  const autoAncestor = topMostPopoverAncestor(\n    element,\n    autoPopoverList.get(document) || new Set(),\n  );\n  const hintAncestor = topMostPopoverAncestor(\n    element,\n    hintPopoverList.get(document) || new Set(),\n  );\n  if (originalType === 'auto') {\n    // Close all hint popovers\n    closeAllOpenPopoversInList(\n      hintPopoverList.get(document) || new Set(),\n      shouldRestoreFocus,\n      true,\n    );\n    const ancestor = autoAncestor || document;\n    hideAllPopoversUntil(ancestor, shouldRestoreFocus, true);\n    stackToAppendTo = 'auto';\n  }\n  if (originalType === 'hint') {\n    if (hintAncestor) {\n      hideAllPopoversUntil(hintAncestor, shouldRestoreFocus, true);\n      stackToAppendTo = 'hint';\n    } else {\n      // Close all hint popovers\n      closeAllOpenPopoversInList(\n        hintPopoverList.get(document) || new Set(),\n        shouldRestoreFocus,\n        true,\n      );\n      if (autoAncestor) {\n        hideAllPopoversUntil(autoAncestor, shouldRestoreFocus, true);\n        stackToAppendTo = 'auto';\n      } else {\n        stackToAppendTo = 'hint';\n      }\n    }\n  }\n\n  if (originalType === 'auto' || originalType === 'hint') {\n    if (\n      originalType !== element.popover ||\n      !checkPopoverValidity(element, false)\n    ) {\n      return;\n    }\n\n    if (!topmostAutoOrHintPopover(document)) {\n      shouldRestoreFocus = true;\n    }\n\n    if (stackToAppendTo === 'auto') {\n      if (!autoPopoverList.has(document)) {\n        autoPopoverList.set(document, new Set());\n      }\n      autoPopoverList.get(document)!.add(element);\n    } else if (stackToAppendTo === 'hint') {\n      if (!hintPopoverList.has(document)) {\n        hintPopoverList.set(document, new Set());\n      }\n      hintPopoverList.get(document)!.add(element);\n    }\n  }\n\n  previouslyFocusedElements.delete(element);\n  const originallyFocusedElement = document.activeElement as HTMLElement;\n  element.classList.add(':popover-open');\n  visibilityState.set(element, 'showing');\n  if (!topLayerElements.has(document)) {\n    topLayerElements.set(document, new Set());\n  }\n  topLayerElements.get(document)!.add(element);\n  setInvokerAriaExpanded(popoverInvoker.get(element), true);\n  popoverFocusingSteps(element);\n  if (\n    shouldRestoreFocus &&\n    originallyFocusedElement &&\n    element.popover === 'auto'\n  ) {\n    previouslyFocusedElements.set(element, originallyFocusedElement);\n  }\n  queuePopoverToggleEventTask(element, 'closed', 'open');\n}\n\n// https://html.spec.whatwg.org/#hide-popover-algorithm\nexport function hidePopover(\n  element: HTMLElement,\n  focusPreviousElement = false,\n  fireEvents = false,\n) {\n  if (!checkPopoverValidity(element, true)) {\n    return;\n  }\n  const document = element.ownerDocument;\n  if (['auto', 'hint'].includes(element.popover as string)) {\n    hideAllPopoversUntil(element, focusPreviousElement, fireEvents);\n    if (!checkPopoverValidity(element, true)) {\n      return;\n    }\n  }\n  const autoList = autoPopoverList.get(document) || new Set();\n  const autoPopoverListContainsElement =\n    autoList.has(element) && lastSetElement(autoList) === element;\n  setInvokerAriaExpanded(popoverInvoker.get(element), false);\n  popoverInvoker.delete(element);\n  if (fireEvents) {\n    element.dispatchEvent(\n      new ToggleEvent('beforetoggle', {\n        oldState: 'open',\n        newState: 'closed',\n      }),\n    );\n    if (\n      autoPopoverListContainsElement &&\n      lastSetElement(autoList) !== element\n    ) {\n      hideAllPopoversUntil(element, focusPreviousElement, fireEvents);\n    }\n    if (!checkPopoverValidity(element, true)) {\n      return;\n    }\n  }\n  topLayerElements.get(document)?.delete(element);\n  autoList.delete(element);\n  hintPopoverList.get(document)?.delete(element);\n  element.classList.remove(':popover-open');\n  visibilityState.set(element, 'hidden');\n  if (fireEvents) {\n    queuePopoverToggleEventTask(element, 'open', 'closed');\n  }\n  const previouslyFocusedElement = previouslyFocusedElements.get(element);\n  if (previouslyFocusedElement) {\n    previouslyFocusedElements.delete(element);\n    if (focusPreviousElement) {\n      previouslyFocusedElement.focus();\n    }\n  }\n}\n\nfunction closeAllOpenPopovers(\n  document: Document,\n  focusPreviousElement = false,\n  fireEvents = false,\n) {\n  let popover = topmostAutoOrHintPopover(document);\n  while (popover) {\n    hidePopover(popover, focusPreviousElement, fireEvents);\n    popover = topmostAutoOrHintPopover(document);\n  }\n}\n\nfunction closeAllOpenPopoversInList(\n  list: Set<HTMLElement>,\n  focusPreviousElement = false,\n  fireEvents = false,\n) {\n  let popover = topMostPopoverInList(list);\n  while (popover) {\n    hidePopover(popover, focusPreviousElement, fireEvents);\n    popover = topMostPopoverInList(list);\n  }\n}\n\n// https://html.spec.whatwg.org/#hide-popover-stack-until\nfunction hidePopoverStackUntil(\n  endpoint: Element | Document,\n  set: Set<HTMLElement>,\n  focusPreviousElement: boolean,\n  fireEvents: boolean,\n) {\n  let repeatingHide = false;\n  let hasRunOnce = false;\n  // This deviates from the latest version of the spec, which has a bug:\n  // https://github.com/whatwg/html/issues/11007\n  while (repeatingHide || !hasRunOnce) {\n    hasRunOnce = true;\n    let lastToHide = null;\n    let foundEndpoint = false;\n    for (const popover of set) {\n      if (popover === endpoint) {\n        foundEndpoint = true;\n      } else if (foundEndpoint) {\n        lastToHide = popover;\n        break;\n      }\n    }\n    if (!lastToHide) return;\n    while (getPopoverVisibilityState(lastToHide) === 'showing' && set.size) {\n      hidePopover(lastSetElement(set), focusPreviousElement, fireEvents);\n    }\n    if (set.has(endpoint as HTMLElement) && lastSetElement(set) !== endpoint) {\n      repeatingHide = true;\n    }\n    if (repeatingHide) {\n      fireEvents = false;\n    }\n  }\n}\n\n// https://html.spec.whatwg.org/#hide-all-popovers-until\nexport function hideAllPopoversUntil(\n  endpoint: Element | Document,\n  focusPreviousElement: boolean,\n  fireEvents: boolean,\n) {\n  const document = endpoint.ownerDocument || endpoint;\n  if (endpoint instanceof Document) {\n    return closeAllOpenPopovers(document, focusPreviousElement, fireEvents);\n  }\n  if (hintPopoverList.get(document)?.has(endpoint as HTMLElement)) {\n    hidePopoverStackUntil(\n      endpoint,\n      hintPopoverList.get(document)!,\n      focusPreviousElement,\n      fireEvents,\n    );\n    return;\n  }\n  closeAllOpenPopoversInList(\n    hintPopoverList.get(document) || new Set(),\n    focusPreviousElement,\n    fireEvents,\n  );\n\n  if (!autoPopoverList.get(document)?.has(endpoint as HTMLElement)) {\n    return;\n  }\n\n  hidePopoverStackUntil(\n    endpoint,\n    autoPopoverList.get(document)!,\n    focusPreviousElement,\n    fireEvents,\n  );\n}\n\nconst popoverPointerDownTargets = new WeakMap<Document, HTMLElement>();\n// https://html.spec.whatwg.org/#topmost-clicked-popover\nexport function lightDismissOpenPopovers(event: Event) {\n  if (!event.isTrusted) return;\n  // Composed path allows us to find the target within shadowroots\n  const target = event.composedPath()[0] as HTMLElement;\n  if (!target) return;\n  const document = target.ownerDocument;\n  const topMostPopover = topmostAutoOrHintPopover(document);\n  if (!topMostPopover) return;\n  const ancestor = topMostClickedPopover(target);\n  if (ancestor && event.type === 'pointerdown') {\n    popoverPointerDownTargets.set(document, ancestor);\n  } else if (event.type === 'pointerup') {\n    const sameTarget = popoverPointerDownTargets.get(document) === ancestor;\n    popoverPointerDownTargets.delete(document);\n    if (sameTarget) {\n      hideAllPopoversUntil(ancestor || document, false, true);\n    }\n  }\n}\n\nconst initialAriaExpandedValue = new WeakMap<\n  HTMLButtonElement | HTMLInputElement,\n  null | string\n>();\n\nfunction setInvokerAriaExpanded(\n  el?: HTMLButtonElement | HTMLInputElement,\n  force = false,\n) {\n  if (!el) return;\n  if (!initialAriaExpandedValue.has(el)) {\n    initialAriaExpandedValue.set(el, el.getAttribute('aria-expanded'));\n  }\n  const popover = el.popoverTargetElement;\n  if (popover instanceof HTMLElement && popover.popover === 'auto') {\n    el.setAttribute('aria-expanded', String(force));\n  } else {\n    const initialValue = initialAriaExpandedValue.get(el);\n    if (!initialValue) {\n      el.removeAttribute('aria-expanded');\n    } else {\n      el.setAttribute('aria-expanded', initialValue);\n    }\n  }\n}\n", "import { ToggleEvent } from './events.js';\nimport {\n  getRootNode,\n  hideAllPopoversUntil,\n  hidePopover,\n  lightDismissOpenPopovers,\n  popoverTargetAttributeActivationBehavior,\n  showPopover,\n  visibilityState,\n} from './popover-helpers.js';\nimport type {\n  PopoverShowPopoverOptions,\n  PopoverTogglePopoverOptions,\n} from './shared-types.js';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst ShadowRoot = globalThis.ShadowRoot || function () {};\n\nexport function isSupported() {\n  return (\n    typeof HTMLElement !== 'undefined' &&\n    typeof HTMLElement.prototype === 'object' &&\n    'popover' in HTMLElement.prototype\n  );\n}\n\nexport function isHintSupported() {\n  const el = document.createElement('div');\n  el.setAttribute('popover', 'hint');\n  // `el.popover` is \"manual\" in non-supporting browsers\n  return el.popover === 'hint';\n}\n\nexport function isPolyfilled() {\n  // if the `showPopover` method is defined but is not \"native code\"\n  // then we can infer it's been polyfilled\n  return Boolean(\n    document.body?.showPopover &&\n      !/native code/i.test(document.body.showPopover.toString()),\n  );\n}\n\nfunction patchSelectorFn<K extends string>(\n  object: Record<PropertyKey & K, unknown>,\n  name: K,\n  mapper: (selector: string) => string,\n) {\n  const original = object[name] as (selectors: string) => NodeList;\n  Object.defineProperty(object, name, {\n    value(selector: string) {\n      return original.call(this, mapper(selector));\n    },\n  });\n}\n\nconst nonEscapedPopoverSelector = /(^|[^\\\\]):popover-open\\b/g;\n\nfunction hasLayerSupport() {\n  return typeof globalThis.CSSLayerBlockRule === 'function';\n}\n\n// To emulate a UA stylesheet which is the lowest priority in the cascade,\n// all selectors must be wrapped in a :where() which has a specificity of zero.\nfunction getStyles() {\n  const useLayer = hasLayerSupport();\n  return `\n${useLayer ? '@layer popover-polyfill {' : ''}\n  :where([popover]) {\n    position: fixed;\n    z-index: 2147483647;\n    inset: 0;\n    padding: 0.25em;\n    width: fit-content;\n    height: fit-content;\n    border-width: initial;\n    border-color: initial;\n    border-image: initial;\n    border-style: solid;\n    background-color: canvas;\n    color: canvastext;\n    overflow: auto;\n    margin: auto;\n  }\n\n  :where([popover]:not(.\\\\:popover-open)) {\n    display: none;\n  }\n\n  :where(dialog[popover].\\\\:popover-open) {\n    display: block;\n  }\n\n  :where(dialog[popover][open]) {\n    display: revert;\n  }\n\n  :where([anchor].\\\\:popover-open) {\n    inset: auto;\n  }\n\n  :where([anchor]:popover-open) {\n    inset: auto;\n  }\n\n  @supports not (background-color: canvas) {\n    :where([popover]) {\n      background-color: white;\n      color: black;\n    }\n  }\n\n  @supports (width: -moz-fit-content) {\n    :where([popover]) {\n      width: -moz-fit-content;\n      height: -moz-fit-content;\n    }\n  }\n\n  @supports not (inset: 0) {\n    :where([popover]) {\n      top: 0;\n      left: 0;\n      right: 0;\n      bottom: 0;\n    }\n  }\n${useLayer ? '}' : ''}\n`;\n}\n\nlet popoverStyleSheet: null | false | CSSStyleSheet = null;\nexport function injectStyles(root: Document | ShadowRoot) {\n  const styles = getStyles();\n  if (popoverStyleSheet === null) {\n    try {\n      popoverStyleSheet = new CSSStyleSheet();\n      popoverStyleSheet.replaceSync(styles);\n    } catch {\n      popoverStyleSheet = false;\n    }\n  }\n  if (popoverStyleSheet === false) {\n    const sheet = document.createElement('style');\n    sheet.textContent = styles;\n    if (root instanceof Document) {\n      root.head.prepend(sheet);\n    } else {\n      root.prepend(sheet);\n    }\n  } else {\n    root.adoptedStyleSheets = [popoverStyleSheet, ...root.adoptedStyleSheets];\n  }\n}\n\nexport function apply() {\n  if (typeof window === 'undefined') return;\n\n  window.ToggleEvent = window.ToggleEvent || ToggleEvent;\n\n  function rewriteSelector(selector: string) {\n    if (selector?.includes(':popover-open')) {\n      selector = selector.replace(\n        nonEscapedPopoverSelector,\n        '$1.\\\\:popover-open',\n      );\n    }\n    return selector;\n  }\n\n  patchSelectorFn(Document.prototype, 'querySelector', rewriteSelector);\n  patchSelectorFn(Document.prototype, 'querySelectorAll', rewriteSelector);\n  patchSelectorFn(Element.prototype, 'querySelector', rewriteSelector);\n  patchSelectorFn(Element.prototype, 'querySelectorAll', rewriteSelector);\n  patchSelectorFn(Element.prototype, 'matches', rewriteSelector);\n  patchSelectorFn(Element.prototype, 'closest', rewriteSelector);\n  patchSelectorFn(\n    DocumentFragment.prototype,\n    'querySelectorAll',\n    rewriteSelector,\n  );\n\n  Object.defineProperties(HTMLElement.prototype, {\n    popover: {\n      enumerable: true,\n      configurable: true,\n      get() {\n        if (!this.hasAttribute('popover')) return null;\n        const value = (this.getAttribute('popover') || '').toLowerCase();\n        if (value === '' || value == 'auto') return 'auto';\n        if (value == 'hint') return 'hint';\n        return 'manual';\n      },\n      set(value) {\n        if (value === null) {\n          this.removeAttribute('popover');\n        } else {\n          this.setAttribute('popover', value);\n        }\n      },\n    },\n\n    showPopover: {\n      enumerable: true,\n      configurable: true,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      value(options: PopoverShowPopoverOptions = {}) {\n        showPopover(this);\n      },\n    },\n\n    hidePopover: {\n      enumerable: true,\n      configurable: true,\n      value() {\n        hidePopover(this, true, true);\n      },\n    },\n\n    togglePopover: {\n      enumerable: true,\n      configurable: true,\n      value(options: boolean | PopoverTogglePopoverOptions = {}): boolean {\n        if (typeof options === 'boolean') {\n          options = { force: options };\n        }\n        // This differs from the spec, in that the `if` includes instances when\n        // popover is hidden and force=false. In that case, the spec only runs\n        // `check popover validity`. Because the polyfill doesn't throw errors\n        // in `check popover validity`, we pass this case to `hide popover`,\n        // which immediately checks popover validity and returns as a noop.\n        if (\n          (visibilityState.get(this) === 'showing' &&\n            options.force === undefined) ||\n          options.force === false\n        ) {\n          hidePopover(this, true, true);\n        } else if (options.force === undefined || options.force === true) {\n          showPopover(this);\n        }\n        return visibilityState.get(this) === 'showing';\n      },\n    },\n  });\n\n  const originalAttachShadow = Element.prototype.attachShadow;\n  if (originalAttachShadow) {\n    Object.defineProperties(Element.prototype, {\n      attachShadow: {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value(options: ShadowRootInit) {\n          const shadowRoot = originalAttachShadow.call(this, options);\n          injectStyles(shadowRoot);\n          return shadowRoot;\n        },\n      },\n    });\n  }\n  const originalAttachInternals = HTMLElement.prototype.attachInternals;\n  if (originalAttachInternals) {\n    Object.defineProperties(HTMLElement.prototype, {\n      attachInternals: {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value() {\n          const internals = originalAttachInternals.call(this);\n          if (internals.shadowRoot) {\n            injectStyles(internals.shadowRoot);\n          }\n          return internals;\n        },\n      },\n    });\n  }\n\n  const popoverTargetAssociatedElements = new WeakMap<Element, Element>();\n  function applyPopoverInvokerElementMixin(ElementClass: typeof HTMLElement) {\n    Object.defineProperties(ElementClass.prototype, {\n      popoverTargetElement: {\n        enumerable: true,\n        configurable: true,\n        set(targetElement: unknown) {\n          if (targetElement === null) {\n            this.removeAttribute('popovertarget');\n            popoverTargetAssociatedElements.delete(this);\n          } else if (!(targetElement instanceof Element)) {\n            throw new TypeError(\n              `popoverTargetElement must be an element or null`,\n            );\n          } else {\n            this.setAttribute('popovertarget', '');\n            popoverTargetAssociatedElements.set(this, targetElement);\n          }\n        },\n        get() {\n          if (this.localName !== 'button' && this.localName !== 'input') {\n            return null;\n          }\n          if (\n            this.localName === 'input' &&\n            this.type !== 'reset' &&\n            this.type !== 'image' &&\n            this.type !== 'button'\n          ) {\n            return null;\n          }\n          if (this.disabled) {\n            return null;\n          }\n          if (this.form && this.type === 'submit') {\n            return null;\n          }\n          const targetElement = popoverTargetAssociatedElements.get(this);\n          if (targetElement && targetElement.isConnected) {\n            return targetElement;\n          } else if (targetElement && !targetElement.isConnected) {\n            popoverTargetAssociatedElements.delete(this);\n            return null;\n          }\n          const root = getRootNode(this);\n          const idref = this.getAttribute('popovertarget');\n          if (\n            (root instanceof Document || root instanceof ShadowRoot) &&\n            idref\n          ) {\n            return root.getElementById(idref) || null;\n          }\n          return null;\n        },\n      },\n      popoverTargetAction: {\n        enumerable: true,\n        configurable: true,\n        get() {\n          const value = (\n            this.getAttribute('popovertargetaction') || ''\n          ).toLowerCase();\n          if (value === 'show' || value === 'hide') return value;\n          return 'toggle';\n        },\n        set(value) {\n          this.setAttribute('popovertargetaction', value);\n        },\n      },\n    });\n  }\n\n  applyPopoverInvokerElementMixin(HTMLButtonElement);\n  applyPopoverInvokerElementMixin(HTMLInputElement);\n\n  const handleInvokerActivation = (event: Event) => {\n    if (event.defaultPrevented) {\n      return;\n    }\n    // Composed path allows us to find the target within shadowroots\n    const composedPath = event.composedPath() as HTMLElement[];\n    const target = composedPath[0];\n    if (!(target instanceof Element) || target?.shadowRoot) {\n      return;\n    }\n    const root = getRootNode(target);\n    if (!(root instanceof ShadowRoot || root instanceof Document)) {\n      return;\n    }\n    const invoker = composedPath.find((el) =>\n      el.matches?.('[popovertargetaction],[popovertarget]'),\n    );\n    if (invoker) {\n      popoverTargetAttributeActivationBehavior(invoker as HTMLButtonElement);\n      event.preventDefault();\n      return;\n    }\n  };\n\n  const onKeydown = (event: Event) => {\n    const key = (event as KeyboardEvent).key;\n    const target = event.target as Element;\n    if (\n      !event.defaultPrevented &&\n      target &&\n      (key === 'Escape' || key === 'Esc')\n    ) {\n      hideAllPopoversUntil(target.ownerDocument, true, true);\n    }\n  };\n\n  const addEventListeners = (root: Document | ShadowRoot) => {\n    root.addEventListener('click', handleInvokerActivation);\n    root.addEventListener('keydown', onKeydown);\n    root.addEventListener('pointerdown', lightDismissOpenPopovers);\n    root.addEventListener('pointerup', lightDismissOpenPopovers);\n  };\n\n  addEventListeners(document);\n  injectStyles(document);\n}\n", "import { apply, isSupported } from './popover.js';\nimport type {\n  PopoverShowPopoverOptions,\n  PopoverTogglePopoverOptions,\n  PopoverToggleTargetElementInvoker,\n} from './shared-types.js';\n\ndeclare global {\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ToggleEvent) */\n  interface ToggleEvent extends Event {\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ToggleEvent/newState) */\n    readonly newState: string;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ToggleEvent/oldState) */\n    readonly oldState: string;\n  }\n\n  interface HTMLElement {\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLElement/popover) */\n    popover: string | null;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLElement/hidePopover) */\n    hidePopover(): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLElement/showPopover) */\n    showPopover(options?: PopoverShowPopoverOptions): void;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLElement/togglePopover) */\n    togglePopover(force?: boolean): boolean;\n    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLElement/togglePopover) */\n    togglePopover(options?: PopoverTogglePopoverOptions): boolean;\n  }\n\n  /* eslint-disable @typescript-eslint/no-empty-object-type */\n  interface HTMLButtonElement extends PopoverToggleTargetElementInvoker {}\n  interface HTMLInputElement extends PopoverToggleTargetElementInvoker {}\n  /* eslint-enable @typescript-eslint/no-empty-object-type */\n\n  interface Window {\n    ToggleEvent: ToggleEvent;\n  }\n}\n\nif (!isSupported()) apply();\n"],
  "mappings": "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",
  "names": ["ToggleEvent", "type", "oldState", "newState", "init", "popoverToggleTaskQueue", "queuePopoverToggleEventTask", "element", "ShadowRoot", "HTMLDialogElement", "topLayerElements", "autoPopoverList", "hintPopoverList", "visibilityState", "getPopoverVisibilityState", "popover", "popoverInvoker", "lastSetElement", "set", "popoverTargetAttributeActivationBehavior", "element", "visibility", "hidePopover", "checkPopoverValidity", "showPopover", "expectedToBeShowing", "getStackPosition", "autoPopovers", "hintPopovers", "topMostClickedPopover", "target", "clickedPopover", "nearestInclusiveOpenPopover", "invokerPopover", "nearestInclusiveTargetPopoverForInvoker", "topmostAutoOrHintPopover", "document", "topmostPopover", "usedStack", "topMostPopoverInList", "list", "getRootNode", "node", "nodePopover", "topMostPopoverAncestor", "newPopover", "popoverPositions", "i", "checkAncestor", "candidate", "okNesting", "candidateAncestor", "candidatePosition", "isFocusable", "focusTarget", "focusDelegate", "whereToLook", "autoFocusDelegate", "slots", "slot", "assignedElements", "el", "walker", "descendant", "popoverFocusingSteps", "subject", "_a", "previouslyFocusedElements", "ToggleEvent", "shouldRestoreFocus", "originalType", "stackToAppendTo", "autoAncestor", "hintAncestor", "closeAllOpenPopoversInList", "hideAllPopoversUntil", "originallyFocusedElement", "setInvokerAriaExpanded", "queuePopoverToggleEventTask", "focusPreviousElement", "fireEvents", "_b", "autoList", "autoPopoverListContainsElement", "previouslyFocusedElement", "closeAllOpenPopovers", "hidePopoverStackUntil", "endpoint", "repeatingHide", "hasRunOnce", "lastToHide", "foundEndpoint", "popoverPointerDownTargets", "lightDismissOpenPopovers", "event", "ancestor", "sameTarget", "initialAriaExpandedValue", "force", "initialValue", "ShadowRoot", "isSupported", "patchSelectorFn", "object", "name", "mapper", "original", "selector", "nonEscapedPopoverSelector", "hasLayerSupport", "getStyles", "useLayer", "popoverStyleSheet", "injectStyles", "root", "styles", "sheet", "apply", "ToggleEvent", "rewriteSelector", "value", "options", "showPopover", "hidePopover", "visibilityState", "originalAttachShadow", "shadowRoot", "originalAttachInternals", "internals", "popoverTargetAssociatedElements", "applyPopoverInvokerElementMixin", "ElementClass", "targetElement", "getRootNode", "idref", "ShadowRoot", "handleInvokerActivation", "event", "composedPath", "target", "invoker", "el", "_a", "popoverTargetAttributeActivationBehavior", "onKeydown", "key", "hideAllPopoversUntil", "lightDismissOpenPopovers", "isSupported", "apply"]
}
